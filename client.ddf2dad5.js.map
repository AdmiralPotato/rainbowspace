{"version":3,"sources":["webpack:///client.ddf2dad5.js","webpack:///webpack/bootstrap 0491c5246d2f421ccacf","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./src/state.js","webpack:///./src/mixin-input.js","webpack:///./src/viewport.js","webpack:///./~/vue/dist/vue.runtime.esm.js","webpack:///./src/vertifier.js","webpack:///./~/three/build/three.js","webpack:///./src/input-button.vue","webpack:///./~/vue-cli/lib/default-entry.es6","webpack:///app.vue","webpack:///existing-dom-node.vue","webpack:///input-button.vue","webpack:///input-check.vue","webpack:///input-select.vue","webpack:///input-toggle.vue","webpack:///settings.vue","webpack:///viewport.vue","webpack:///./src/app.vue","webpack:///./src/existing-dom-node.vue","webpack:///./src/input-check.vue","webpack:///./src/input-select.vue","webpack:///./src/input-toggle.vue","webpack:///./src/settings.vue","webpack:///./src/viewport.vue","webpack:///./src/input-select.vue?1e3f","webpack:///./src/input-check.vue?a0f0","webpack:///./src/viewport.vue?805f","webpack:///./src/settings.vue?a9a9","webpack:///./src/existing-dom-node.vue?6c2c","webpack:///./src/app.vue?5968","webpack:///./src/input-button.vue?d345","webpack:///(webpack)/buildin/global.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","type","default","options","render","staticRenderFns","_scopeId","computed","keys","forEach","key","__webpack_exports__","autoRotateY","autoRotateX","scaleImages","showBounds","image","imageList","text","displayMethod","displayMethodList","cameraMode","cameraModeList","cameraPosition","cameraPositionList","cameraPositionKeymap","Numpad7-0","Numpad1-0","Numpad3-0","Numpad0-0","Numpad7-1","Numpad1-1","Numpad3-1","Numpad0-1","backgroundColor","backgroundColorList","buttonMixin","__WEBPACK_IMPORTED_MODULE_0_vue__","__WEBPACK_IMPORTED_MODULE_1__state__","data","id","this","_uid","internalValue","props","label","String","destinationAddress","methods","change","set","watch","newValue","toLocaleLowerCase","classObject","active","btn-primary","btn-light","displayLabel","click","resizeWindowEventHandler","__WEBPACK_IMPORTED_MODULE_0__state__","__WEBPACK_IMPORTED_MODULE_1__vertifier__","__WEBPACK_IMPORTED_MODULE_2_three__","viewportList","Viewport","renderCanvas","vueComponentInstance","dataCanvas","width","height","dragging","dragPosLast","dragDiff","scene","cameraMap","perspective","orthographic","position","z","orthographicMultiplier","camera","renderer","canvas","antialias","alpha","vue","ambientLight","add","boundingGeometry","Cone","Cones","Cube","Cylinder","Sphere","radialSegments","boundsMaterial","wireframe","opacity","color","setHSL","transparent","bounds","undefined","scale","setScalar","origin","rotation","x","Math","PI","vertifier","imageUrl","callback","remove","particleSystem","grid","y","material","wireframeLinewidth","sizeWindow","push","window","viewport","cameraPositionMap","top","front","right","wcorner","bottom","back","left","bcorner","ratio","devicePixelRatio","clientWidth","clientHeight","aspect","updateProjectionMatrix","updateOrthographicCameraScale","setViewport","orthographicScale","min","oWidth","oHeight","time","fromArray","loadImage","mapMethodName","geomName","slice","boundingGeom","geometry","mapColorsToVerts","visible","dragStart","dragMove","current","clone","sub","dragStop","scroll","num","max","item","renderAllViews","go","requestAnimationFrame","global","isUndef","v","isDef","isTrue","isFalse","isPrimitive","isObject","obj","isPlainObject","_toString","isRegExp","isValidArrayIndex","val","parseFloat","floor","isFinite","toString","JSON","stringify","toNumber","isNaN","makeMap","str","expectsLowerCase","map","create","list","split","length","toLowerCase","arr","index","indexOf","splice","hasOwn","cached","fn","cache","bind","ctx","boundFn","a","arguments","apply","_length","toArray","start","ret","Array","extend","to","_from","toObject","res","noop","b","looseEqual","isObjectA","isObjectB","isArrayA","isArray","isArrayB","every","e","keysA","keysB","looseIndexOf","once","called","isReserved","charCodeAt","def","writable","parsePath","path","bailRE","test","segments","handleError","err","vm","info","config","errorHandler","inBrowser","console","error","isNative","Ctor","pushTarget","_target","Dep","target","targetStack","popTarget","pop","protoAugment","src","__proto__","copyAugment","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","shallow","dep","getOwnPropertyDescriptor","setter","childOb","depend","dependArray","newVal","notify","del","mergeData","from","toVal","fromVal","mergeDataOrFn","parentVal","childVal","instanceData","defaultData","mergeHook","concat","mergeAssets","normalizeProps","camelize","normalizeInject","inject","normalized","normalizeDirectives","dirs","directives","update","mergeOptions","parent","child","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","resolveAsset","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","isType","Boolean","hyphenate","getPropDefaultValue","prevShouldConvert","$options","_props","getType","match","len","createTextVNode","VNode","cloneVNode","vnode","deep","cloned","tag","children","elm","context","componentOptions","asyncFactory","ns","isStatic","isComment","isCloned","cloneVNodes","vnodes","createFnInvoker","fns","invoker","arguments$1","prioritizePlainEvents","plain","updateListeners","on","oldOn","remove$$1","cur","old","event","toAdd","hasModifier","normalizeEvent","handler","sort","event$1","capture","passive","mergeVNodeHook","hookKey","hook","wrappedHook","oldHook","merged","extractPropsFromVNodeData","attrs","altKey","checkProp","hash","preserve","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","isTextNode","node","nestedIndex","last","_isVList","ensureCtor","comp","base","createAsyncPlaceholder","factory","createEmptyVNode","asyncMeta","resolveAsyncComponent","baseCtor","errorComp","resolved","loading","loadingComp","contexts","sync","forceRender","$forceUpdate","resolve","reject","reason","then","component","delay","setTimeout","timeout","isAsyncPlaceholder","getFirstComponentChild","initEvents","_events","_hasHookEvent","listeners","_parentListeners","updateComponentListeners","once$$1","$once","$on","remove$1","$off","oldListeners","resolveSlots","slots","defaultSlot","slot","functionalContext","isWhitespace","resolveScopedSlots","initLifecycle","abstract","$parent","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","el","hydrating","$el","callHook","updateComponent","_update","_render","Watcher","$vnode","updateChildComponent","parentVnode","renderChildren","hasChildren","_renderChildren","scopedSlots","$scopedSlots","emptyObject","_parentVnode","_vnode","$attrs","$listeners","propKeys","_propKeys","$slots","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","handlers","j","$emit","resetSchedulerState","queue","activatedChildren","has","waiting","flushing","flushSchedulerQueue","watcher","run","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","devtools","emit","queueActivatedComponent","queueWatcher","nextTick","traverse","seenObjects","clear","_traverse","seen","isA","depId","proxy","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","initProps","initMethods","initData","_data","initComputed","nativeWatch","initWatch","propsOptions","isRoot","getData","watchers","_computedWatchers","isSSR","userDef","computedWatcherOptions","defineComputed","shouldCache","createComputedGetter","dirty","evaluate","createWatcher","keyOrFn","$watch","initProvide","provide","_provided","initInjections","result","resolveInject","hasSymbol","Reflect","ownKeys","filter","provideKey","source","createFunctionalComponent","mergeProps","_context","h","createElement","injections","functionalOptions","createComponent","_base","cid","resolveConstructorOptions","model","transformModel","functional","nativeOn","mergeHooks","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","_parentElm","_refElm","inlineTemplate","hooksToMerge","fromParent","ours","componentVNodeHooks","mergeHook$1","one","two","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","is","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","renderList","renderSlot","fallback","bindObject","scopedSlotFn","slotNodes","resolveFilter","identity","checkKeyCodes","eventKeyCode","builtInAlias","keyCodes","bindObjectProps","asProp","isSync","isReservedAttribute","mustUseProp","domProps","$event","renderStatic","isInFor","tree","_staticTrees","_renderProxy","markStatic","markOnce","isOnce","markStaticNode","bindObjectListeners","existing","initRender","renderContext","_c","$createElement","parentData","initInternalComponent","constructor","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","extended","sealed","sealedOptions","dedupe","Vue$3","_init","initUse","Vue","use","plugin","installedPlugins","_installedPlugins","args","unshift","install","initMixin$1","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","initProps$1","initComputed$1","ASSET_TYPES","Comp","initAssetRegisters","definition","getComponentName","matches","pattern","pruneCache","cachedNode","pruneCacheEntry","componentInstance","$destroy","genClassForVnode","parentNode","childNode","mergeClassData","renderClass","staticClass","class","dynamicClass","stringifyClass","stringifyArray","stringifyObject","stringified","isSVG","isUnknownElement","unknownElementCache","document","HTMLUnknownElement","HTMLElement","query","selected","querySelector","createElement$1","tagName","multiple","setAttribute","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","registerRef","isRemoval","ref","refs","refInFor","sameVnode","sameInputType","typeA","typeB","isTextInputType","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","dir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","join","updateAttrs","inheritAttrs","oldAttrs","setAttr","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","removeAttribute","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","normalizeEvents","RANGE_TOKEN","isIE","CHECKBOX_RADIO_TOKEN","isChrome","add$1","oldHandler","target$1","ev","remove$2","addEventListener","supportsPassive","removeEventListener","updateDOMListeners","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","notInFocus","activeElement","_vModifiers","number","trim","normalizeStyleData","style","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","setProp","addClass","classList","getAttribute","removeClass","tar","replace","resolveTransition","def$$1","css","autoCssTransition","nextFrame","raf","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","expectedType","cb","getTransitionInfo","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","end","onEnd","styles","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","Number","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","activeInstance","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","_","setSelected","binding","actuallySetSelected","isEdge","isMultiple","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","dy","moved","transform","WebkitTransform","transitionDuration","camelizeRE","toUpperCase","charAt","hyphenateRE","no","SSR_ATTR","LIFECYCLE_HOOKS","optionMergeStrategies","silent","productionTip","performance","warnHandler","ignoredElements","isReservedAttr","_lifecycleHooks","freeze","warn","hasProto","UA","navigator","userAgent","isAndroid","isIOS","_isServer","_Set","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","Symbol","nextTickHandler","pending","copies","callbacks","timerFunc","Promise","logError","catch","MutationObserver","counter","observer","textNode","characterData","_resolve","Set","uid$1","subs","addSub","removeSub","addDep","arrayProto","arrayMethods","method","original","observeArray","arrayKeys","getOwnPropertyNames","walk","items","raw","prototypeAccessors","defineProperties","uid$2","expOrFn","user","lazy","deps","newDeps","depIds","newDepIds","expression","cleanupDeps","this$1","tmp","teardown","init","$mount","keepAlive","mountedNode","prepatch","insert","destroy","uid","_self","dataDef","propsDef","$set","$delete","immediate","hookRE","cbs","i$1","prevEl","prevVnode","prevActiveInstance","__patch__","__vue__","$nextTick","_rendered","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","_u","_g","patternTypes","RegExp","KeepAlive","include","exclude","created","destroyed","builtInComponents","configDef","util","defineReactive","delete","ssrContext","version","emptyStyle","acceptValue","attr","svg","math","isHTMLTag","nodeOps","hooks","baseModules","klass","events","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","normalizedName","normalize","vendorNames","capName","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","activate","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","ref$$1","ancestor","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","findIdxInOld","hydrate","postpatch","invokeInsertHook","initial","hasChildNodes","innerHTML","childrenMatch","firstChild","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","parentElm$1","patchable","i$2","vmodel","model$1","_vOptions","prevOptions","curOptions","some","transition$$1","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","cloneNode","platformComponents","__WEBPACK_IMPORTED_MODULE_1_three__","Vertifier","t","break","loader","vertexGeom","vertexMaterial","size","sizeAttenuation","vertexColors","loadedImageMap","loadedGeomMap","crossOriginProxy","tryWithCrossOrigin","imageKey","log","swapGeometry","makeGeometryFromImage","load","texture","loadProgress","xhr","loadFailure","imageSourceToCanvas","canvasContext","getContext","imageSmoothingEnabled","shrank","calculateAspectRatioFit","drawImage","srcWidth","srcHeight","maxWidth","maxHeight","duplicateColorMap","colors","rgbString","offset","r","g","numPixels","getImageData","colorsNeedUpdate","lastMapping","loaded","total","alert","vertices","mapNormalizedRGBTo","verticesNeedUpdate","rgbCube","hslCylinder","hsl","getHSL","angle","radius","cos","sin","hsvCylinder","hsv","hslToHsv","hslCones","abs","hsvCone","hslSphere","lon","hsvSphere","hslCube","hsvCube","EventDispatcher","Vector2","Texture","mapping","wrapS","wrapT","magFilter","minFilter","format","anisotropy","encoding","TextureIdCount","uuid","_Math","generateUUID","sourceFile","DEFAULT_IMAGE","mipmaps","DEFAULT_MAPPING","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","repeat","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","LinearEncoding","onUpdate","count","Vector4","w","WebGLRenderTarget","scissor","scissorTest","depthBuffer","stencilBuffer","depthTexture","WebGLRenderTargetCube","activeCubeFace","activeMipMapLevel","Quaternion","_x","_y","_z","_w","Vector3","Matrix4","elements","Float32Array","CubeTexture","images","CubeReflectionMapping","UniformContainer","seq","flatten","array","nBlocks","blockSize","firstElem","arrayCacheF32","allocTexUnits","arrayCacheI32","Int32Array","allocTextureUnit","setValue1f","gl","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","unit","setTexture2D","emptyTexture","setValueT6","setTextureCube","emptyCubeTexture","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","units","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","setValue","PureArrayUniform","StructuredUniform","addUniform","container","uniformObject","parseUniform","pathLength","RePathPart","lastIndex","exec","matchEnd","idIsIndex","subscript","next","WebGLUniforms","program","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","Color","setRGB","Box2","Infinity","LensFlarePlugin","flares","faces","Uint16Array","vertexBuffer","createBuffer","elementBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","tempTexture","createTexture","occlusionTexture","state","bindTexture","TEXTURE_2D","texImage2D","RGB","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","RGBA","shader","vertexShader","fragmentShader","createProgram","attributes","vertex","getAttribLocation","uv","uniforms","renderType","occlusionMap","screenPosition","createShader","FRAGMENT_SHADER","VERTEX_SHADER","prefix","getPrecision","shaderSource","compileShader","attachShader","linkProgram","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","useProgram","initAttributes","enableAttribute","disableUnusedAttributes","vertexAttribPointer","FLOAT","disable","CULL_FACE","setDepthWrite","flare","matrixWorld","applyMatrix4","matrixWorldInverse","applyProjection","projectionMatrix","copy","containsPoint","activeTexture","TEXTURE0","TEXTURE1","copyTexImage2D","BLEND","enable","DEPTH_TEST","drawElements","TRIANGLES","UNSIGNED_SHORT","positionScreen","customUpdateCallback","updateLensFlares","jl","lensFlares","sprite","setBlending","blending","blendEquation","blendSrc","blendDst","resetGLState","SpritePlugin","sprites","uvOffset","uvScale","modelViewMatrix","fogType","fogDensity","fogNear","fogFar","fogColor","alphaTest","fillStyle","fillRect","needsUpdate","painterSortStable","renderOrder","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","fog","isFog","near","far","isFogExp2","density","multiplyMatrices","decompose","setDepthTest","depthTest","depthWrite","Material","MaterialIdCount","lights","NormalBlending","side","FrontSide","shading","SmoothShading","NoColors","SrcAlphaFactor","OneMinusSrcAlphaFactor","AddEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","LessEqualDepth","clippingPlanes","clipIntersection","clipShadows","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","count$1","ShaderMaterial","parameters","defines","linewidth","clipping","skinning","morphTargets","morphNormals","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","uv2","index0AttributeName","setValues","MeshDepthMaterial","depthPacking","BasicDepthPacking","alphaMap","displacementMap","displacementScale","displacementBias","Box3","center","Matrix3","Plane","normal","constant","Frustum","p0","p1","p2","p3","p4","p5","planes","WebGLShadowMap","_renderer","_lights","_objects","capabilities","getDepthMaterial","isPointLight","lightPositionWorld","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","isBufferGeometry","morphAttributes","isGeometry","useSkinning","isSkinnedMesh","variantIndex","_MorphingFlag","_SkinningFlag","localClippingEnabled","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","scope","renderSingleSided","DoubleSide","renderReverseSided","BackSide","lightPos","projectObject","shadowCamera","layers","mask","isMesh","isLine","isPoints","castShadow","frustumCulled","_frustum","intersectsObject","_renderList","_gl","_state","_projScreenMatrix","_lightShadows","shadows","_shadowMapSize","_maxShadowMapSize","maxTextureSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","RGBADepthPacking","distanceShader","ShaderLib","distanceUniforms","UniformsUtils","depthMaterial","distanceMaterial","USE_SHADOWMAP","enabled","autoUpdate","PCFShadowMap","clearColor","setScissorTest","faceCount","il","light","shadow","mapSize","vpWidth","vpHeight","pars","NearestFilter","isSpotLightShadow","shadowMap","shadowMatrix","matrix","setFromMatrixPosition","setRenderTarget","face","up","lookAt","vpDimensions","updateMatrixWorld","getInverse","multiply","setFromMatrix","isMultiMaterial","groups","materials","k","kl","group","groupMaterial","materialIndex","renderBufferDirect","getClearColor","clearAlpha","getClearAlpha","setClearColor","Ray","direction","Euler","order","_order","DefaultOrder","Layers","Object3D","onRotationChange","quaternion","setFromEuler","onQuaternionChange","setFromQuaternion","Object3DIdCount","DefaultUp","onChange","normalMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","receiveShadow","userData","onBeforeRender","onAfterRender","count$2","Line3","Triangle","Face3","isVector3","vertexNormals","isColor","MeshBasicMaterial","aoMap","aoMapIntensity","specularMap","envMap","combine","MultiplyOperation","reflectivity","refractionRatio","wireframeLinecap","wireframeLinejoin","BufferAttribute","itemSize","TypeError","dynamic","updateRange","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Int32Attribute","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","setDynamic","Geometry","GeometryIdCount","faceVertexUvs","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","count$3","DirectGeometry","indices","normals","uvs","uvs2","BufferGeometry","drawRange","Mesh","random","drawMode","TrianglesDrawMode","updateMorphTargets","BoxBufferGeometry","depth","widthSegments","heightSegments","depthSegments","buildPlane","u","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","ix","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","addGroup","groupStart","vertexCount","indexCount","setIndex","addAttribute","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","offset2","Camera","PerspectiveCamera","fov","zoom","focus","view","filmGauge","filmOffset","OrthographicCamera","WebGLIndexedBufferRenderer","infoRender","setMode","UNSIGNED_INT","calls","renderInstances","extension","drawElementsInstancedANGLE","maxInstancedCount","WebGLBufferRenderer","drawArrays","isInterleavedBufferAttribute","drawArraysInstancedANGLE","WebGLLights","shadowBias","shadowRadius","shadowMapSize","distance","coneCos","penumbraCos","decay","skyColor","groundColor","addLineNumbers","string","lines","WebGLShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getEncodingComponents","sRGBEncoding","RGBEEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","GammaEncoding","Error","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMapping","toneMappingName","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","generateExtensions","rendererExtensions","envMapCubeUV","bumpMap","normalMap","flatShading","logarithmicDepthBuffer","filterEmptyLine","generateDefines","chunks","fetchAttributeLocations","identifiers","ACTIVE_ATTRIBUTES","getActiveAttrib","replaceLightNums","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","ShaderChunk","unrollLoops","snippet","unroll","parseInt","WebGLProgram","code","__webglShader","shadowMapTypeDefine","shadowMapType","PCFSoftShadowMap","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","CubeRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","MixOperation","AddOperation","prefixVertex","prefixFragment","gammaFactorDefine","gammaFactor","customExtensions","customDefines","isRawShaderMaterial","supportsVertexTextures","maxBones","lightMap","emissiveMap","roughnessMap","metalnessMap","useVertexTexture","doubleSided","flipSided","numClippingPlanes","shadowMapEnabled","useFog","fogExp","numClipIntersection","physicallyCorrectLights","NoToneMapping","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","isShaderMaterial","vertexGlsl","fragmentGlsl","glVertexShader","glFragmentShader","bindAttribLocation","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","deleteShader","cachedUniforms","getUniforms","cachedAttributes","getAttributes","deleteProgram","programIdCount","usedTimes","WebGLPrograms","allocateBones","floatVertexTextures","skeleton","nVertexUniforms","maxVertexUniforms","nVertexMatrices","bones","getTextureEncodingFromMap","gammaOverrideLinear","isTexture","isWebGLRenderTarget","programs","shaderIDs","MeshNormalMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshStandardMaterial","MeshPhysicalMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","parameterNames","getParameters","nClipPlanes","nClipIntersection","shaderID","getMaxPrecision","currentRenderTarget","getCurrentRenderTarget","vertexTextures","gammaOutput","gammaInput","envMapMode","FlatShading","maxMorphTargets","maxMorphNormals","directional","point","spot","hemi","getProgramCode","acquireProgram","pl","programInfo","releaseProgram","WebGLGeometries","properties","onGeometryDispose","buffergeometry","geometries","deleteAttribute","deleteAttributes","bufferproperty","memory","getAttributeBuffer","attribute","__webglBuffer","buffer","deleteBuffer","removeAttributeBuffer","_bufferGeometry","setFromObject","WebGLObjects","updateFromObject","updateAttribute","bufferType","attributeProperties","updateBuffer","usage","DYNAMIC_DRAW","bufferSubData","BYTES_PER_ELEMENT","subarray","getWireframeAttribute","TypeArray","WebGLTextures","paramThreeToGL","clampToMaxSize","maxSize","isPowerOfTwo","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","nearestPowerOfTwo","textureNeedsPowerOfTwo","filterFallback","f","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LINEAR","onTextureDispose","deallocateTexture","_infoMemory","textures","onRenderTargetDispose","renderTarget","deallocateRenderTarget","textureProperties","__image__webglTextureCube","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","dispose","isWebGLRenderTargetCube","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__version","complete","uploadTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isCompressedTexture","isDataTexture","cubeImage","maxCubemapSize","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","RGBFormat","getCompressedTextureFormats","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","generateMipmap","setTextureCubeDynamic","textureType","FloatType","HalfFloatType","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isDepthTexture","internalFormat","DEPTH_COMPONENT","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","DepthStencilFormat","DEPTH_STENCIL","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","webglDepthTexture","DepthFormat","setupDepthRenderbuffer","isCube","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","webglTexture","WebGL2RenderingContext","WebGLProperties","WebGLState","ColorBuffer","locked","currentColorMask","currentColorClear","setMask","colorMask","setLocked","lock","setClear","equals","reset","DepthBuffer","currentDepthMask","currentDepthFunc","currentDepthClear","setTest","depthMask","setFunc","NeverDepth","NEVER","AlwaysDepth","ALWAYS","LessDepth","LESS","LEQUAL","EqualDepth","EQUAL","GreaterEqualDepth","GEQUAL","GreaterDepth","GREATER","NotEqualDepth","NOTEQUAL","clearDepth","StencilBuffer","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","stencilFunc","stencilRef","setOp","stencilFail","stencilZFail","stencilZPass","stencilOp","stencil","clearStencil","setDepthFunc","setFlipSided","setCullFace","CullFaceBack","newAttributes","enabledAttributes","enableVertexAttribArray","attributeDivisors","vertexAttribDivisorANGLE","enableAttributeAndDivisor","meshPerAttribute","disableVertexAttribArray","compressedTextureFormats","formats","getParameter","COMPRESSED_TEXTURE_FORMATS","NoBlending","currentBlending","currentPremultipledAlpha","AdditiveBlending","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","blendFunc","SRC_ALPHA","SubtractiveBlending","ZERO","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","MultiplyBlending","SRC_COLOR","CustomBlending","currentBlendEquation","currentBlendEquationAlpha","currentBlendSrc","currentBlendDst","currentBlendSrcAlpha","currentBlendDstAlpha","setColorWrite","colorBuffer","setStencilTest","setStencilWrite","stencilWrite","setStencilFunc","setStencilOp","currentFlipSided","frontFace","CW","CCW","cullFace","CullFaceNone","currentCullFace","BACK","CullFaceFront","FRONT","FRONT_AND_BACK","setLineWidth","currentLineWidth","lineWidth","setPolygonOffset","factor","POLYGON_OFFSET_FILL","currentPolygonOffsetFactor","currentPolygonOffsetUnits","getScissorTest","currentScissorTest","SCISSOR_TEST","webglSlot","maxTextures","currentTextureSlot","webglType","boundTexture","currentBoundTextures","emptyTextures","currentScissor","currentViewport","maxVertexAttributes","MAX_VERTEX_ATTRIBS","MAX_TEXTURE_IMAGE_UNITS","buffers","WebGLCapabilities","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","HIGH_FLOAT","MEDIUM_FLOAT","maxPrecision","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","floatFragmentTextures","WebGLExtensions","getExtension","WebGLClipping","resetGlobalState","uniform","globalState","numGlobalPlanes","numPlanes","numIntersection","projectPlanes","dstOffset","skipTransform","nPlanes","dstArray","flatSize","viewMatrix","viewNormalMatrix","getNormalMatrix","i4","plane","renderingShadows","enableLocalClipping","beginShadows","endShadows","setState","fromCache","nGlobal","lGlobal","clippingState","WebGLRenderer","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","setDefaultGLState","_currentScissor","_scissor","multiplyScalar","_currentViewport","_viewport","_clearColor","_clearAlpha","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","preventDefault","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programCache","setupVertexAttributes","startIndex","isInstancedBufferGeometry","geometryAttributes","programAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","SHORT","INT","BYTE","objects","stride","isInstancedInterleavedBuffer","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","absNumericalSort","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","computeBoundingSphere","_sphere","isSphereViewable","isSpriteViewable","sphere","intersectsSphere","_clipping","_this","negRad","distanceToPoint","isLight","isSprite","isLensFlare","isImmediateRenderObject","sortObjects","renderObjects","overrideMaterial","setMaterial","setProgram","renderBufferImmediate","initMaterial","materialProperties","programChange","numSupportedMorphTargets","numSupportedMorphNormals","lightsHash","ambientLightColor","ambient","directionalLights","spotLights","pointLights","hemisphereLights","directionalShadowMap","directionalShadowMatrix","spotShadowMap","spotShadowMatrix","pointShadowMap","pointShadowMatrix","progUniforms","uniformsList","seqWithValue","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","useCache","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","LN2","isMeshPhongMaterial","isMeshStandardMaterial","uCamPos","isMeshLambertMaterial","isMeshBasicMaterial","setOptional","markUniformsLightsNeedsUpdate","refreshUniformsFog","isMeshDepthMaterial","refreshUniformsCommon","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshNormalMaterial","upload","diffuse","emissive","emissiveIntensity","uvScaleMap","offsetRepeat","flipEnvMap","isCubeTexture","dashSize","totalSize","gapSize","_height","lightMapIntensity","specular","shininess","bumpScale","normalScale","roughness","metalness","envMapIntensity","clearCoat","clearCoatRoughness","setupShadows","lightShadowsLength","setupLights","ll","intensity","directionalLength","pointLength","spotLength","hemiLength","isAmbientLight","isDirectionalLight","lightCache","transformDirection","bias","isSpotLight","penumbra","negate","setPosition","isHemisphereLight","textureUnit","RepeatWrapping","REPEAT","MirroredRepeatWrapping","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LinearMipMapNearestFilter","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UnsignedShort4444Type","UNSIGNED_SHORT_4_4_4_4","UnsignedShort5551Type","UNSIGNED_SHORT_5_5_5_1","UnsignedShort565Type","UNSIGNED_SHORT_5_6_5","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","HALF_FLOAT_OES","AlphaFormat","ALPHA","LuminanceFormat","LUMINANCE","LuminanceAlphaFormat","LUMINANCE_ALPHA","SubtractEquation","FUNC_SUBTRACT","ReverseSubtractEquation","FUNC_REVERSE_SUBTRACT","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","DstAlphaFactor","DST_ALPHA","OneMinusDstAlphaFactor","ONE_MINUS_DST_ALPHA","DstColorFactor","DST_COLOR","OneMinusDstColorFactor","ONE_MINUS_DST_COLOR","SrcAlphaSaturateFactor","SRC_ALPHA_SATURATE","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","RGB_ETC1_Format","COMPRESSED_RGB_ETC1_WEBGL","MinEquation","MaxEquation","MIN_EXT","MAX_EXT","UnsignedInt248Type","UNSIGNED_INT_24_8_WEBGL","REVISION","_canvas","_alpha","_depth","_stencil","_antialias","_preserveDrawingBuffer","preserveDrawingBuffer","morphInfluences","domElement","autoClear","autoClearColor","autoClearDepth","autoClearStencil","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_scissorTest","_infoRender","points","rangeMin","rangeMax","MaxIndex","bufferRenderer","indexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","backgroundBoxShader","backgroundBoxMesh","spritePlugin","lensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getPixelRatio","setPixelRatio","setSize","getSize","setScissor","boolean","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","hasPositions","hasNormals","hasUvs","hasColors","positionArray","normalArray","nx","ny","nz","uvArray","colorArray","updateBuffers","geometryProgram","morphTargetInfluences","activeInfluences","influence","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","LINES","TriangleStripDrawMode","TRIANGLE_STRIP","TriangleFanDrawMode","TRIANGLE_FAN","isLineSegments","LINE_STRIP","POINTS","forceClear","isCamera","background","extractRotation","setFaceCulling","frontFaceDirection","FrontFaceDirectionCW","warned","setTexture","readRenderTargetPixels","restore","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","FogExp2","Fog","Scene","LensFlare","SpriteMaterial","Sprite","LOD","levels","DataTexture","Skeleton","boneInverses","identityMatrix","sqrt","nextPowerOfTwo","ceil","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","Bone","skin","SkinnedMesh","bindMode","bindMatrix","bindMatrixInverse","bone","gbone","rotq","scl","normalizeSkinWeights","linecap","linejoin","Line","LineSegments","Points","Group","VideoTexture","video","readyState","HAVE_CURRENT_DATA","CompressedTexture","CanvasTexture","DepthTexture","WireframeGeometry","sortFunction","edge","numEdges","edges","coords","ol","index2","getX","getY","getZ","numTris","index1","ParametricBufferGeometry","func","slices","stacks","sliceCount","computeVertexNormals","ParametricGeometry","fromBufferGeometry","mergeVertices","PolyhedronBufferGeometry","detail","subdivideFace","cols","pow","aj","lerp","bj","rows","pushVertex","correctSeam","uvBuffer","x0","x1","x2","getVertexByIndex","correctUVs","centroid","uvA","uvB","uvC","divideScalar","azi","azimuth","correctUV","atan2","inclination","normalizeNormals","TetrahedronBufferGeometry","TetrahedronGeometry","OctahedronBufferGeometry","OctahedronGeometry","IcosahedronBufferGeometry","IcosahedronGeometry","DodecahedronBufferGeometry","DodecahedronGeometry","PolyhedronGeometry","TubeBufferGeometry","tubularSegments","closed","generateSegment","P","getPointAt","N","frames","B","binormals","generateIndices","generateUVs","computeFrenetFrames","tangents","TubeGeometry","taper","bufferGeometry","TorusKnotBufferGeometry","tube","q","calculatePositionOnCurve","cu","su","quOverP","cs","indexOffset","P1","P2","T","subVectors","addVectors","crossVectors","cx","cy","setXYZ","setXY","setX","TorusKnotGeometry","heightScale","TorusBufferGeometry","arc","TorusGeometry","ExtrudeGeometry","shapes","addShapeList","computeFaceNormals","TextGeometry","font","isFont","generateShapes","curveSegments","amount","bevelThickness","bevelSize","bevelEnabled","SphereBufferGeometry","phiStart","phiLength","thetaStart","thetaLength","thetaEnd","positions","verticesRow","px","py","pz","v1","v2","v3","v4","SphereGeometry","RingBufferGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","segment","radiusStep","thetaSegmentLevel","RingGeometry","PlaneGeometry","LatheBufferGeometry","clamp","inverseSegments","phi","n1","n2","LatheGeometry","ShapeGeometry","EdgesGeometry","thresholdAngle","geometry2","thresholdDot","DEG2RAD","vert1","vert2","face1","face2","dot","CylinderBufferGeometry","radiusTop","radiusBottom","openEnded","generateCap","centerIndexStart","centerIndexEnd","sign","halfHeight","theta","cosTheta","sinTheta","nbCap","indexArray","slope","indexRow","i1","i2","i3","CylinderGeometry","ConeGeometry","ConeBufferGeometry","CircleBufferGeometry","ii","CircleGeometry","BoxGeometry","ShadowMaterial","merge","UniformsLib","RawShaderMaterial","MultiMaterial","STANDARD","PHYSICAL","LoadingManager","onLoad","onProgress","onError","isLoading","itemsLoaded","itemsTotal","onStart","itemStart","url","itemEnd","itemError","XHRLoader","manager","DefaultLoadingManager","CompressedTextureLoader","_parser","BinaryTextureLoader","ImageLoader","CubeTextureLoader","TextureLoader","Light","HemisphereLight","updateMatrix","LightShadow","SpotLightShadow","SpotLight","power","PointLight","DirectionalLightShadow","DirectionalLight","AmbientLight","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","LinearInterpolant","DiscreteInterpolant","KeyframeTrackConstructor","times","values","interpolation","AnimationUtils","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","optimize","VectorKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","NumberKeyframeTrack","StringKeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","KeyframeTrack","AnimationClip","tracks","resetDuration","MaterialLoader","BufferGeometryLoader","Loader","onLoadStart","onLoadProgress","onLoadComplete","JSONLoader","withCredentials","ObjectLoader","texturePath","Curve","LineCurve","CurvePath","curves","autoClose","EllipseCurve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","SplineCurve","CubicBezierCurve","v0","QuadraticBezierCurve","Shape","Path","holes","currentPoint","fromPoints","ShapePath","subPaths","currentPath","Font","FontLoader","getAudioContext","AudioContext","webkitAudioContext","AudioLoader","StereoCamera","eyeSep","cameraL","cameraR","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","updateCubeMap","AudioListener","gain","createGain","connect","destination","Audio","listener","createBufferSource","onended","onEnded","getInput","autoplay","startTime","playbackRate","isPlaying","hasPlaybackControl","sourceType","filters","PositionalAudio","panner","createPanner","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getOutput","PropertyMixer","typeName","mixFunction","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","useCount","referenceCount","PropertyBinding","rootNode","parsedPath","parseTrackName","findNode","nodeName","AnimationObjectGroup","var_args","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","stats","inUse","bindingsPerObject","AnimationAction","mixer","clip","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","endingStart","ZeroCurvatureEnding","endingEnd","interpolant","createInterpolant","settings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","LoopRepeat","_loopCount","_startTime","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","AnimationMixer","root","_root","_initMemoryManager","_accuIndex","Uniform","InstancedBufferGeometry","InterleavedBufferAttribute","interleavedBuffer","InterleavedBuffer","InstancedInterleavedBuffer","InstancedBufferAttribute","Raycaster","ray","params","threshold","PointCloud","ascSort","intersectObject","raycaster","intersects","recursive","raycast","Clock","autoStart","oldTime","elapsedTime","running","Spline","interpolate","t2","t3","intPoint","w2","w3","pa","pb","pc","pd","initFromArray","getPoint","getControlPointsArray","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","distanceTo","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Spherical","MorphBlendMesh","animationsMap","animationsList","numFrames","endFrame","fps","createAnimation","setAnimationWeight","ImmediateRenderObject","renderCallback","VertexNormalsHelper","hex","nNormals","objGeometry","SpotLightHelper","cone","SkeletonHelper","getBoneList","isBone","VertexColors","PointLightHelper","sphereSize","HemisphereLightHelper","rotateX","FaceColors","lightSphere","GridHelper","divisions","color1","color2","step","FaceNormalsHelper","DirectionalLightHelper","CameraHelper","addLine","addPoint","pointMap","BoundingBoxHelper","box","BoxHelper","ArrowHelper","headLength","headWidth","line","lineGeometry","coneGeometry","setDirection","setLength","AxisHelper","ClosedSplineCurve3","CatmullRomCurve3","ArcCurve","aRadius","Face4","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","EdgesHelper","WireframeHelper","Projector","projectVector","project","unprojectVector","unproject","pickingRay","CanvasRenderer","EPSILON","Function","assign","output","nextKey","_listeners","hasEventListener","listenerArray","MOUSE","LEFT","MIDDLE","RIGHT","BlendingMode","TextureMapping","UVMapping","TextureWrapping","TextureFilter","RGBEFormat","RAD2DEG","chars","rnd","euclideanModulo","mapLinear","a1","a2","b1","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","round","isVector2","scalar","setY","setComponent","getComponent","addScalar","addScaledVector","subScalar","divide","clampScalar","minVal","maxVal","clampLength","roundToZero","lengthSq","lengthManhattan","distanceToSquared","distanceToManhattan","lerpVectors","fromAttribute","rotateAround","toJSON","meta","metadata","generator","wrap","toDataURL","transformUv","isVector4","setZ","setW","setAxisAngleFromQuaternion","acos","setAxisAngleFromRotationMatrix","te","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","onChangeCallback","euler","isEuler","c1","c2","c3","s1","s2","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","vFrom","vTo","inverse","conjugate","multiplyQuaternions","premultiply","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","qa","qm","slerpFlat","dst","src0","srcOffset0","src1","srcOffset1","y0","z0","w0","y1","z1","w1","sqrSin","tDir","multiplyVectors","applyEuler","applyQuaternion","applyAxisAngle","applyMatrix3","qx","qy","qz","qw","iz","iw","cross","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","reflect","angleTo","dz","setFromSpherical","sinPhiRadius","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","temp","isMatrix4","n11","n12","n13","n14","n21","n22","n23","n24","n31","n32","n33","n34","n41","n42","n43","n44","copyPosition","me","extractBasis","xAxis","yAxis","zAxis","makeBasis","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","y2","z2","wx","wy","wz","eye","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","applyToVector3Array","applyToBuffer","determinant","transpose","flattenToArrayOffset","getPosition","throwOnDegenerate","t11","t12","t13","t14","det","msg","detInv","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","invSX","invSY","invSZ","makeFrustum","makePerspective","ymax","tan","ymin","xmin","xmax","makeOrthographic","uniforms_src","uniforms_dst","parameter_src","isMatrix3","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_fragment","fog_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_template","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_flip","normal_fragment","normalmap_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","setHex","setStyle","hue2rgb","handleAlpha","ColorKeywords","copyGammaToLinear","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","getHex","getHexString","optionalTarget","hue","saturation","lightness","delta","offsetHSL","addColors","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","basic","lambert","phong","standard","dashed","cube","tCube","tFlip","equirect","tEquirect","distanceRGBA","physical","setFromPoints","makeEmpty","expandByPoint","setFromCenterAndSize","halfSize","isEmpty","getCenter","expandByVector","expandByScalar","containsBox","intersectsBox","clampPoint","intersect","union","translate","isMaterial","currentValue","extractFromCache","srcPlanes","dstPlanes","isBox3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","closestPoint","intersectsPlane","getBoundingSphere","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","setFromMatrix4","matrix4","transposeIntoArray","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","denominator","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","frustum","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsSprite","negRadius","d1","d2","at","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","RotationOrders","asin","setFromVector3","reorder","newOrder","toVector3","optionalResult","channel","toggle","isObject3D","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","getObjectById","getObjectByProperty","getObjectByName","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","force","isRootObject","parse","distanceSq","closestPointToPointParameter","startP","startEnd","clampToLine","startEnd2","startEnd_startP","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","setFromPointsAndIndices","i0","triangle","area","midpoint","edgeList","projectedPoint","minDistance","isBufferAttribute","setArray","copyAt","copyArray","copyColorsArray","copyIndicesArray","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXYZW","computeBoundingBox","addFace","tempNormals","tempUVs","tempUVs2","ab","fl","vA","vB","vC","areaWeighted","vl","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","colors1","colors2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","verticesMap","unique","changes","faceIndicesToRemove","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","getNormalIndex","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","getIndex","clearGroups","setDrawRange","__directGeometry","lineDistance","fromDirectGeometry","pA","pB","pC","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","array2","setDrawMode","morphTargetDictionary","ml","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","faceIndex","inverseMatrix","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","tl","targets","uvs_f","isPerspectiveCamera","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","offsetX","offsetY","clearViewOffset","skew","isOrthographicCamera","zoomW","zoomH","scaleW","scaleH","vecX","vecY","wantedRotation","matrixPosition","level","addLevel","getObjectForDistance","pose","offsetMatrix","sw","vec","skinWeight","linePrecision","precisionSq","vStart","vEnd","interSegment","interRay","distSq","nbVertices","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","ShapeUtils","contour","triangulate","snip","verts","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","removeDupEndPts","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","allPointsMap","allpoints","hl","shapeWithoutHoles","hole","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","shape","indepHoles","failedCuts","minShapeIndex","h2","inShapeIdx","inHoleIdx","lastShapeIdx","prevShapeIdx","nextShapeIdx","insideAngle","lastHoleIdx","prevHoleIdx","nextHoleIdx","inShapePt","inHolePt","sIdx","nextIdx","ihIdx","chkHole","hIdx","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","addShape","scalePt2","pt","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","sidewalls","layeroffset","steps","bevelSegments","slen1","vlen","slen2","f4","f3","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","getSpacedPoints","ahole","shapePoints","extractPoints","reverse","bs","vert","flen","contourMovements","oneHoleMovements","holesMovements","verticesMovements","layer","indexA","indexB","indexC","indexD","Geometries","isShadowMaterial","Materials","Cache","files","file","dataUriRegex","dataUriRegexResult","mimeType","isBase64","decodeURIComponent","atob","response","responseType","ArrayBuffer","Blob","parser","DOMParser","parseFromString","request","XMLHttpRequest","open","status","overrideMimeType","send","setPath","setResponseType","setWithCredentials","texDatas","mipmapCount","isCubemap","DataTextureLoader","texData","onload","URL","revokeObjectURL","onerror","blob","createObjectURL","setCrossOrigin","crossOrigin","urls","isJPEG","search","arraySlice","isTypedArray","forceClone","isView","DataView","getKeyframeOrder","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","DefaultSettings_","getSettings_","copySampleValue_","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","KeyframeTrackPrototype","InterpolantFactoryMethodDiscrete","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","ValueTypeName","getInterpolation","shift","timeOffset","endTime","nKeys","valid","prevTime","currTime","smoothInterpolation","writeIndex","keep","offsetP","offsetN","readOffset","writeOffset","json","trackType","_getTrackTypeForValueTypeName","track","jsonTracks","frameTime","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","parts","animationMorphTargets","clips","parseAnimation","animation","addNonemptyTrack","trackName","animationKeys","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","setTextures","getTexture","TYPED_ARRAYS","typedArray","drawcalls","offsets","extractUrlBase","initMaterials","createMaterial","textureLoader","materialLoader","loadTexture","fullPath","Handlers","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","regex","setTexturePath","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","hasMaterial","faceA","faceB","uvLayer","nUvLayers","influencesPerVertex","dstVertices","srcVertices","morphColors","outputAnimations","morphAnimationClips","substring","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","parseAnimations","geometryLoader","bufferGeometryLoader","parseConstant","getGeometry","getMaterial","isInteger","getUtoTmapping","getPoints","lengths","getLengths","cacheArcLengths","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","getTangentAt","mat","MAX_VALUE","tz","getPointFunc","isLineCurve","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","lens","cacheLengths","sums","resolution","isEllipseCurve","isSplineCurve","createPointsGeometry","createGeometry","createSpacedPointsGeometry","twoPi","deltaAngle","samePoints","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","point0","point1","point2","point3","PathPrototype","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","getPointsHoles","holesPts","extractAllPoints","toShapes","isCCW","noHoles","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","froms","tos","tmpHoles","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","outline","_cachedOutline","action","ha","paths","decodeAudioData","audioBuffer","instance","eyeRight","eyeLeft","eyeSepOnProjection","removeFilter","disconnect","getFilter","setFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","setNodeSource","audioNode","setBuffer","play","pause","stop","currentTime","getFilters","setFilters","setPlaybackRate","getPlaybackRate","getLoop","setLoop","getVolume","setVolume","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","getFrequencyData","getByteFrequencyData","getAverageFrequency","accumulate","accuIndex","currentWeight","mix","originalValueOffset","saveOriginalState","restoreOriginalState","targetArray","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","subscribe_","firstValidIndex","bindings","isAnimationObjectGroup","re","results","searchNodeSubtree","subTreeNode","nObjects","nCachedObjects","indicesByUUID","parsedPaths","nBindings","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","now","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","deltaTime","timeDirection","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","atStart","atEnd","weightNow","weightThen","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","_nActiveBindings","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","_removeInactiveBinding","uncacheAction","bindingsByName","_addInactiveBinding","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","lastInactiveBinding","remove_empty_map","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","isInterleavedBuffer","setFromCamera","intersectObjects","Date","getElapsedTime","getDelta","newTime","other","makeSafe","vec3","lastFrame","currentFrame","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe","objPos","objNorm","vector2","coneLength","coneWidth","boneList","matrixWorldInv","boneMatrix","setColors","lightPlane","targetLine","setPoint","setColor","CubicPoly","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","SplineCurve3","CubicBezierCurve3","QuadraticBezierCurve3","LineCurve3","SceneUtils","createMultiMaterialObject","detach","attach","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","extrude","makeGeometry","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","CullFaceFrontBack","FrontFaceDirectionCCW","BasicShadowMap","LoopOnce","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroSlopeEnding","WrapAroundEnding","LogLuvEncoding","CubeGeometry","LineStrip","LinePieces","MeshFaceMaterial","Particle","Component","__WEBPACK_IMPORTED_MODULE_1_your_tasteful_component__","__WEBPACK_IMPORTED_MODULE_1_your_tasteful_component___default","__WEBPACK_IMPORTED_MODULE_2__viewport_vue__","__WEBPACK_IMPORTED_MODULE_2__viewport_vue___default","__WEBPACK_IMPORTED_MODULE_3__settings__","__WEBPACK_IMPORTED_MODULE_3__settings___default","__WEBPACK_IMPORTED_MODULE_4__viewport_js__","className","Settings","showSidebar","mounted","keyHandler","beforeDestroy","keyboardEvent","ctrlKey","settingsToggle","scrollTo","content","__WEBPACK_IMPORTED_MODULE_0__mixin_input__","__WEBPACK_IMPORTED_MODULE_1__input_button__","__WEBPACK_IMPORTED_MODULE_1__input_button___default","__WEBPACK_IMPORTED_MODULE_1__existing_dom_node__","__WEBPACK_IMPORTED_MODULE_1__existing_dom_node___default","__WEBPACK_IMPORTED_MODULE_2__input_button__","__WEBPACK_IMPORTED_MODULE_2__input_button___default","__WEBPACK_IMPORTED_MODULE_3__input_check__","__WEBPACK_IMPORTED_MODULE_3__input_check___default","__WEBPACK_IMPORTED_MODULE_4__input_select__","__WEBPACK_IMPORTED_MODULE_4__input_select___default","__WEBPACK_IMPORTED_MODULE_5__input_toggle__","__WEBPACK_IMPORTED_MODULE_5__input_toggle___default","ExistingDomNode","InputButton","InputCheck","InputSelect","InputToggle","clearAllImages","uploadImage","changeEvent","fileList","isMobile","readFile","__WEBPACK_IMPORTED_MODULE_1__viewport__","__WEBPACK_IMPORTED_MODULE_2__vertifier__","__WEBPACK_IMPORTED_MODULE_3__viewport_js__","clickable","handleAsFile","getAsFile","searchForImage","getAsString","imageTagRegexExec","img","srcExec","altExec","alt","supportedTypeMap","image/png","image/jpeg","image/gif","image/bmp","image/svg+xml","text/html","handleDrag","itemList","dataTransfer","anySuitableHandler","handleType","handleWheel","beforeMount","deltaX","deltaY","nameUnique","lastModified","reader","FileReader","onloadend","Image","readAsDataURL","clientX","clientY","targetTouches","move","_vm","_h","for","$$selectedVal","checked","__c","$$a","$$el","$$c","$$i","mousedown","mousemove","mouseup","mouseout","touchstart","touchmove","touchend","encType","role","href","col-sm-8 col-xl-9","sidebar h-100 col-12 col-sm-4 col-xl-3","eval"],"mappings":"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","file":"client.ddf2dad5.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 35);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n\tautoRotateY: true,\n\tautoRotateX: false,\n\tscaleImages: false,\n\tshowBounds: true,\n\timage: 'http://i.imgur.com/T2lAyjx.png',\n\timageList: [{ text: 'RainbowSpace rendered logo', value: 'http://i.imgur.com/SXJ6pGK.png' }, { text: 'RainbowSpace painted logo', value: 'http://i.imgur.com/T2lAyjx.png' }, { text: 'Triangle - Cyan, Magenta, Yellow', value: 'http://i.imgur.com/7zOi9i3.png' }, { text: 'Triangle - Red, Yellow, Blue', value: 'http://i.imgur.com/EUe7UYD.png' }, { text: 'Ghost & Candy Corn', value: 'http://i.imgur.com/sdEo3fXl.jpg' }, { text: 'Crusader Arts \"Red Room\" Tribute', value: 'http://i.imgur.com/IllmOBYl.jpg' }, { text: 'Hexagonal Hard Candy Revisited - Cyan', value: 'http://i.imgur.com/ioYgktml.jpg' }, { text: 'Hexagonal Hard Candy Revisited - Purple', value: 'http://i.imgur.com/bvlb8Jhl.jpg' }, { text: 'Chocolate Hearts', value: 'http://i.imgur.com/PI9rY1Nl.jpg' }, { text: 'Hella Hearts - 4 of 4', value: 'http://i.imgur.com/03Iaigtl.jpg' }, { text: 'Aperture Eyes', value: 'http://i.imgur.com/un151Ttl.jpg' }, { text: 'Warm Wooden Toy', value: 'http://i.imgur.com/4mUs55cl.jpg' }, { text: 'Recursive Trefoil Knot', value: 'http://i.imgur.com/3kasZkCl.jpg' }, { text: 'Some Cool Color Chart', value: 'http://i.imgur.com/Mv7BbPWl.jpg' }, { text: 'Another Cool Color Chart', value: 'https://c1.staticflickr.com/5/4149/5077374515_c740c2f199_b.jpg' }, { text: 'Yet Another Cool Color Chart', value: 'https://c1.staticflickr.com/7/6080/6109196872_61ea600625_z.jpg' }, { text: 'aCool Color Chart', value: 'https://c2.staticflickr.com/6/5059/5500526444_baf6909eef_z.jpg' }, { text: 'bCool Color Chart', value: 'https://c2.staticflickr.com/2/1563/26702317155_e3c3a9dd71_z.jpg' }, { text: 'cCool Color Chart', value: 'https://c2.staticflickr.com/4/3065/2924345262_24dc9d632a_z.jpg?zz=1' }, { text: 'DemonPuppy', value: 'https://crossorigin.me/https://github.com/AdmiralPotato/npos3d/raw/master/tests/pn3_files/demonpuppy.png' }, { text: 'InterSphere', value: 'https://crossorigin.me/http://nuclearpixel.com/js/npos3d/tests/img/intersphere.png' }, { text: 'hsl?', value: 'https://crossorigin.me/http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/01/hsl-color-wheel.png' }],\n\tdisplayMethod: 'hslSphere',\n\tdisplayMethodList: ['rgbCube', 'hslSphere', 'hslCones', 'hslCylinder', 'hslCube', 'hsvSphere', 'hsvCone', 'hsvCylinder', 'hsvCube'],\n\tcameraMode: 'perspective',\n\tcameraModeList: ['perspective', 'orthographic'],\n\tcameraPosition: 'free',\n\tcameraPositionList: ['Top', 'Front', 'Right', 'WCorner', 'Bottom', 'Back', 'Left', 'BCorner'],\n\tcameraPositionKeymap: {\n\t\t'Numpad7-0': 'Top',\n\t\t'Numpad1-0': 'Front',\n\t\t'Numpad3-0': 'Right',\n\t\t'Numpad0-0': 'WCorner',\n\t\t'Numpad7-1': 'Bottom',\n\t\t'Numpad1-1': 'Back',\n\t\t'Numpad3-1': 'Left',\n\t\t'Numpad0-1': 'BCorner'\n\t},\n\tbackgroundColor: '20',\n\tbackgroundColorList: ['0', '20', '40', '50', '60', '80', '100']\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyY1xcc3RhdGUuanMiXSwibmFtZXMiOlsiYXV0b1JvdGF0ZVkiLCJhdXRvUm90YXRlWCIsInNjYWxlSW1hZ2VzIiwic2hvd0JvdW5kcyIsImltYWdlIiwiaW1hZ2VMaXN0IiwidGV4dCIsInZhbHVlIiwiZGlzcGxheU1ldGhvZCIsImRpc3BsYXlNZXRob2RMaXN0IiwiY2FtZXJhTW9kZSIsImNhbWVyYU1vZGVMaXN0IiwiY2FtZXJhUG9zaXRpb24iLCJjYW1lcmFQb3NpdGlvbkxpc3QiLCJjYW1lcmFQb3NpdGlvbktleW1hcCIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRDb2xvckxpc3QiXSwibWFwcGluZ3MiOiJBQUFBLGVBQWU7QUFDZEEsY0FBYSxJQURDO0FBRWRDLGNBQWEsS0FGQztBQUdkQyxjQUFhLEtBSEM7QUFJZEMsYUFBWSxJQUpFO0FBS2RDLFFBQU8sZ0NBTE87QUFNZEMsWUFBVyxDQUNWLEVBQUNDLE1BQU0sNEJBQVAsRUFBcUNDLE9BQU8sZ0NBQTVDLEVBRFUsRUFFVixFQUFDRCxNQUFNLDJCQUFQLEVBQW9DQyxPQUFPLGdDQUEzQyxFQUZVLEVBR1YsRUFBQ0QsTUFBTSxrQ0FBUCxFQUEyQ0MsT0FBTyxnQ0FBbEQsRUFIVSxFQUlWLEVBQUNELE1BQU0sOEJBQVAsRUFBdUNDLE9BQU8sZ0NBQTlDLEVBSlUsRUFLVixFQUFDRCxNQUFNLG9CQUFQLEVBQTZCQyxPQUFPLGlDQUFwQyxFQUxVLEVBTVYsRUFBQ0QsTUFBTSxrQ0FBUCxFQUEyQ0MsT0FBTyxpQ0FBbEQsRUFOVSxFQU9WLEVBQUNELE1BQU0sdUNBQVAsRUFBZ0RDLE9BQU8saUNBQXZELEVBUFUsRUFRVixFQUFDRCxNQUFNLHlDQUFQLEVBQWtEQyxPQUFPLGlDQUF6RCxFQVJVLEVBU1YsRUFBQ0QsTUFBTSxrQkFBUCxFQUEyQkMsT0FBTyxpQ0FBbEMsRUFUVSxFQVVWLEVBQUNELE1BQU0sdUJBQVAsRUFBZ0NDLE9BQU8saUNBQXZDLEVBVlUsRUFXVixFQUFDRCxNQUFNLGVBQVAsRUFBd0JDLE9BQU8saUNBQS9CLEVBWFUsRUFZVixFQUFDRCxNQUFNLGlCQUFQLEVBQTBCQyxPQUFPLGlDQUFqQyxFQVpVLEVBYVYsRUFBQ0QsTUFBTSx3QkFBUCxFQUFpQ0MsT0FBTyxpQ0FBeEMsRUFiVSxFQWNWLEVBQUNELE1BQU0sdUJBQVAsRUFBZ0NDLE9BQU8saUNBQXZDLEVBZFUsRUFlVixFQUFDRCxNQUFNLDBCQUFQLEVBQW1DQyxPQUFPLGdFQUExQyxFQWZVLEVBZ0JWLEVBQUNELE1BQU0sOEJBQVAsRUFBdUNDLE9BQU8sZ0VBQTlDLEVBaEJVLEVBaUJWLEVBQUNELE1BQU0sbUJBQVAsRUFBNEJDLE9BQU8sZ0VBQW5DLEVBakJVLEVBa0JWLEVBQUNELE1BQU0sbUJBQVAsRUFBNEJDLE9BQU8saUVBQW5DLEVBbEJVLEVBbUJWLEVBQUNELE1BQU0sbUJBQVAsRUFBNEJDLE9BQU8scUVBQW5DLEVBbkJVLEVBb0JWLEVBQUNELE1BQU0sWUFBUCxFQUFxQkMsT0FBTywwR0FBNUIsRUFwQlUsRUFxQlYsRUFBQ0QsTUFBTSxhQUFQLEVBQXNCQyxPQUFPLG9GQUE3QixFQXJCVSxFQXNCVixFQUFDRCxNQUFNLE1BQVAsRUFBZUMsT0FBTyx3SEFBdEIsRUF0QlUsQ0FORztBQThCZEMsZ0JBQWUsV0E5QkQ7QUErQmRDLG9CQUFtQixDQUFDLFNBQUQsRUFBWSxXQUFaLEVBQXlCLFVBQXpCLEVBQXFDLGFBQXJDLEVBQW9ELFNBQXBELEVBQStELFdBQS9ELEVBQTRFLFNBQTVFLEVBQXVGLGFBQXZGLEVBQXNHLFNBQXRHLENBL0JMO0FBZ0NkQyxhQUFZLGFBaENFO0FBaUNkQyxpQkFBZ0IsQ0FBQyxhQUFELEVBQWdCLGNBQWhCLENBakNGO0FBa0NkQyxpQkFBZ0IsTUFsQ0Y7QUFtQ2RDLHFCQUFvQixDQUFDLEtBQUQsRUFBUSxPQUFSLEVBQWlCLE9BQWpCLEVBQTBCLFNBQTFCLEVBQXFDLFFBQXJDLEVBQStDLE1BQS9DLEVBQXVELE1BQXZELEVBQStELFNBQS9ELENBbkNOO0FBb0NkQyx1QkFBc0I7QUFDckIsZUFBYSxLQURRO0FBRXJCLGVBQWEsT0FGUTtBQUdyQixlQUFhLE9BSFE7QUFJckIsZUFBYSxTQUpRO0FBS3JCLGVBQWEsUUFMUTtBQU1yQixlQUFhLE1BTlE7QUFPckIsZUFBYSxNQVBRO0FBUXJCLGVBQWE7QUFSUSxFQXBDUjtBQThDZEMsa0JBQWlCLElBOUNIO0FBK0NkQyxzQkFBcUIsQ0FBQyxHQUFELEVBQU0sSUFBTixFQUFZLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsS0FBcEM7QUEvQ1AsQ0FBZiIsImZpbGUiOiJzdGF0ZS5qcyIsInNvdXJjZVJvb3QiOiJHOi9kZXYvcmFpbmJvd3NwYWNlIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuXHRhdXRvUm90YXRlWTogdHJ1ZSxcblx0YXV0b1JvdGF0ZVg6IGZhbHNlLFxuXHRzY2FsZUltYWdlczogZmFsc2UsXG5cdHNob3dCb3VuZHM6IHRydWUsXG5cdGltYWdlOiAnaHR0cDovL2kuaW1ndXIuY29tL1QybEF5angucG5nJyxcblx0aW1hZ2VMaXN0OiBbXG5cdFx0e3RleHQ6ICdSYWluYm93U3BhY2UgcmVuZGVyZWQgbG9nbycsIHZhbHVlOiAnaHR0cDovL2kuaW1ndXIuY29tL1NYSjZwR0sucG5nJ30sXG5cdFx0e3RleHQ6ICdSYWluYm93U3BhY2UgcGFpbnRlZCBsb2dvJywgdmFsdWU6ICdodHRwOi8vaS5pbWd1ci5jb20vVDJsQXlqeC5wbmcnfSxcblx0XHR7dGV4dDogJ1RyaWFuZ2xlIC0gQ3lhbiwgTWFnZW50YSwgWWVsbG93JywgdmFsdWU6ICdodHRwOi8vaS5pbWd1ci5jb20vN3pPaTlpMy5wbmcnfSxcblx0XHR7dGV4dDogJ1RyaWFuZ2xlIC0gUmVkLCBZZWxsb3csIEJsdWUnLCB2YWx1ZTogJ2h0dHA6Ly9pLmltZ3VyLmNvbS9FVWU3VVlELnBuZyd9LFxuXHRcdHt0ZXh0OiAnR2hvc3QgJiBDYW5keSBDb3JuJywgdmFsdWU6ICdodHRwOi8vaS5pbWd1ci5jb20vc2RFbzNmWGwuanBnJ30sXG5cdFx0e3RleHQ6ICdDcnVzYWRlciBBcnRzIFwiUmVkIFJvb21cIiBUcmlidXRlJywgdmFsdWU6ICdodHRwOi8vaS5pbWd1ci5jb20vSWxsbU9CWWwuanBnJ30sXG5cdFx0e3RleHQ6ICdIZXhhZ29uYWwgSGFyZCBDYW5keSBSZXZpc2l0ZWQgLSBDeWFuJywgdmFsdWU6ICdodHRwOi8vaS5pbWd1ci5jb20vaW9ZZ2t0bWwuanBnJ30sXG5cdFx0e3RleHQ6ICdIZXhhZ29uYWwgSGFyZCBDYW5keSBSZXZpc2l0ZWQgLSBQdXJwbGUnLCB2YWx1ZTogJ2h0dHA6Ly9pLmltZ3VyLmNvbS9idmxiOEpobC5qcGcnfSxcblx0XHR7dGV4dDogJ0Nob2NvbGF0ZSBIZWFydHMnLCB2YWx1ZTogJ2h0dHA6Ly9pLmltZ3VyLmNvbS9QSTlyWTFObC5qcGcnfSxcblx0XHR7dGV4dDogJ0hlbGxhIEhlYXJ0cyAtIDQgb2YgNCcsIHZhbHVlOiAnaHR0cDovL2kuaW1ndXIuY29tLzAzSWFpZ3RsLmpwZyd9LFxuXHRcdHt0ZXh0OiAnQXBlcnR1cmUgRXllcycsIHZhbHVlOiAnaHR0cDovL2kuaW1ndXIuY29tL3VuMTUxVHRsLmpwZyd9LFxuXHRcdHt0ZXh0OiAnV2FybSBXb29kZW4gVG95JywgdmFsdWU6ICdodHRwOi8vaS5pbWd1ci5jb20vNG1VczU1Y2wuanBnJ30sXG5cdFx0e3RleHQ6ICdSZWN1cnNpdmUgVHJlZm9pbCBLbm90JywgdmFsdWU6ICdodHRwOi8vaS5pbWd1ci5jb20vM2thc1prQ2wuanBnJ30sXG5cdFx0e3RleHQ6ICdTb21lIENvb2wgQ29sb3IgQ2hhcnQnLCB2YWx1ZTogJ2h0dHA6Ly9pLmltZ3VyLmNvbS9NdjdCYlBXbC5qcGcnfSxcblx0XHR7dGV4dDogJ0Fub3RoZXIgQ29vbCBDb2xvciBDaGFydCcsIHZhbHVlOiAnaHR0cHM6Ly9jMS5zdGF0aWNmbGlja3IuY29tLzUvNDE0OS81MDc3Mzc0NTE1X2M3NDBjMmYxOTlfYi5qcGcnfSxcblx0XHR7dGV4dDogJ1lldCBBbm90aGVyIENvb2wgQ29sb3IgQ2hhcnQnLCB2YWx1ZTogJ2h0dHBzOi8vYzEuc3RhdGljZmxpY2tyLmNvbS83LzYwODAvNjEwOTE5Njg3Ml82MWVhNjAwNjI1X3ouanBnJ30sXG5cdFx0e3RleHQ6ICdhQ29vbCBDb2xvciBDaGFydCcsIHZhbHVlOiAnaHR0cHM6Ly9jMi5zdGF0aWNmbGlja3IuY29tLzYvNTA1OS81NTAwNTI2NDQ0X2JhZjY5MDllZWZfei5qcGcnfSxcblx0XHR7dGV4dDogJ2JDb29sIENvbG9yIENoYXJ0JywgdmFsdWU6ICdodHRwczovL2MyLnN0YXRpY2ZsaWNrci5jb20vMi8xNTYzLzI2NzAyMzE3MTU1X2UzYzNhOWRkNzFfei5qcGcnfSxcblx0XHR7dGV4dDogJ2NDb29sIENvbG9yIENoYXJ0JywgdmFsdWU6ICdodHRwczovL2MyLnN0YXRpY2ZsaWNrci5jb20vNC8zMDY1LzI5MjQzNDUyNjJfMjRkYzlkNjMyYV96LmpwZz96ej0xJ30sXG5cdFx0e3RleHQ6ICdEZW1vblB1cHB5JywgdmFsdWU6ICdodHRwczovL2Nyb3Nzb3JpZ2luLm1lL2h0dHBzOi8vZ2l0aHViLmNvbS9BZG1pcmFsUG90YXRvL25wb3MzZC9yYXcvbWFzdGVyL3Rlc3RzL3BuM19maWxlcy9kZW1vbnB1cHB5LnBuZyd9LFxuXHRcdHt0ZXh0OiAnSW50ZXJTcGhlcmUnLCB2YWx1ZTogJ2h0dHBzOi8vY3Jvc3NvcmlnaW4ubWUvaHR0cDovL251Y2xlYXJwaXhlbC5jb20vanMvbnBvczNkL3Rlc3RzL2ltZy9pbnRlcnNwaGVyZS5wbmcnfSxcblx0XHR7dGV4dDogJ2hzbD8nLCB2YWx1ZTogJ2h0dHBzOi8vY3Jvc3NvcmlnaW4ubWUvaHR0cDovL2NvZHJvcHNwei50eW1wYW51cy5uZXRkbmEtY2RuLmNvbS9jb2Ryb3BzL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE1LzAxL2hzbC1jb2xvci13aGVlbC5wbmcnfSxcblx0XSxcblx0ZGlzcGxheU1ldGhvZDogJ2hzbFNwaGVyZScsXG5cdGRpc3BsYXlNZXRob2RMaXN0OiBbJ3JnYkN1YmUnLCAnaHNsU3BoZXJlJywgJ2hzbENvbmVzJywgJ2hzbEN5bGluZGVyJywgJ2hzbEN1YmUnLCAnaHN2U3BoZXJlJywgJ2hzdkNvbmUnLCAnaHN2Q3lsaW5kZXInLCAnaHN2Q3ViZSddLFxuXHRjYW1lcmFNb2RlOiAncGVyc3BlY3RpdmUnLFxuXHRjYW1lcmFNb2RlTGlzdDogWydwZXJzcGVjdGl2ZScsICdvcnRob2dyYXBoaWMnXSxcblx0Y2FtZXJhUG9zaXRpb246ICdmcmVlJyxcblx0Y2FtZXJhUG9zaXRpb25MaXN0OiBbJ1RvcCcsICdGcm9udCcsICdSaWdodCcsICdXQ29ybmVyJywgJ0JvdHRvbScsICdCYWNrJywgJ0xlZnQnLCAnQkNvcm5lciddLFxuXHRjYW1lcmFQb3NpdGlvbktleW1hcDoge1xuXHRcdCdOdW1wYWQ3LTAnOiAnVG9wJyxcblx0XHQnTnVtcGFkMS0wJzogJ0Zyb250Jyxcblx0XHQnTnVtcGFkMy0wJzogJ1JpZ2h0Jyxcblx0XHQnTnVtcGFkMC0wJzogJ1dDb3JuZXInLFxuXHRcdCdOdW1wYWQ3LTEnOiAnQm90dG9tJyxcblx0XHQnTnVtcGFkMS0xJzogJ0JhY2snLFxuXHRcdCdOdW1wYWQzLTEnOiAnTGVmdCcsXG5cdFx0J051bXBhZDAtMSc6ICdCQ29ybmVyJ1xuXHR9LFxuXHRiYWNrZ3JvdW5kQ29sb3I6ICcyMCcsXG5cdGJhY2tncm91bmRDb2xvckxpc3Q6IFsnMCcsICcyMCcsICc0MCcsICc1MCcsICc2MCcsICc4MCcsICcxMDAnXSxcbn1cbiJdfQ==\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return buttonMixin; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(1);\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n\tdata: function data() {\n\t\treturn {\n\t\t\tid: 'inputUnique-' + this._uid,\n\t\t\tinternalValue: this.value\n\t\t};\n\t},\n\tprops: {\n\t\tlabel: String,\n\t\tvalue: String,\n\t\tdestinationAddress: String\n\t},\n\tmethods: {\n\t\tchange: function change() {\n\t\t\t__WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */].set(__WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */], this.destinationAddress, this.internalValue);\n\t\t}\n\t},\n\twatch: {\n\t\tvalue: function value(newValue) {\n\t\t\tthis.internalValue = newValue;\n\t\t}\n\t}\n});\n\nvar buttonMixin = {\n\tdata: function data() {\n\t\treturn {\n\t\t\tname: this.label.toLocaleLowerCase()\n\t\t};\n\t},\n\tprops: {\n\t\tlabel: String,\n\t\tdestinationAddress: String\n\t},\n\tcomputed: {\n\t\tclassObject: function classObject() {\n\t\t\tvar active = this.active();\n\t\t\treturn {\n\t\t\t\t'btn-primary': active,\n\t\t\t\t'btn-light': !active\n\t\t\t};\n\t\t},\n\t\tdisplayLabel: function displayLabel() {\n\t\t\treturn this.label;\n\t\t}\n\t},\n\tmethods: {\n\t\tactive: function active() {\n\t\t\treturn __WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */][this.destinationAddress] === this.name;\n\t\t},\n\t\tclick: function click() {\n\t\t\t__WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */][this.destinationAddress] = this.name;\n\t\t}\n\t}\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyY1xcbWl4aW4taW5wdXQuanMiXSwibmFtZXMiOlsiVnVlIiwic3RhdGUiLCJkYXRhIiwiaWQiLCJfdWlkIiwiaW50ZXJuYWxWYWx1ZSIsInZhbHVlIiwicHJvcHMiLCJsYWJlbCIsIlN0cmluZyIsImRlc3RpbmF0aW9uQWRkcmVzcyIsIm1ldGhvZHMiLCJjaGFuZ2UiLCJzZXQiLCJ3YXRjaCIsIm5ld1ZhbHVlIiwiYnV0dG9uTWl4aW4iLCJuYW1lIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJjb21wdXRlZCIsImNsYXNzT2JqZWN0IiwiYWN0aXZlIiwiZGlzcGxheUxhYmVsIiwiY2xpY2siXSwibWFwcGluZ3MiOiJBQUFBLE9BQU9BLEdBQVAsTUFBZ0IsS0FBaEI7QUFDQSxPQUFPQyxLQUFQLE1BQWtCLFNBQWxCOztBQUVBLGVBQWU7QUFDZEMsT0FBTSxnQkFBVTtBQUNmLFNBQU87QUFDTkMsT0FBSSxpQkFBaUIsS0FBS0MsSUFEcEI7QUFFTkMsa0JBQWUsS0FBS0M7QUFGZCxHQUFQO0FBSUEsRUFOYTtBQU9kQyxRQUFPO0FBQ05DLFNBQU9DLE1BREQ7QUFFTkgsU0FBT0csTUFGRDtBQUdOQyxzQkFBb0JEO0FBSGQsRUFQTztBQVlkRSxVQUFTO0FBQ1JDLFVBQVEsa0JBQVU7QUFDakJaLE9BQUlhLEdBQUosQ0FBUVosS0FBUixFQUFlLEtBQUtTLGtCQUFwQixFQUF3QyxLQUFLTCxhQUE3QztBQUNBO0FBSE8sRUFaSztBQWlCZFMsUUFBTztBQUNOUixTQUFPLGVBQVVTLFFBQVYsRUFBb0I7QUFDMUIsUUFBS1YsYUFBTCxHQUFxQlUsUUFBckI7QUFDQTtBQUhLO0FBakJPLENBQWY7O0FBd0JBLE9BQU8sSUFBSUMsY0FBYztBQUN4QmQsT0FBTSxnQkFBVTtBQUNmLFNBQU87QUFDTmUsU0FBTSxLQUFLVCxLQUFMLENBQVdVLGlCQUFYO0FBREEsR0FBUDtBQUdBLEVBTHVCO0FBTXhCWCxRQUFPO0FBQ05DLFNBQU9DLE1BREQ7QUFFTkMsc0JBQW9CRDtBQUZkLEVBTmlCO0FBVXhCVSxXQUFVO0FBQ1RDLGVBQWEsdUJBQVk7QUFDeEIsT0FBSUMsU0FBUyxLQUFLQSxNQUFMLEVBQWI7QUFDQSxVQUFPO0FBQ04sbUJBQWVBLE1BRFQ7QUFFTixpQkFBYSxDQUFDQTtBQUZSLElBQVA7QUFJQSxHQVBRO0FBUVRDLGdCQUFjLHdCQUFZO0FBQ3pCLFVBQU8sS0FBS2QsS0FBWjtBQUNBO0FBVlEsRUFWYztBQXNCeEJHLFVBQVM7QUFDUlUsVUFBUSxrQkFBWTtBQUNuQixVQUFPcEIsTUFBTSxLQUFLUyxrQkFBWCxNQUFtQyxLQUFLTyxJQUEvQztBQUNBLEdBSE87QUFJUk0sU0FBTyxpQkFBWTtBQUNsQnRCLFNBQU0sS0FBS1Msa0JBQVgsSUFBaUMsS0FBS08sSUFBdEM7QUFDQTtBQU5PO0FBdEJlLENBQWxCIiwiZmlsZSI6Im1peGluLWlucHV0LmpzIiwic291cmNlUm9vdCI6Ikc6L2Rldi9yYWluYm93c3BhY2UiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgc3RhdGUgZnJvbSAnLi9zdGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZGF0YTogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aWQ6ICdpbnB1dFVuaXF1ZS0nICsgdGhpcy5fdWlkLFxuXHRcdFx0aW50ZXJuYWxWYWx1ZTogdGhpcy52YWx1ZVxuXHRcdH1cblx0fSxcblx0cHJvcHM6IHtcblx0XHRsYWJlbDogU3RyaW5nLFxuXHRcdHZhbHVlOiBTdHJpbmcsXG5cdFx0ZGVzdGluYXRpb25BZGRyZXNzOiBTdHJpbmdcblx0fSxcblx0bWV0aG9kczoge1xuXHRcdGNoYW5nZTogZnVuY3Rpb24oKXtcblx0XHRcdFZ1ZS5zZXQoc3RhdGUsIHRoaXMuZGVzdGluYXRpb25BZGRyZXNzLCB0aGlzLmludGVybmFsVmFsdWUpO1xuXHRcdH1cblx0fSxcblx0d2F0Y2g6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG5cdFx0XHR0aGlzLmludGVybmFsVmFsdWUgPSBuZXdWYWx1ZTtcblx0XHR9XG5cdH0sXG59XG5cbmV4cG9ydCBsZXQgYnV0dG9uTWl4aW4gPSB7XG5cdGRhdGE6IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IHRoaXMubGFiZWwudG9Mb2NhbGVMb3dlckNhc2UoKVxuXHRcdH1cblx0fSxcblx0cHJvcHM6IHtcblx0XHRsYWJlbDogU3RyaW5nLFxuXHRcdGRlc3RpbmF0aW9uQWRkcmVzczogU3RyaW5nXG5cdH0sXG5cdGNvbXB1dGVkOiB7XG5cdFx0Y2xhc3NPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGxldCBhY3RpdmUgPSB0aGlzLmFjdGl2ZSgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0J2J0bi1wcmltYXJ5JzogYWN0aXZlLFxuXHRcdFx0XHQnYnRuLWxpZ2h0JzogIWFjdGl2ZSxcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRpc3BsYXlMYWJlbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGFiZWxcblx0XHR9XG5cdH0sXG5cdG1ldGhvZHM6IHtcblx0XHRhY3RpdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBzdGF0ZVt0aGlzLmRlc3RpbmF0aW9uQWRkcmVzc10gPT09IHRoaXMubmFtZTtcblx0XHR9LFxuXHRcdGNsaWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzdGF0ZVt0aGlzLmRlc3RpbmF0aW9uQWRkcmVzc10gPSB0aGlzLm5hbWU7XG5cdFx0fVxuXHR9XG59O1xuIl19\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return resizeWindowEventHandler; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vertifier__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_three__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_three___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_three__);\n\n\n\n\nvar viewportList = [];\nvar Viewport = function Viewport(renderCanvas, vueComponentInstance, dataCanvas) {\n\tvar p = this;\n\tp.width = 0;\n\tp.height = 0;\n\tp.dragging = false;\n\tp.dragPosLast = new __WEBPACK_IMPORTED_MODULE_2_three__[\"Vector2\"]();\n\tp.dragDiff = new __WEBPACK_IMPORTED_MODULE_2_three__[\"Vector2\"]();\n\tp.scene = new __WEBPACK_IMPORTED_MODULE_2_three__[\"Scene\"]();\n\tp.cameraMap = {\n\t\tperspective: new __WEBPACK_IMPORTED_MODULE_2_three__[\"PerspectiveCamera\"](45, 1, 0.1, 1000),\n\t\torthographic: new __WEBPACK_IMPORTED_MODULE_2_three__[\"OrthographicCamera\"](0, 0, 0, 0, 0, 1000)\n\t};\n\tp.cameraMap.perspective.position.z = p.cameraMap.orthographic.position.z = 25;\n\tp.orthographicMultiplier = 7;\n\tp.camera = null;\n\tp.cameraPosition = __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].cameraPosition;\n\tp.renderer = new __WEBPACK_IMPORTED_MODULE_2_three__[\"WebGLRenderer\"]({\n\t\tcanvas: renderCanvas,\n\t\tantialias: true,\n\t\talpha: true\n\t});\n\tp.canvas = renderCanvas;\n\tp.vue = vueComponentInstance;\n\n\tp.ambientLight = new __WEBPACK_IMPORTED_MODULE_2_three__[\"AmbientLight\"](0xffffff);\n\tp.scene.add(p.ambientLight);\n\n\tvar radialSegments = 24;\n\tvar openEnds = false;\n\tp.boundingGeometry = {\n\t\tCone: new __WEBPACK_IMPORTED_MODULE_2_three__[\"ConeGeometry\"](0.5, -1, radialSegments, 0, openEnds),\n\t\tCones: new __WEBPACK_IMPORTED_MODULE_2_three__[\"SphereGeometry\"](0.5, radialSegments, 2),\n\t\tCube: new __WEBPACK_IMPORTED_MODULE_2_three__[\"BoxGeometry\"](1, 1, 1),\n\t\tCylinder: new __WEBPACK_IMPORTED_MODULE_2_three__[\"CylinderGeometry\"](0.5, 0.5, 1, radialSegments, 1, openEnds),\n\t\tSphere: new __WEBPACK_IMPORTED_MODULE_2_three__[\"SphereGeometry\"](0.5, radialSegments, radialSegments / 2)\n\t};\n\tp.boundsMaterial = new __WEBPACK_IMPORTED_MODULE_2_three__[\"MeshBasicMaterial\"]();\n\tp.boundsMaterial.wireframe = true;\n\tp.boundsMaterial.opacity = 0.2;\n\tp.boundsMaterial.color.setHSL(0, 0, 0.5);\n\tp.boundsMaterial.transparent = true;\n\tp.bounds = new __WEBPACK_IMPORTED_MODULE_2_three__[\"Mesh\"](undefined, p.boundsMaterial);\n\tp.bounds.scale.setScalar(1.05);\n\tp.origin = new __WEBPACK_IMPORTED_MODULE_2_three__[\"Object3D\"]();\n\tp.origin.scale.setScalar(10);\n\tp.origin.rotation.x = Math.PI / 6;\n\tp.origin.add(p.bounds);\n\tp.scene.add(p.origin);\n\n\tp.vertifier = new __WEBPACK_IMPORTED_MODULE_1__vertifier__[\"a\" /* default */]({\n\t\timageUrl: __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].image,\n\t\tcallback: function callback() {\n\t\t\t//not quite sure why this doesn't work unless I add it after the image load\n\t\t\tp.origin.remove(p.vertifier.particleSystem);\n\t\t\tp.origin.add(p.vertifier.particleSystem);\n\t\t},\n\t\tdataCanvas: dataCanvas\n\t});\n\n\tp.grid = new __WEBPACK_IMPORTED_MODULE_2_three__[\"GridHelper\"](200, 20);\n\tp.grid.position.y = -50;\n\tp.grid.material.opacity = 0.5;\n\tp.grid.material.transparent = true;\n\tp.grid.material.wireframeLinewidth = 20;\n\tp.scene.add(p.grid);\n\n\tp.sizeWindow();\n\tviewportList.push(p);\n\twindow.viewport = p;\n};\n\nViewport.prototype = {\n\tcameraPositionMap: {\n\t\ttop: [Math.PI / 2, 0, 0],\n\t\tfront: [0, 0, 0],\n\t\tright: [0, -Math.PI / 2, 0],\n\t\twcorner: [Math.PI / 5.1043, -Math.PI / 4, 0],\n\t\tbottom: [-Math.PI / 2, 0, 0],\n\t\tback: [0, -Math.PI, 0],\n\t\tleft: [0, Math.PI / 2, 0],\n\t\tbcorner: [-Math.PI / 5.1043, 3 * Math.PI / 4, 0]\n\t},\n\tsizeWindow: function sizeWindow() {\n\t\tvar p = this;\n\t\tvar ratio = window.devicePixelRatio || 1;\n\t\tp.width = p.canvas.clientWidth * ratio;\n\t\tp.height = p.canvas.clientHeight * ratio;\n\t\tp.vue.width = p.width;\n\t\tp.vue.height = p.height;\n\n\t\tp.cameraMap.perspective.aspect = p.width / p.height;\n\t\tp.cameraMap.perspective.updateProjectionMatrix();\n\t\tp.updateOrthographicCameraScale();\n\t\t//p.renderer.setPixelRatio(ratio);\n\t\tp.renderer.setViewport(0, 0, p.width, p.height);\n\t},\n\tupdateOrthographicCameraScale: function updateOrthographicCameraScale() {\n\t\tvar p = this;\n\t\tvar orthographicScale = p.orthographicMultiplier / Math.min(p.width, p.height);\n\t\tvar oWidth = p.width * orthographicScale;\n\t\tvar oHeight = p.height * orthographicScale;\n\t\tp.cameraMap.orthographic.right = oWidth;\n\t\tp.cameraMap.orthographic.left = -oWidth;\n\t\tp.cameraMap.orthographic.top = oHeight;\n\t\tp.cameraMap.orthographic.bottom = -oHeight;\n\t\tp.cameraMap.orthographic.updateProjectionMatrix();\n\t},\n\trender: function render(time) {\n\t\tvar p = this;\n\t\tif (__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].autoRotateY) {\n\t\t\tp.origin.rotation.y += 0.005;\n\t\t}\n\t\tif (__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].autoRotateX) {\n\t\t\tp.origin.rotation.x += 0.005;\n\t\t}\n\t\tif (__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].cameraPosition !== 'free' && __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].cameraPosition !== p.cameraPosition) {\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].autoRotateY = false;\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].autoRotateX = false;\n\t\t\tp.cameraPosition = __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].cameraPosition;\n\t\t\tp.origin.rotation.fromArray(p.cameraPositionMap[p.cameraPosition]);\n\t\t}\n\t\tif (p.dragging) {\n\t\t\tp.origin.rotation.x += p.dragDiff.y * -0.01;\n\t\t\tp.origin.rotation.y += p.dragDiff.x * -0.01;\n\t\t\tp.dragDiff.set(0, 0);\n\t\t}\n\n\t\tp.camera = p.cameraMap[__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].cameraMode];\n\t\tif (p.vertifier.imageUrl !== __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].image) {\n\t\t\tp.vertifier.loadImage(__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].image);\n\t\t}\n\t\tif (p.vertifier.mapMethodName !== __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].displayMethod) {\n\t\t\tvar geomName = __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].displayMethod.slice(3);\n\t\t\tvar boundingGeom = p.boundingGeometry[geomName];\n\t\t\tif (boundingGeom) {\n\t\t\t\tp.bounds.geometry = boundingGeom;\n\t\t\t}\n\t\t\tp.vertifier.mapColorsToVerts(__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].displayMethod);\n\t\t}\n\t\tp.bounds.visible = __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].showBounds;\n\t\tp.renderer.render(p.scene, p.camera);\n\t},\n\tdragStart: function dragStart(x, y) {\n\t\tvar p = this;\n\t\tp.dragging = true;\n\t\tp.dragPosLast.set(x, y);\n\t\tp.cameraPosition = __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].cameraPosition = 'free';\n\t},\n\tdragMove: function dragMove(x, y) {\n\t\tvar p = this;\n\t\tvar current = new __WEBPACK_IMPORTED_MODULE_2_three__[\"Vector2\"](x, y);\n\t\tp.dragDiff = p.dragPosLast.clone().sub(current);\n\t\tp.dragPosLast.set(x, y);\n\t},\n\tdragStop: function dragStop() {\n\t\tvar p = this;\n\t\tp.dragging = false;\n\t\tp.dragDiff.set(0, 0);\n\t},\n\tscroll: function scroll(num) {\n\t\tthis.cameraMap.perspective.position.z = Math.max(this.cameraMap.perspective.position.z + num, -1.5);\n\t\tthis.orthographicMultiplier = Math.max(this.orthographicMultiplier + num * 0.25, 0.025);\n\t\tthis.updateOrthographicCameraScale();\n\t}\n};\n\nvar resizeWindowEventHandler = function resizeWindowEventHandler() {\n\tviewportList.forEach(function (item) {\n\t\titem.sizeWindow();\n\t});\n};\nvar renderAllViews = function renderAllViews(time) {\n\tviewportList.forEach(function (item) {\n\t\titem.render(time);\n\t});\n};\n\nvar go = true,\n    start = function start() {\n\tgo = true;\n\trequestAnimationFrame(render);\n},\n    stop = function stop() {\n\tgo = false;\n};\n\nvar render = function render(time) {\n\tif (go) {\n\t\trequestAnimationFrame(render);\n\t}\n\trenderAllViews(time);\n};\n\nstart();\n\n/* harmony default export */ __webpack_exports__[\"b\"] = (Viewport);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyY1xcdmlld3BvcnQuanMiXSwibmFtZXMiOlsic3RhdGUiLCJWZXJ0aWZpZXIiLCJUSFJFRSIsInZpZXdwb3J0TGlzdCIsIlZpZXdwb3J0IiwicmVuZGVyQ2FudmFzIiwidnVlQ29tcG9uZW50SW5zdGFuY2UiLCJkYXRhQ2FudmFzIiwicCIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhZ2dpbmciLCJkcmFnUG9zTGFzdCIsIlZlY3RvcjIiLCJkcmFnRGlmZiIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmFNYXAiLCJwZXJzcGVjdGl2ZSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwib3J0aG9ncmFwaGljIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwicG9zaXRpb24iLCJ6Iiwib3J0aG9ncmFwaGljTXVsdGlwbGllciIsImNhbWVyYSIsImNhbWVyYVBvc2l0aW9uIiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiY2FudmFzIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJ2dWUiLCJhbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHQiLCJhZGQiLCJyYWRpYWxTZWdtZW50cyIsIm9wZW5FbmRzIiwiYm91bmRpbmdHZW9tZXRyeSIsIkNvbmUiLCJDb25lR2VvbWV0cnkiLCJDb25lcyIsIlNwaGVyZUdlb21ldHJ5IiwiQ3ViZSIsIkJveEdlb21ldHJ5IiwiQ3lsaW5kZXIiLCJDeWxpbmRlckdlb21ldHJ5IiwiU3BoZXJlIiwiYm91bmRzTWF0ZXJpYWwiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIndpcmVmcmFtZSIsIm9wYWNpdHkiLCJjb2xvciIsInNldEhTTCIsInRyYW5zcGFyZW50IiwiYm91bmRzIiwiTWVzaCIsInVuZGVmaW5lZCIsInNjYWxlIiwic2V0U2NhbGFyIiwib3JpZ2luIiwiT2JqZWN0M0QiLCJyb3RhdGlvbiIsIngiLCJNYXRoIiwiUEkiLCJ2ZXJ0aWZpZXIiLCJpbWFnZVVybCIsImltYWdlIiwiY2FsbGJhY2siLCJyZW1vdmUiLCJwYXJ0aWNsZVN5c3RlbSIsImdyaWQiLCJHcmlkSGVscGVyIiwieSIsIm1hdGVyaWFsIiwid2lyZWZyYW1lTGluZXdpZHRoIiwic2l6ZVdpbmRvdyIsInB1c2giLCJ3aW5kb3ciLCJ2aWV3cG9ydCIsInByb3RvdHlwZSIsImNhbWVyYVBvc2l0aW9uTWFwIiwidG9wIiwiZnJvbnQiLCJyaWdodCIsIndjb3JuZXIiLCJib3R0b20iLCJiYWNrIiwibGVmdCIsImJjb3JuZXIiLCJyYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJ1cGRhdGVPcnRob2dyYXBoaWNDYW1lcmFTY2FsZSIsInNldFZpZXdwb3J0Iiwib3J0aG9ncmFwaGljU2NhbGUiLCJtaW4iLCJvV2lkdGgiLCJvSGVpZ2h0IiwicmVuZGVyIiwidGltZSIsImF1dG9Sb3RhdGVZIiwiYXV0b1JvdGF0ZVgiLCJmcm9tQXJyYXkiLCJzZXQiLCJjYW1lcmFNb2RlIiwibG9hZEltYWdlIiwibWFwTWV0aG9kTmFtZSIsImRpc3BsYXlNZXRob2QiLCJnZW9tTmFtZSIsInNsaWNlIiwiYm91bmRpbmdHZW9tIiwiZ2VvbWV0cnkiLCJtYXBDb2xvcnNUb1ZlcnRzIiwidmlzaWJsZSIsInNob3dCb3VuZHMiLCJkcmFnU3RhcnQiLCJkcmFnTW92ZSIsImN1cnJlbnQiLCJjbG9uZSIsInN1YiIsImRyYWdTdG9wIiwic2Nyb2xsIiwibnVtIiwibWF4IiwicmVzaXplV2luZG93RXZlbnRIYW5kbGVyIiwiZm9yRWFjaCIsIml0ZW0iLCJyZW5kZXJBbGxWaWV3cyIsImdvIiwic3RhcnQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdG9wIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPQSxLQUFQLE1BQWtCLFNBQWxCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixhQUF0QjtBQUNBLE9BQU8sS0FBS0MsS0FBWixNQUF1QixPQUF2Qjs7QUFFQSxJQUFJQyxlQUFlLEVBQW5CO0FBQ0EsSUFBSUMsV0FBVyxTQUFYQSxRQUFXLENBQVNDLFlBQVQsRUFBdUJDLG9CQUF2QixFQUE2Q0MsVUFBN0MsRUFBd0Q7QUFDdEUsS0FBSUMsSUFBSSxJQUFSO0FBQ0FBLEdBQUVDLEtBQUYsR0FBVSxDQUFWO0FBQ0FELEdBQUVFLE1BQUYsR0FBVyxDQUFYO0FBQ0FGLEdBQUVHLFFBQUYsR0FBYSxLQUFiO0FBQ0FILEdBQUVJLFdBQUYsR0FBZ0IsSUFBSVYsTUFBTVcsT0FBVixFQUFoQjtBQUNBTCxHQUFFTSxRQUFGLEdBQWEsSUFBSVosTUFBTVcsT0FBVixFQUFiO0FBQ0FMLEdBQUVPLEtBQUYsR0FBVSxJQUFJYixNQUFNYyxLQUFWLEVBQVY7QUFDQVIsR0FBRVMsU0FBRixHQUFjO0FBQ2JDLGVBQWEsSUFBSWhCLE1BQU1pQixpQkFBVixDQUE0QixFQUE1QixFQUFnQyxDQUFoQyxFQUFtQyxHQUFuQyxFQUF3QyxJQUF4QyxDQURBO0FBRWJDLGdCQUFjLElBQUlsQixNQUFNbUIsa0JBQVYsQ0FBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkMsRUFBc0MsQ0FBdEMsRUFBeUMsQ0FBekMsRUFBNEMsSUFBNUM7QUFGRCxFQUFkO0FBSUFiLEdBQUVTLFNBQUYsQ0FBWUMsV0FBWixDQUF3QkksUUFBeEIsQ0FBaUNDLENBQWpDLEdBQXFDZixFQUFFUyxTQUFGLENBQVlHLFlBQVosQ0FBeUJFLFFBQXpCLENBQWtDQyxDQUFsQyxHQUFzQyxFQUEzRTtBQUNBZixHQUFFZ0Isc0JBQUYsR0FBMkIsQ0FBM0I7QUFDQWhCLEdBQUVpQixNQUFGLEdBQVcsSUFBWDtBQUNBakIsR0FBRWtCLGNBQUYsR0FBbUIxQixNQUFNMEIsY0FBekI7QUFDQWxCLEdBQUVtQixRQUFGLEdBQWEsSUFBSXpCLE1BQU0wQixhQUFWLENBQXdCO0FBQ3BDQyxVQUFReEIsWUFENEI7QUFFcEN5QixhQUFXLElBRnlCO0FBR3BDQyxTQUFPO0FBSDZCLEVBQXhCLENBQWI7QUFLQXZCLEdBQUVxQixNQUFGLEdBQVd4QixZQUFYO0FBQ0FHLEdBQUV3QixHQUFGLEdBQVExQixvQkFBUjs7QUFFQUUsR0FBRXlCLFlBQUYsR0FBaUIsSUFBSS9CLE1BQU1nQyxZQUFWLENBQXVCLFFBQXZCLENBQWpCO0FBQ0ExQixHQUFFTyxLQUFGLENBQVFvQixHQUFSLENBQVkzQixFQUFFeUIsWUFBZDs7QUFFQSxLQUFJRyxpQkFBaUIsRUFBckI7QUFDQSxLQUFJQyxXQUFXLEtBQWY7QUFDQTdCLEdBQUU4QixnQkFBRixHQUFxQjtBQUNwQkMsUUFBTSxJQUFJckMsTUFBTXNDLFlBQVYsQ0FBdUIsR0FBdkIsRUFBNEIsQ0FBQyxDQUE3QixFQUFnQ0osY0FBaEMsRUFBZ0QsQ0FBaEQsRUFBbURDLFFBQW5ELENBRGM7QUFFcEJJLFNBQU8sSUFBSXZDLE1BQU13QyxjQUFWLENBQXlCLEdBQXpCLEVBQThCTixjQUE5QixFQUE4QyxDQUE5QyxDQUZhO0FBR3BCTyxRQUFNLElBQUl6QyxNQUFNMEMsV0FBVixDQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixDQUhjO0FBSXBCQyxZQUFVLElBQUkzQyxNQUFNNEMsZ0JBQVYsQ0FBMkIsR0FBM0IsRUFBZ0MsR0FBaEMsRUFBcUMsQ0FBckMsRUFBd0NWLGNBQXhDLEVBQXdELENBQXhELEVBQTJEQyxRQUEzRCxDQUpVO0FBS3BCVSxVQUFRLElBQUk3QyxNQUFNd0MsY0FBVixDQUF5QixHQUF6QixFQUE4Qk4sY0FBOUIsRUFBOENBLGlCQUFpQixDQUEvRDtBQUxZLEVBQXJCO0FBT0E1QixHQUFFd0MsY0FBRixHQUFtQixJQUFJOUMsTUFBTStDLGlCQUFWLEVBQW5CO0FBQ0F6QyxHQUFFd0MsY0FBRixDQUFpQkUsU0FBakIsR0FBNkIsSUFBN0I7QUFDQTFDLEdBQUV3QyxjQUFGLENBQWlCRyxPQUFqQixHQUEyQixHQUEzQjtBQUNBM0MsR0FBRXdDLGNBQUYsQ0FBaUJJLEtBQWpCLENBQXVCQyxNQUF2QixDQUE4QixDQUE5QixFQUFnQyxDQUFoQyxFQUFrQyxHQUFsQztBQUNBN0MsR0FBRXdDLGNBQUYsQ0FBaUJNLFdBQWpCLEdBQStCLElBQS9CO0FBQ0E5QyxHQUFFK0MsTUFBRixHQUFXLElBQUlyRCxNQUFNc0QsSUFBVixDQUFlQyxTQUFmLEVBQTBCakQsRUFBRXdDLGNBQTVCLENBQVg7QUFDQXhDLEdBQUUrQyxNQUFGLENBQVNHLEtBQVQsQ0FBZUMsU0FBZixDQUF5QixJQUF6QjtBQUNBbkQsR0FBRW9ELE1BQUYsR0FBVyxJQUFJMUQsTUFBTTJELFFBQVYsRUFBWDtBQUNBckQsR0FBRW9ELE1BQUYsQ0FBU0YsS0FBVCxDQUFlQyxTQUFmLENBQXlCLEVBQXpCO0FBQ0FuRCxHQUFFb0QsTUFBRixDQUFTRSxRQUFULENBQWtCQyxDQUFsQixHQUFzQkMsS0FBS0MsRUFBTCxHQUFVLENBQWhDO0FBQ0F6RCxHQUFFb0QsTUFBRixDQUFTekIsR0FBVCxDQUFhM0IsRUFBRStDLE1BQWY7QUFDQS9DLEdBQUVPLEtBQUYsQ0FBUW9CLEdBQVIsQ0FBWTNCLEVBQUVvRCxNQUFkOztBQUVBcEQsR0FBRTBELFNBQUYsR0FBYyxJQUFJakUsU0FBSixDQUFjO0FBQzNCa0UsWUFBVW5FLE1BQU1vRSxLQURXO0FBRTNCQyxZQUFVLG9CQUFVO0FBQ25CO0FBQ0E3RCxLQUFFb0QsTUFBRixDQUFTVSxNQUFULENBQWdCOUQsRUFBRTBELFNBQUYsQ0FBWUssY0FBNUI7QUFDQS9ELEtBQUVvRCxNQUFGLENBQVN6QixHQUFULENBQWEzQixFQUFFMEQsU0FBRixDQUFZSyxjQUF6QjtBQUNBLEdBTjBCO0FBTzNCaEUsY0FBWUE7QUFQZSxFQUFkLENBQWQ7O0FBVUFDLEdBQUVnRSxJQUFGLEdBQVMsSUFBSXRFLE1BQU11RSxVQUFWLENBQXNCLEdBQXRCLEVBQTJCLEVBQTNCLENBQVQ7QUFDQWpFLEdBQUVnRSxJQUFGLENBQU9sRCxRQUFQLENBQWdCb0QsQ0FBaEIsR0FBb0IsQ0FBQyxFQUFyQjtBQUNBbEUsR0FBRWdFLElBQUYsQ0FBT0csUUFBUCxDQUFnQnhCLE9BQWhCLEdBQTBCLEdBQTFCO0FBQ0EzQyxHQUFFZ0UsSUFBRixDQUFPRyxRQUFQLENBQWdCckIsV0FBaEIsR0FBOEIsSUFBOUI7QUFDQTlDLEdBQUVnRSxJQUFGLENBQU9HLFFBQVAsQ0FBZ0JDLGtCQUFoQixHQUFxQyxFQUFyQztBQUNBcEUsR0FBRU8sS0FBRixDQUFRb0IsR0FBUixDQUFhM0IsRUFBRWdFLElBQWY7O0FBRUFoRSxHQUFFcUUsVUFBRjtBQUNBMUUsY0FBYTJFLElBQWIsQ0FBa0J0RSxDQUFsQjtBQUNBdUUsUUFBT0MsUUFBUCxHQUFrQnhFLENBQWxCO0FBQ0EsQ0FyRUQ7O0FBdUVBSixTQUFTNkUsU0FBVCxHQUFxQjtBQUNwQkMsb0JBQW1CO0FBQ2xCQyxPQUFTLENBQVFuQixLQUFLQyxFQUFMLEdBQVUsQ0FBbEIsRUFBb0MsQ0FBcEMsRUFBdUMsQ0FBdkMsQ0FEUztBQUVsQm1CLFNBQVMsQ0FBa0IsQ0FBbEIsRUFBb0MsQ0FBcEMsRUFBdUMsQ0FBdkMsQ0FGUztBQUdsQkMsU0FBUyxDQUFrQixDQUFsQixFQUF5QixDQUFDckIsS0FBS0MsRUFBTixHQUFXLENBQXBDLEVBQXVDLENBQXZDLENBSFM7QUFJbEJxQixXQUFTLENBQUd0QixLQUFLQyxFQUFMLEdBQVUsTUFBYixFQUF5QixDQUFDRCxLQUFLQyxFQUFOLEdBQVcsQ0FBcEMsRUFBdUMsQ0FBdkMsQ0FKUztBQUtsQnNCLFVBQVMsQ0FBTyxDQUFDdkIsS0FBS0MsRUFBTixHQUFXLENBQWxCLEVBQW9DLENBQXBDLEVBQXVDLENBQXZDLENBTFM7QUFNbEJ1QixRQUFTLENBQWtCLENBQWxCLEVBQTZCLENBQUN4QixLQUFLQyxFQUFuQyxFQUF1QyxDQUF2QyxDQU5TO0FBT2xCd0IsUUFBUyxDQUFrQixDQUFsQixFQUEwQnpCLEtBQUtDLEVBQUwsR0FBVSxDQUFwQyxFQUF1QyxDQUF2QyxDQVBTO0FBUWxCeUIsV0FBUyxDQUFFLENBQUMxQixLQUFLQyxFQUFOLEdBQVcsTUFBYixFQUFzQixJQUFJRCxLQUFLQyxFQUFULEdBQWMsQ0FBcEMsRUFBdUMsQ0FBdkM7QUFSUyxFQURDO0FBV3BCWSxhQUFZLHNCQUFZO0FBQ3ZCLE1BQUlyRSxJQUFJLElBQVI7QUFDQSxNQUFJbUYsUUFBUVosT0FBT2EsZ0JBQVAsSUFBMkIsQ0FBdkM7QUFDQXBGLElBQUVDLEtBQUYsR0FBVUQsRUFBRXFCLE1BQUYsQ0FBU2dFLFdBQVQsR0FBdUJGLEtBQWpDO0FBQ0FuRixJQUFFRSxNQUFGLEdBQVdGLEVBQUVxQixNQUFGLENBQVNpRSxZQUFULEdBQXdCSCxLQUFuQztBQUNBbkYsSUFBRXdCLEdBQUYsQ0FBTXZCLEtBQU4sR0FBY0QsRUFBRUMsS0FBaEI7QUFDQUQsSUFBRXdCLEdBQUYsQ0FBTXRCLE1BQU4sR0FBZUYsRUFBRUUsTUFBakI7O0FBRUFGLElBQUVTLFNBQUYsQ0FBWUMsV0FBWixDQUF3QjZFLE1BQXhCLEdBQWlDdkYsRUFBRUMsS0FBRixHQUFVRCxFQUFFRSxNQUE3QztBQUNBRixJQUFFUyxTQUFGLENBQVlDLFdBQVosQ0FBd0I4RSxzQkFBeEI7QUFDQXhGLElBQUV5Riw2QkFBRjtBQUNBO0FBQ0F6RixJQUFFbUIsUUFBRixDQUFXdUUsV0FBWCxDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QjFGLEVBQUVDLEtBQS9CLEVBQXNDRCxFQUFFRSxNQUF4QztBQUNBLEVBeEJtQjtBQXlCcEJ1RixnQ0FBK0IseUNBQVU7QUFDeEMsTUFBSXpGLElBQUksSUFBUjtBQUNBLE1BQUkyRixvQkFBb0IzRixFQUFFZ0Isc0JBQUYsR0FBMkJ3QyxLQUFLb0MsR0FBTCxDQUFTNUYsRUFBRUMsS0FBWCxFQUFrQkQsRUFBRUUsTUFBcEIsQ0FBbkQ7QUFDQSxNQUFJMkYsU0FBUzdGLEVBQUVDLEtBQUYsR0FBVTBGLGlCQUF2QjtBQUNBLE1BQUlHLFVBQVU5RixFQUFFRSxNQUFGLEdBQVd5RixpQkFBekI7QUFDQTNGLElBQUVTLFNBQUYsQ0FBWUcsWUFBWixDQUF5QmlFLEtBQXpCLEdBQW1DZ0IsTUFBbkM7QUFDQTdGLElBQUVTLFNBQUYsQ0FBWUcsWUFBWixDQUF5QnFFLElBQXpCLEdBQWtDLENBQUNZLE1BQW5DO0FBQ0E3RixJQUFFUyxTQUFGLENBQVlHLFlBQVosQ0FBeUIrRCxHQUF6QixHQUFtQ21CLE9BQW5DO0FBQ0E5RixJQUFFUyxTQUFGLENBQVlHLFlBQVosQ0FBeUJtRSxNQUF6QixHQUFrQyxDQUFDZSxPQUFuQztBQUNBOUYsSUFBRVMsU0FBRixDQUFZRyxZQUFaLENBQXlCNEUsc0JBQXpCO0FBQ0EsRUFuQ21CO0FBb0NwQk8sU0FBUSxnQkFBVUMsSUFBVixFQUFnQjtBQUN2QixNQUFJaEcsSUFBSSxJQUFSO0FBQ0EsTUFBR1IsTUFBTXlHLFdBQVQsRUFBc0I7QUFBQ2pHLEtBQUVvRCxNQUFGLENBQVNFLFFBQVQsQ0FBa0JZLENBQWxCLElBQXVCLEtBQXZCO0FBQThCO0FBQ3JELE1BQUcxRSxNQUFNMEcsV0FBVCxFQUFzQjtBQUFDbEcsS0FBRW9ELE1BQUYsQ0FBU0UsUUFBVCxDQUFrQkMsQ0FBbEIsSUFBdUIsS0FBdkI7QUFBOEI7QUFDckQsTUFBRy9ELE1BQU0wQixjQUFOLEtBQXlCLE1BQXpCLElBQW1DMUIsTUFBTTBCLGNBQU4sS0FBeUJsQixFQUFFa0IsY0FBakUsRUFBZ0Y7QUFDL0UxQixTQUFNeUcsV0FBTixHQUFvQixLQUFwQjtBQUNBekcsU0FBTTBHLFdBQU4sR0FBb0IsS0FBcEI7QUFDQWxHLEtBQUVrQixjQUFGLEdBQW1CMUIsTUFBTTBCLGNBQXpCO0FBQ0FsQixLQUFFb0QsTUFBRixDQUFTRSxRQUFULENBQWtCNkMsU0FBbEIsQ0FBNEJuRyxFQUFFMEUsaUJBQUYsQ0FBb0IxRSxFQUFFa0IsY0FBdEIsQ0FBNUI7QUFDQTtBQUNELE1BQUdsQixFQUFFRyxRQUFMLEVBQWM7QUFDYkgsS0FBRW9ELE1BQUYsQ0FBU0UsUUFBVCxDQUFrQkMsQ0FBbEIsSUFBdUJ2RCxFQUFFTSxRQUFGLENBQVc0RCxDQUFYLEdBQWUsQ0FBQyxJQUF2QztBQUNBbEUsS0FBRW9ELE1BQUYsQ0FBU0UsUUFBVCxDQUFrQlksQ0FBbEIsSUFBdUJsRSxFQUFFTSxRQUFGLENBQVdpRCxDQUFYLEdBQWUsQ0FBQyxJQUF2QztBQUNBdkQsS0FBRU0sUUFBRixDQUFXOEYsR0FBWCxDQUFlLENBQWYsRUFBa0IsQ0FBbEI7QUFDQTs7QUFFRHBHLElBQUVpQixNQUFGLEdBQVdqQixFQUFFUyxTQUFGLENBQVlqQixNQUFNNkcsVUFBbEIsQ0FBWDtBQUNBLE1BQUdyRyxFQUFFMEQsU0FBRixDQUFZQyxRQUFaLEtBQXlCbkUsTUFBTW9FLEtBQWxDLEVBQXdDO0FBQ3ZDNUQsS0FBRTBELFNBQUYsQ0FBWTRDLFNBQVosQ0FBc0I5RyxNQUFNb0UsS0FBNUI7QUFDQTtBQUNELE1BQUc1RCxFQUFFMEQsU0FBRixDQUFZNkMsYUFBWixLQUE4Qi9HLE1BQU1nSCxhQUF2QyxFQUFxRDtBQUNwRCxPQUFJQyxXQUFXakgsTUFBTWdILGFBQU4sQ0FBb0JFLEtBQXBCLENBQTBCLENBQTFCLENBQWY7QUFDQSxPQUFJQyxlQUFlM0csRUFBRThCLGdCQUFGLENBQW1CMkUsUUFBbkIsQ0FBbkI7QUFDQSxPQUFHRSxZQUFILEVBQWdCO0FBQ2YzRyxNQUFFK0MsTUFBRixDQUFTNkQsUUFBVCxHQUFvQkQsWUFBcEI7QUFDQTtBQUNEM0csS0FBRTBELFNBQUYsQ0FBWW1ELGdCQUFaLENBQTZCckgsTUFBTWdILGFBQW5DO0FBQ0E7QUFDRHhHLElBQUUrQyxNQUFGLENBQVMrRCxPQUFULEdBQW1CdEgsTUFBTXVILFVBQXpCO0FBQ0EvRyxJQUFFbUIsUUFBRixDQUFXNEUsTUFBWCxDQUFrQi9GLEVBQUVPLEtBQXBCLEVBQTJCUCxFQUFFaUIsTUFBN0I7QUFDQSxFQWxFbUI7QUFtRXBCK0YsWUFBVyxtQkFBU3pELENBQVQsRUFBWVcsQ0FBWixFQUFjO0FBQ3hCLE1BQUlsRSxJQUFJLElBQVI7QUFDQUEsSUFBRUcsUUFBRixHQUFhLElBQWI7QUFDQUgsSUFBRUksV0FBRixDQUFjZ0csR0FBZCxDQUFrQjdDLENBQWxCLEVBQXFCVyxDQUFyQjtBQUNBbEUsSUFBRWtCLGNBQUYsR0FBbUIxQixNQUFNMEIsY0FBTixHQUF1QixNQUExQztBQUNBLEVBeEVtQjtBQXlFcEIrRixXQUFVLGtCQUFTMUQsQ0FBVCxFQUFZVyxDQUFaLEVBQWM7QUFDdkIsTUFBSWxFLElBQUksSUFBUjtBQUNBLE1BQUlrSCxVQUFVLElBQUl4SCxNQUFNVyxPQUFWLENBQWtCa0QsQ0FBbEIsRUFBcUJXLENBQXJCLENBQWQ7QUFDQWxFLElBQUVNLFFBQUYsR0FBYU4sRUFBRUksV0FBRixDQUFjK0csS0FBZCxHQUFzQkMsR0FBdEIsQ0FBMEJGLE9BQTFCLENBQWI7QUFDQWxILElBQUVJLFdBQUYsQ0FBY2dHLEdBQWQsQ0FBa0I3QyxDQUFsQixFQUFxQlcsQ0FBckI7QUFDQSxFQTlFbUI7QUErRXBCbUQsV0FBVSxvQkFBVTtBQUNuQixNQUFJckgsSUFBSSxJQUFSO0FBQ0FBLElBQUVHLFFBQUYsR0FBYSxLQUFiO0FBQ0FILElBQUVNLFFBQUYsQ0FBVzhGLEdBQVgsQ0FBZSxDQUFmLEVBQWtCLENBQWxCO0FBQ0EsRUFuRm1CO0FBb0ZwQmtCLFNBQVEsZ0JBQVNDLEdBQVQsRUFBYTtBQUNwQixPQUFLOUcsU0FBTCxDQUFlQyxXQUFmLENBQTJCSSxRQUEzQixDQUFvQ0MsQ0FBcEMsR0FBd0N5QyxLQUFLZ0UsR0FBTCxDQUN2QyxLQUFLL0csU0FBTCxDQUFlQyxXQUFmLENBQTJCSSxRQUEzQixDQUFvQ0MsQ0FBcEMsR0FBd0N3RyxHQURELEVBRXZDLENBQUMsR0FGc0MsQ0FBeEM7QUFJQSxPQUFLdkcsc0JBQUwsR0FBOEJ3QyxLQUFLZ0UsR0FBTCxDQUM3QixLQUFLeEcsc0JBQUwsR0FBOEJ1RyxNQUFNLElBRFAsRUFFN0IsS0FGNkIsQ0FBOUI7QUFJQSxPQUFLOUIsNkJBQUw7QUFDQTtBQTlGbUIsQ0FBckI7O0FBaUdBLE9BQU8sSUFBSWdDLDJCQUEyQixTQUEzQkEsd0JBQTJCLEdBQVk7QUFDakQ5SCxjQUFhK0gsT0FBYixDQUFxQixVQUFVQyxJQUFWLEVBQWdCO0FBQ3BDQSxPQUFLdEQsVUFBTDtBQUNBLEVBRkQ7QUFHQSxDQUpNO0FBS1AsSUFBSXVELGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBVTVCLElBQVYsRUFBZ0I7QUFDbkNyRyxjQUFhK0gsT0FBYixDQUFxQixVQUFVQyxJQUFWLEVBQWdCO0FBQ3BDQSxPQUFLNUIsTUFBTCxDQUFZQyxJQUFaO0FBQ0EsRUFGRDtBQUdBLENBSkY7O0FBTUEsSUFBSTZCLEtBQUssSUFBVDtBQUFBLElBQ0NDLFFBQVEsU0FBUkEsS0FBUSxHQUFVO0FBQ2pCRCxNQUFLLElBQUw7QUFDQUUsdUJBQXNCaEMsTUFBdEI7QUFDQSxDQUpGO0FBQUEsSUFLQ2lDLE9BQU8sU0FBUEEsSUFBTyxHQUFVO0FBQ2hCSCxNQUFLLEtBQUw7QUFDQSxDQVBGOztBQVNBLElBQUk5QixTQUFTLFNBQVRBLE1BQVMsQ0FBVUMsSUFBVixFQUFlO0FBQzNCLEtBQUc2QixFQUFILEVBQU07QUFDTEUsd0JBQXNCaEMsTUFBdEI7QUFDQTtBQUNENkIsZ0JBQWU1QixJQUFmO0FBQ0EsQ0FMRDs7QUFPQThCOztBQUVBLGVBQWVsSSxRQUFmIiwiZmlsZSI6InZpZXdwb3J0LmpzIiwic291cmNlUm9vdCI6Ikc6L2Rldi9yYWluYm93c3BhY2UiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RhdGUgZnJvbSAnLi9zdGF0ZSc7XG5pbXBvcnQgVmVydGlmaWVyIGZyb20gJy4vdmVydGlmaWVyJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxubGV0IHZpZXdwb3J0TGlzdCA9IFtdO1xubGV0IFZpZXdwb3J0ID0gZnVuY3Rpb24ocmVuZGVyQ2FudmFzLCB2dWVDb21wb25lbnRJbnN0YW5jZSwgZGF0YUNhbnZhcyl7XG5cdGxldCBwID0gdGhpcztcblx0cC53aWR0aCA9IDA7XG5cdHAuaGVpZ2h0ID0gMDtcblx0cC5kcmFnZ2luZyA9IGZhbHNlO1xuXHRwLmRyYWdQb3NMYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0cC5kcmFnRGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHAuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblx0cC5jYW1lcmFNYXAgPSB7XG5cdFx0cGVyc3BlY3RpdmU6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgMSwgMC4xLCAxMDAwKSxcblx0XHRvcnRob2dyYXBoaWM6IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMCwgMTAwMCksXG5cdH07XG5cdHAuY2FtZXJhTWFwLnBlcnNwZWN0aXZlLnBvc2l0aW9uLnogPSBwLmNhbWVyYU1hcC5vcnRob2dyYXBoaWMucG9zaXRpb24ueiA9IDI1O1xuXHRwLm9ydGhvZ3JhcGhpY011bHRpcGxpZXIgPSA3O1xuXHRwLmNhbWVyYSA9IG51bGw7XG5cdHAuY2FtZXJhUG9zaXRpb24gPSBzdGF0ZS5jYW1lcmFQb3NpdGlvbjtcblx0cC5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcblx0XHRjYW52YXM6IHJlbmRlckNhbnZhcyxcblx0XHRhbnRpYWxpYXM6IHRydWUsXG5cdFx0YWxwaGE6IHRydWVcblx0fSk7XG5cdHAuY2FudmFzID0gcmVuZGVyQ2FudmFzO1xuXHRwLnZ1ZSA9IHZ1ZUNvbXBvbmVudEluc3RhbmNlO1xuXG5cdHAuYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCgweGZmZmZmZik7XG5cdHAuc2NlbmUuYWRkKHAuYW1iaWVudExpZ2h0KTtcblxuXHRsZXQgcmFkaWFsU2VnbWVudHMgPSAyNDtcblx0bGV0IG9wZW5FbmRzID0gZmFsc2U7XG5cdHAuYm91bmRpbmdHZW9tZXRyeSA9IHtcblx0XHRDb25lOiBuZXcgVEhSRUUuQ29uZUdlb21ldHJ5KDAuNSwgLTEsIHJhZGlhbFNlZ21lbnRzLCAwLCBvcGVuRW5kcyksXG5cdFx0Q29uZXM6IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjUsIHJhZGlhbFNlZ21lbnRzLCAyKSxcblx0XHRDdWJlOiBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMSwgMSwgMSksXG5cdFx0Q3lsaW5kZXI6IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KDAuNSwgMC41LCAxLCByYWRpYWxTZWdtZW50cywgMSwgb3BlbkVuZHMpLFxuXHRcdFNwaGVyZTogbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNSwgcmFkaWFsU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzIC8gMilcblx0fTtcblx0cC5ib3VuZHNNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgpO1xuXHRwLmJvdW5kc01hdGVyaWFsLndpcmVmcmFtZSA9IHRydWU7XG5cdHAuYm91bmRzTWF0ZXJpYWwub3BhY2l0eSA9IDAuMjtcblx0cC5ib3VuZHNNYXRlcmlhbC5jb2xvci5zZXRIU0woMCwwLDAuNSk7XG5cdHAuYm91bmRzTWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRwLmJvdW5kcyA9IG5ldyBUSFJFRS5NZXNoKHVuZGVmaW5lZCwgcC5ib3VuZHNNYXRlcmlhbCk7XG5cdHAuYm91bmRzLnNjYWxlLnNldFNjYWxhcigxLjA1KTtcblx0cC5vcmlnaW4gPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblx0cC5vcmlnaW4uc2NhbGUuc2V0U2NhbGFyKDEwKTtcblx0cC5vcmlnaW4ucm90YXRpb24ueCA9IE1hdGguUEkgLyA2O1xuXHRwLm9yaWdpbi5hZGQocC5ib3VuZHMpO1xuXHRwLnNjZW5lLmFkZChwLm9yaWdpbik7XG5cblx0cC52ZXJ0aWZpZXIgPSBuZXcgVmVydGlmaWVyKHtcblx0XHRpbWFnZVVybDogc3RhdGUuaW1hZ2UsXG5cdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKCl7XG5cdFx0XHQvL25vdCBxdWl0ZSBzdXJlIHdoeSB0aGlzIGRvZXNuJ3Qgd29yayB1bmxlc3MgSSBhZGQgaXQgYWZ0ZXIgdGhlIGltYWdlIGxvYWRcblx0XHRcdHAub3JpZ2luLnJlbW92ZShwLnZlcnRpZmllci5wYXJ0aWNsZVN5c3RlbSk7XG5cdFx0XHRwLm9yaWdpbi5hZGQocC52ZXJ0aWZpZXIucGFydGljbGVTeXN0ZW0pO1xuXHRcdH0sXG5cdFx0ZGF0YUNhbnZhczogZGF0YUNhbnZhc1xuXHR9KTtcblxuXHRwLmdyaWQgPSBuZXcgVEhSRUUuR3JpZEhlbHBlciggMjAwLCAyMCApO1xuXHRwLmdyaWQucG9zaXRpb24ueSA9IC01MDtcblx0cC5ncmlkLm1hdGVyaWFsLm9wYWNpdHkgPSAwLjU7XG5cdHAuZ3JpZC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cdHAuZ3JpZC5tYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSAyMDtcblx0cC5zY2VuZS5hZGQoIHAuZ3JpZCApO1xuXG5cdHAuc2l6ZVdpbmRvdygpO1xuXHR2aWV3cG9ydExpc3QucHVzaChwKTtcblx0d2luZG93LnZpZXdwb3J0ID0gcDtcbn07XG5cblZpZXdwb3J0LnByb3RvdHlwZSA9IHtcblx0Y2FtZXJhUG9zaXRpb25NYXA6IHtcblx0XHR0b3A6ICAgICBbICAgICAgIE1hdGguUEkgLyAyLCAgICAgICAgICAgICAgICAwLCAwIF0sXG5cdFx0ZnJvbnQ6ICAgWyAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgMCwgMCBdLFxuXHRcdHJpZ2h0OiAgIFsgICAgICAgICAgICAgICAgIDAsICAgICAtTWF0aC5QSSAvIDIsIDAgXSxcblx0XHR3Y29ybmVyOiBbICBNYXRoLlBJIC8gNS4xMDQzLCAgICAgLU1hdGguUEkgLyA0LCAwIF0sXG5cdFx0Ym90dG9tOiAgWyAgICAgIC1NYXRoLlBJIC8gMiwgICAgICAgICAgICAgICAgMCwgMCBdLFxuXHRcdGJhY2s6ICAgIFsgICAgICAgICAgICAgICAgIDAsICAgICAgICAgLU1hdGguUEksIDAgXSxcblx0XHRsZWZ0OiAgICBbICAgICAgICAgICAgICAgICAwLCAgICAgIE1hdGguUEkgLyAyLCAwIF0sXG5cdFx0YmNvcm5lcjogWyAtTWF0aC5QSSAvIDUuMTA0MywgIDMgKiBNYXRoLlBJIC8gNCwgMCBdXG5cdH0sXG5cdHNpemVXaW5kb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRsZXQgcCA9IHRoaXM7XG5cdFx0bGV0IHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblx0XHRwLndpZHRoID0gcC5jYW52YXMuY2xpZW50V2lkdGggKiByYXRpbztcblx0XHRwLmhlaWdodCA9IHAuY2FudmFzLmNsaWVudEhlaWdodCAqIHJhdGlvO1xuXHRcdHAudnVlLndpZHRoID0gcC53aWR0aDtcblx0XHRwLnZ1ZS5oZWlnaHQgPSBwLmhlaWdodDtcblxuXHRcdHAuY2FtZXJhTWFwLnBlcnNwZWN0aXZlLmFzcGVjdCA9IHAud2lkdGggLyBwLmhlaWdodDtcblx0XHRwLmNhbWVyYU1hcC5wZXJzcGVjdGl2ZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0cC51cGRhdGVPcnRob2dyYXBoaWNDYW1lcmFTY2FsZSgpO1xuXHRcdC8vcC5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHJhdGlvKTtcblx0XHRwLnJlbmRlcmVyLnNldFZpZXdwb3J0KDAsIDAsIHAud2lkdGgsIHAuaGVpZ2h0KTtcblx0fSxcblx0dXBkYXRlT3J0aG9ncmFwaGljQ2FtZXJhU2NhbGU6IGZ1bmN0aW9uKCl7XG5cdFx0bGV0IHAgPSB0aGlzO1xuXHRcdGxldCBvcnRob2dyYXBoaWNTY2FsZSA9IHAub3J0aG9ncmFwaGljTXVsdGlwbGllciAvIE1hdGgubWluKHAud2lkdGgsIHAuaGVpZ2h0KTtcblx0XHRsZXQgb1dpZHRoID0gcC53aWR0aCAqIG9ydGhvZ3JhcGhpY1NjYWxlO1xuXHRcdGxldCBvSGVpZ2h0ID0gcC5oZWlnaHQgKiBvcnRob2dyYXBoaWNTY2FsZTtcblx0XHRwLmNhbWVyYU1hcC5vcnRob2dyYXBoaWMucmlnaHQgID0gIG9XaWR0aDtcblx0XHRwLmNhbWVyYU1hcC5vcnRob2dyYXBoaWMubGVmdCAgID0gLW9XaWR0aDtcblx0XHRwLmNhbWVyYU1hcC5vcnRob2dyYXBoaWMudG9wICAgID0gIG9IZWlnaHQ7XG5cdFx0cC5jYW1lcmFNYXAub3J0aG9ncmFwaGljLmJvdHRvbSA9IC1vSGVpZ2h0O1xuXHRcdHAuY2FtZXJhTWFwLm9ydGhvZ3JhcGhpYy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdH0sXG5cdHJlbmRlcjogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHRsZXQgcCA9IHRoaXM7XG5cdFx0aWYoc3RhdGUuYXV0b1JvdGF0ZVkpIHtwLm9yaWdpbi5yb3RhdGlvbi55ICs9IDAuMDA1O31cblx0XHRpZihzdGF0ZS5hdXRvUm90YXRlWCkge3Aub3JpZ2luLnJvdGF0aW9uLnggKz0gMC4wMDU7fVxuXHRcdGlmKHN0YXRlLmNhbWVyYVBvc2l0aW9uICE9PSAnZnJlZScgJiYgc3RhdGUuY2FtZXJhUG9zaXRpb24gIT09IHAuY2FtZXJhUG9zaXRpb24pe1xuXHRcdFx0c3RhdGUuYXV0b1JvdGF0ZVkgPSBmYWxzZTtcblx0XHRcdHN0YXRlLmF1dG9Sb3RhdGVYID0gZmFsc2U7XG5cdFx0XHRwLmNhbWVyYVBvc2l0aW9uID0gc3RhdGUuY2FtZXJhUG9zaXRpb247XG5cdFx0XHRwLm9yaWdpbi5yb3RhdGlvbi5mcm9tQXJyYXkocC5jYW1lcmFQb3NpdGlvbk1hcFtwLmNhbWVyYVBvc2l0aW9uXSk7XG5cdFx0fVxuXHRcdGlmKHAuZHJhZ2dpbmcpe1xuXHRcdFx0cC5vcmlnaW4ucm90YXRpb24ueCArPSBwLmRyYWdEaWZmLnkgKiAtMC4wMTtcblx0XHRcdHAub3JpZ2luLnJvdGF0aW9uLnkgKz0gcC5kcmFnRGlmZi54ICogLTAuMDE7XG5cdFx0XHRwLmRyYWdEaWZmLnNldCgwLCAwKTtcblx0XHR9XG5cblx0XHRwLmNhbWVyYSA9IHAuY2FtZXJhTWFwW3N0YXRlLmNhbWVyYU1vZGVdO1xuXHRcdGlmKHAudmVydGlmaWVyLmltYWdlVXJsICE9PSBzdGF0ZS5pbWFnZSl7XG5cdFx0XHRwLnZlcnRpZmllci5sb2FkSW1hZ2Uoc3RhdGUuaW1hZ2UpO1xuXHRcdH1cblx0XHRpZihwLnZlcnRpZmllci5tYXBNZXRob2ROYW1lICE9PSBzdGF0ZS5kaXNwbGF5TWV0aG9kKXtcblx0XHRcdGxldCBnZW9tTmFtZSA9IHN0YXRlLmRpc3BsYXlNZXRob2Quc2xpY2UoMyk7XG5cdFx0XHRsZXQgYm91bmRpbmdHZW9tID0gcC5ib3VuZGluZ0dlb21ldHJ5W2dlb21OYW1lXTtcblx0XHRcdGlmKGJvdW5kaW5nR2VvbSl7XG5cdFx0XHRcdHAuYm91bmRzLmdlb21ldHJ5ID0gYm91bmRpbmdHZW9tO1xuXHRcdFx0fVxuXHRcdFx0cC52ZXJ0aWZpZXIubWFwQ29sb3JzVG9WZXJ0cyhzdGF0ZS5kaXNwbGF5TWV0aG9kKTtcblx0XHR9XG5cdFx0cC5ib3VuZHMudmlzaWJsZSA9IHN0YXRlLnNob3dCb3VuZHM7XG5cdFx0cC5yZW5kZXJlci5yZW5kZXIocC5zY2VuZSwgcC5jYW1lcmEpO1xuXHR9LFxuXHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKHgsIHkpe1xuXHRcdGxldCBwID0gdGhpcztcblx0XHRwLmRyYWdnaW5nID0gdHJ1ZTtcblx0XHRwLmRyYWdQb3NMYXN0LnNldCh4LCB5KTtcblx0XHRwLmNhbWVyYVBvc2l0aW9uID0gc3RhdGUuY2FtZXJhUG9zaXRpb24gPSAnZnJlZSc7XG5cdH0sXG5cdGRyYWdNb3ZlOiBmdW5jdGlvbih4LCB5KXtcblx0XHRsZXQgcCA9IHRoaXM7XG5cdFx0bGV0IGN1cnJlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMih4LCB5KTtcblx0XHRwLmRyYWdEaWZmID0gcC5kcmFnUG9zTGFzdC5jbG9uZSgpLnN1YihjdXJyZW50KTtcblx0XHRwLmRyYWdQb3NMYXN0LnNldCh4LCB5KTtcblx0fSxcblx0ZHJhZ1N0b3A6IGZ1bmN0aW9uKCl7XG5cdFx0bGV0IHAgPSB0aGlzO1xuXHRcdHAuZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRwLmRyYWdEaWZmLnNldCgwLCAwKTtcblx0fSxcblx0c2Nyb2xsOiBmdW5jdGlvbihudW0pe1xuXHRcdHRoaXMuY2FtZXJhTWFwLnBlcnNwZWN0aXZlLnBvc2l0aW9uLnogPSBNYXRoLm1heChcblx0XHRcdHRoaXMuY2FtZXJhTWFwLnBlcnNwZWN0aXZlLnBvc2l0aW9uLnogKyBudW0sXG5cdFx0XHQtMS41XG5cdFx0KTtcblx0XHR0aGlzLm9ydGhvZ3JhcGhpY011bHRpcGxpZXIgPSBNYXRoLm1heChcblx0XHRcdHRoaXMub3J0aG9ncmFwaGljTXVsdGlwbGllciArIG51bSAqIDAuMjUsXG5cdFx0XHQwLjAyNVxuXHRcdCk7XG5cdFx0dGhpcy51cGRhdGVPcnRob2dyYXBoaWNDYW1lcmFTY2FsZSgpO1xuXHR9XG59O1xuXG5leHBvcnQgbGV0IHJlc2l6ZVdpbmRvd0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblx0dmlld3BvcnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRpdGVtLnNpemVXaW5kb3coKTtcblx0fSk7XG59O1xubGV0IHJlbmRlckFsbFZpZXdzID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR2aWV3cG9ydExpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0aXRlbS5yZW5kZXIodGltZSk7XG5cdFx0fSk7XG5cdH07XG5cbmxldCBnbyA9IHRydWUsXG5cdHN0YXJ0ID0gZnVuY3Rpb24oKXtcblx0XHRnbyA9IHRydWU7XG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG5cdH0sXG5cdHN0b3AgPSBmdW5jdGlvbigpe1xuXHRcdGdvID0gZmFsc2U7XG5cdH07XG5cbmxldCByZW5kZXIgPSBmdW5jdGlvbiAodGltZSl7XG5cdGlmKGdvKXtcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcblx0fVxuXHRyZW5kZXJBbGxWaWV3cyh0aW1lKTtcbn07XG5cbnN0YXJ0KCk7XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0O1xuIl19\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.4.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(val);\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\n\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this) : parentVal\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn.call(this, parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (parentVal, childVal) {\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeInject(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode, deep) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  if (deep && vnode.children) {\n    cloned.children = cloneVNodes(vnode.children);\n  }\n  return cloned\n}\n\nfunction cloneVNodes (vnodes, deep) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i], deep);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  var plain = !(passive || once$$1 || capture);\n  return {\n    name: name,\n    plain: plain,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\n// #6552\nfunction prioritizePlainEvents (a, b) {\n  return a.plain ? -1 : b.plain ? 1 : 0\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  var toAdd = [];\n  var hasModifier = false;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!event.plain) { hasModifier = true; }\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      event.handler = cur;\n      toAdd.push(event);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  if (toAdd.length) {\n    if (hasModifier) { toAdd.sort(prioritizePlainEvents); }\n    for (var i = 0; i < toAdd.length; i++) {\n      var event$1 = toAdd[i];\n      add(event$1.name, event$1.handler, event$1.once, event$1.capture, event$1.passive);\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (comp.__esModule && comp.default) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$off(event[i], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    if (fn) {\n      // specific handler\n      var cb;\n      var i$1 = cbs.length;\n      while (i$1--) {\n        cb = cbs[i$1];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i$1, 1);\n          break\n        }\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (false) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (false) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction checkOptionType (vm, name) {\n  var option = vm.$options[name];\n  if (!isPlainObject(option)) {\n    warn(\n      (\"component option \\\"\" + name + \"\\\" should be an object.\"),\n      vm\n    );\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (false) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  \"production\" !== 'production' && checkOptionType(vm, 'computed');\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : userDef;\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (false) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  \"production\" !== 'production' && checkOptionType(vm, 'methods');\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  \"production\" !== 'production' && checkOptionType(vm, 'watch');\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n        ? Reflect.ownKeys(inject).filter(function (key) {\n          /* istanbul ignore next */\n          return Object.getOwnPropertyDescriptor(inject, key).enumerable\n        })\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (false) {\n        warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || emptyObject,\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (false\n  ) {\n    warn(\n      'Avoid using non-primitive value as key, ' +\n      'use string/number value instead.',\n      context\n    );\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(ours, existing) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (false) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // if the parent didn't update, the slot nodes will be the ones from\n      // last render. They need to be cloned to ensure \"freshness\" for this render.\n      for (var key in vm.$slots) {\n        var slot = vm.$slots[key];\n        if (slot._rendered) {\n          vm.$slots[key] = cloneVNodes(slot, true /* deep */);\n        }\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n  Vue.prototype._g = bindObjectListeners;\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp, Array];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.4.4';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\n\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.elm = elm;\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (false\n              ) {\n                bailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (false\n              ) {\n                bailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\n\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\n\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar str;\nvar index$1;\n\n/*  */\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number) {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$options._renderChildren;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(34)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_three__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_three___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_three__);\n\n\n\nvar Vertifier = function Vertifier(args) {\n\tvar t = this;\n\tt.imageUrl = args.imageUrl || console.break('MISSING IMAGE URL');\n\tt.callback = args.callback || console.break('MISSING CALLBACK');\n\tt.dataCanvas = args.dataCanvas || document.createElement('canvas');\n\tt.mapMethodName = args.mapMethodName || 'rgbCube';\n\n\tt.loader = new __WEBPACK_IMPORTED_MODULE_1_three__[\"TextureLoader\"]();\n\tt.vertexGeom = new __WEBPACK_IMPORTED_MODULE_1_three__[\"Geometry\"]();\n\tt.vertexMaterial = new __WEBPACK_IMPORTED_MODULE_1_three__[\"PointsMaterial\"]({\n\t\tsize: 5 * window.devicePixelRatio,\n\t\tsizeAttenuation: false,\n\t\tvertexColors: __WEBPACK_IMPORTED_MODULE_1_three__[\"VertexColors\"]\n\t});\n\tt.particleSystem = new __WEBPACK_IMPORTED_MODULE_1_three__[\"Points\"](t.vertexGeom, t.vertexMaterial);\n\tt.loadImage();\n};\n\nVertifier.loadedImageMap = {};\nVertifier.loadedGeomMap = {};\n\nVertifier.prototype = {\n\tcrossOriginProxy: 'http://crossorigin.me/',\n\tloadImage: function loadImage(imageUrl, tryWithCrossOrigin) {\n\t\tvar t = this;\n\t\tvar imageKey = t.imageUrl = imageUrl || t.imageUrl; //TODO: brain better later. force lexical capturing now.\n\t\tvar origin = tryWithCrossOrigin ? t.crossOriginProxy : '';\n\t\tvar image = Vertifier.loadedImageMap[imageKey];\n\t\tvar geometry = Vertifier.loadedGeomMap[imageKey];\n\t\tif (image && geometry) {\n\t\t\tconsole.log('Vertifier.loadImage: using already loaded ' + imageKey);\n\t\t\tt.swapGeometry(geometry);\n\t\t} else if (image && !geometry) {\n\t\t\tgeometry = Vertifier.loadedGeomMap[imageKey] = t.makeGeometryFromImage(image);\n\t\t\tt.swapGeometry(geometry);\n\t\t} else {\n\t\t\tt.loader.load(origin + imageKey, function (texture) {\n\t\t\t\tconsole.log('Vertifier.loadImage: finished loading ' + imageKey);\n\t\t\t\timage = Vertifier.loadedImageMap[imageKey] = texture.image;\n\t\t\t\tgeometry = Vertifier.loadedGeomMap[imageKey] = t.makeGeometryFromImage(image);\n\t\t\t\tt.swapGeometry(geometry);\n\t\t\t}, t.loadProgress, function (xhr) {\n\t\t\t\tif (!tryWithCrossOrigin) {\n\t\t\t\t\tt.loadImage(imageUrl, true);\n\t\t\t\t} else {\n\t\t\t\t\tt.loadFailure(xhr);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\timageSourceToCanvas: function imageSourceToCanvas(source, canvas, x, y) {\n\t\tvar width = x || source.width;\n\t\tvar height = y || source.height;\n\t\tvar canvasContext = canvas.getContext('2d');\n\t\tcanvasContext.imageSmoothingEnabled = true;\n\t\tif (__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].scaleImages) {\n\t\t\tvar shrank = this.calculateAspectRatioFit(width, height, 256, 256);\n\t\t\twidth = shrank.width;\n\t\t\theight = shrank.height;\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].scaleImages = false;\n\t\t}\n\t\tcanvas.width = 0;\n\t\tcanvas.height = 0;\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\tcanvasContext.drawImage(source, 0, 0, width, height);\n\t\treturn canvasContext;\n\t},\n\tcalculateAspectRatioFit: function calculateAspectRatioFit(srcWidth, srcHeight, maxWidth, maxHeight) {\n\t\tvar ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);\n\t\treturn { width: srcWidth * ratio, height: srcHeight * ratio };\n\t},\n\tmakeGeometryFromImage: function makeGeometryFromImage(image) {\n\t\tvar t = this;\n\t\tvar width = image.width;\n\t\tvar height = image.height;\n\t\tvar duplicateColorMap = {};\n\t\tvar colors = [];\n\t\tvar color = void 0;\n\t\tvar rgbString = void 0;\n\t\tvar offset = void 0;\n\t\tvar r = void 0,\n\t\t    g = void 0,\n\t\t    b = void 0,\n\t\t    a = void 0;\n\t\tvar numPixels = width * height;\n\t\tvar dataCanvas = document.createElement('canvas');\n\t\tvar context = t.imageSourceToCanvas(image, dataCanvas, width, height);\n\t\tvar data = context.getImageData(0, 0, width, height).data;\n\t\tvar vertexGeom = new __WEBPACK_IMPORTED_MODULE_1_three__[\"Geometry\"]();\n\t\tfor (var i = 0; i < numPixels; i++) {\n\t\t\toffset = i * 4;\n\t\t\tr = data[offset];\n\t\t\tg = data[offset + 1];\n\t\t\tb = data[offset + 2];\n\t\t\ta = data[offset + 3];\n\t\t\trgbString = 'rgba(' + r + ',' + g + ',' + b + ')';\n\t\t\tif (!duplicateColorMap[rgbString] && a > 192) {\n\t\t\t\tcolor = new __WEBPACK_IMPORTED_MODULE_1_three__[\"Color\"](rgbString);\n\t\t\t\tcolors.push(color);\n\t\t\t}\n\t\t\tduplicateColorMap[rgbString] = true;\n\t\t}\n\t\tvertexGeom.colors = colors;\n\t\tvertexGeom.colorsNeedUpdate = true;\n\t\tvertexGeom.dataCanvas = dataCanvas;\n\t\treturn vertexGeom;\n\t},\n\tswapGeometry: function swapGeometry(vertexGeom) {\n\t\tvar t = this;\n\t\tt.vertexGeom = vertexGeom;\n\t\tt.imageSourceToCanvas(t.vertexGeom.dataCanvas, t.dataCanvas);\n\t\tif (t.vertexGeom.lastMapping !== t.mapMethodName) {\n\t\t\tt.mapColorsToVerts();\n\t\t}\n\t\tt.particleSystem.geometry = t.vertexGeom = vertexGeom;\n\t\tt.callback(t);\n\t},\n\n\tloadProgress: function loadProgress(xhr) {\n\t\tconsole.log(xhr.loaded / xhr.total * 100 + '% loaded');\n\t},\n\tloadFailure: function loadFailure(xhr) {\n\t\tconsole.log('An error happened', xhr);\n\t\talert('Sorry, was not able to load that image - still working out all the bugs. Try an image from another source?');\n\t},\n\tmapColorsToVerts: function mapColorsToVerts(mapMethodName) {\n\t\tvar t = this;\n\t\tt.mapMethodName = mapMethodName || t.mapMethodName;\n\t\tt.vertexGeom.vertices = t.vertexGeom.colors.map(t.mapNormalizedRGBTo[t.mapMethodName]);\n\t\tt.vertexGeom.verticesNeedUpdate = true;\n\t\tt.vertexGeom.lastMapping = mapMethodName;\n\t},\n\tmapNormalizedRGBTo: {\n\t\trgbCube: function rgbCube(color) {\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](color.r - 0.5, color.g - 0.5, color.b - 0.5);\n\t\t},\n\t\thslCylinder: function hslCylinder(color) {\n\t\t\tvar hsl = color.getHSL();\n\t\t\tvar angle = -hsl.h * Math.PI * 2;\n\t\t\tvar radius = hsl.s * 0.5;\n\t\t\tvar x = Math.cos(angle) * radius;\n\t\t\tvar y = hsl.l - 0.5;\n\t\t\tvar z = Math.sin(angle) * radius;\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](x, y, z);\n\t\t},\n\t\thsvCylinder: function hsvCylinder(color) {\n\t\t\tvar hsv = hslToHsv(color.getHSL());\n\t\t\tvar angle = -hsv.h * Math.PI * 2;\n\t\t\tvar radius = hsv.s * 0.5;\n\t\t\tvar x = Math.cos(angle) * radius;\n\t\t\tvar y = hsv.v - 0.5;\n\t\t\tvar z = Math.sin(angle) * radius;\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](x, y, z);\n\t\t},\n\t\thslCones: function hslCones(color) {\n\t\t\tvar hsl = color.getHSL();\n\t\t\tvar angle = -hsl.h * Math.PI * 2;\n\t\t\tvar radius = (1 - Math.abs(hsl.l - 0.5) * 2) * hsl.s * 0.5;\n\t\t\tvar x = Math.cos(angle) * radius;\n\t\t\tvar y = hsl.l - 0.5;\n\t\t\tvar z = Math.sin(angle) * radius;\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](x, y, z);\n\t\t},\n\t\thsvCone: function hsvCone(color) {\n\t\t\tvar hsv = hslToHsv(color.getHSL());\n\t\t\tvar angle = -hsv.h * Math.PI * 2;\n\t\t\tvar radius = hsv.v * hsv.s * 0.5;\n\t\t\tvar x = Math.cos(angle) * radius;\n\t\t\tvar y = hsv.v - 0.5;\n\t\t\tvar z = Math.sin(angle) * radius;\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](x, y, z);\n\t\t},\n\t\thslSphere: function hslSphere(color) {\n\t\t\tvar hsl = color.getHSL();\n\t\t\tvar angle = -hsl.h * Math.PI * 2;\n\t\t\tvar lon = hsl.l * Math.PI;\n\t\t\tvar radius = Math.sin(lon) * hsl.s * 0.5;\n\t\t\tvar x = Math.cos(angle) * radius;\n\t\t\tvar y = Math.cos(lon) * -0.5;\n\t\t\tvar z = Math.sin(angle) * radius;\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](x, y, z);\n\t\t},\n\t\thsvSphere: function hsvSphere(color) {\n\t\t\tvar hsv = hslToHsv(color.getHSL());\n\t\t\tvar angle = -hsv.h * Math.PI * 2;\n\t\t\tvar lon = hsv.v * Math.PI;\n\t\t\tvar radius = Math.sin(lon) * hsv.s * 0.5;\n\t\t\tvar x = Math.cos(angle) * radius;\n\t\t\tvar y = Math.cos(lon) * -0.5;\n\t\t\tvar z = Math.sin(angle) * radius;\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](x, y, z);\n\t\t},\n\t\thslCube: function hslCube(color) {\n\t\t\tvar hsl = color.getHSL();\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](hsl.h - 0.5, hsl.s - 0.5, hsl.l - 0.5);\n\t\t},\n\t\thsvCube: function hsvCube(color) {\n\t\t\tvar hsv = hslToHsv(color.getHSL());\n\t\t\treturn new __WEBPACK_IMPORTED_MODULE_1_three__[\"Vector3\"](hsv.h - 0.5, hsv.s - 0.5, hsv.v - 0.5);\n\t\t}\n\t}\n};\n\nvar hslToHsv = function hslToHsv(hsl) {\n\tvar h = hsl.h;\n\tvar s = hsl.s;\n\tvar l = hsl.l;\n\ts *= l < .5 ? l : 1 - l;\n\treturn {\n\t\th: h,\n\t\ts: 2 * s / (l + s),\n\t\tv: l + s\n\t};\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vertifier);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyY1xcdmVydGlmaWVyLmpzIl0sIm5hbWVzIjpbInN0YXRlIiwiVEhSRUUiLCJWZXJ0aWZpZXIiLCJhcmdzIiwidCIsImltYWdlVXJsIiwiY29uc29sZSIsImJyZWFrIiwiY2FsbGJhY2siLCJkYXRhQ2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibWFwTWV0aG9kTmFtZSIsImxvYWRlciIsIlRleHR1cmVMb2FkZXIiLCJ2ZXJ0ZXhHZW9tIiwiR2VvbWV0cnkiLCJ2ZXJ0ZXhNYXRlcmlhbCIsIlBvaW50c01hdGVyaWFsIiwic2l6ZSIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJzaXplQXR0ZW51YXRpb24iLCJ2ZXJ0ZXhDb2xvcnMiLCJWZXJ0ZXhDb2xvcnMiLCJwYXJ0aWNsZVN5c3RlbSIsIlBvaW50cyIsImxvYWRJbWFnZSIsImxvYWRlZEltYWdlTWFwIiwibG9hZGVkR2VvbU1hcCIsInByb3RvdHlwZSIsImNyb3NzT3JpZ2luUHJveHkiLCJ0cnlXaXRoQ3Jvc3NPcmlnaW4iLCJpbWFnZUtleSIsIm9yaWdpbiIsImltYWdlIiwiZ2VvbWV0cnkiLCJsb2ciLCJzd2FwR2VvbWV0cnkiLCJtYWtlR2VvbWV0cnlGcm9tSW1hZ2UiLCJsb2FkIiwidGV4dHVyZSIsImxvYWRQcm9ncmVzcyIsInhociIsImxvYWRGYWlsdXJlIiwiaW1hZ2VTb3VyY2VUb0NhbnZhcyIsInNvdXJjZSIsImNhbnZhcyIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJjYW52YXNDb250ZXh0IiwiZ2V0Q29udGV4dCIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsInNjYWxlSW1hZ2VzIiwic2hyYW5rIiwiY2FsY3VsYXRlQXNwZWN0UmF0aW9GaXQiLCJkcmF3SW1hZ2UiLCJzcmNXaWR0aCIsInNyY0hlaWdodCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwicmF0aW8iLCJNYXRoIiwibWluIiwiZHVwbGljYXRlQ29sb3JNYXAiLCJjb2xvcnMiLCJjb2xvciIsInJnYlN0cmluZyIsIm9mZnNldCIsInIiLCJnIiwiYiIsImEiLCJudW1QaXhlbHMiLCJjb250ZXh0IiwiZGF0YSIsImdldEltYWdlRGF0YSIsImkiLCJDb2xvciIsInB1c2giLCJjb2xvcnNOZWVkVXBkYXRlIiwibGFzdE1hcHBpbmciLCJtYXBDb2xvcnNUb1ZlcnRzIiwibG9hZGVkIiwidG90YWwiLCJhbGVydCIsInZlcnRpY2VzIiwibWFwIiwibWFwTm9ybWFsaXplZFJHQlRvIiwidmVydGljZXNOZWVkVXBkYXRlIiwicmdiQ3ViZSIsIlZlY3RvcjMiLCJoc2xDeWxpbmRlciIsImhzbCIsImdldEhTTCIsImFuZ2xlIiwiaCIsIlBJIiwicmFkaXVzIiwicyIsImNvcyIsImwiLCJ6Iiwic2luIiwiaHN2Q3lsaW5kZXIiLCJoc3YiLCJoc2xUb0hzdiIsInYiLCJoc2xDb25lcyIsImFicyIsImhzdkNvbmUiLCJoc2xTcGhlcmUiLCJsb24iLCJoc3ZTcGhlcmUiLCJoc2xDdWJlIiwiaHN2Q3ViZSJdLCJtYXBwaW5ncyI6IkFBQUEsT0FBT0EsS0FBUCxNQUFrQixTQUFsQjtBQUNBLE9BQU8sS0FBS0MsS0FBWixNQUF1QixPQUF2Qjs7QUFFQSxJQUFJQyxZQUFZLFNBQVpBLFNBQVksQ0FBVUMsSUFBVixFQUFnQjtBQUMvQixLQUFJQyxJQUFJLElBQVI7QUFDQUEsR0FBRUMsUUFBRixHQUFhRixLQUFLRSxRQUFMLElBQWlCQyxRQUFRQyxLQUFSLENBQWMsbUJBQWQsQ0FBOUI7QUFDQUgsR0FBRUksUUFBRixHQUFhTCxLQUFLSyxRQUFMLElBQWlCRixRQUFRQyxLQUFSLENBQWMsa0JBQWQsQ0FBOUI7QUFDQUgsR0FBRUssVUFBRixHQUFlTixLQUFLTSxVQUFMLElBQW1CQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQWxDO0FBQ0FQLEdBQUVRLGFBQUYsR0FBa0JULEtBQUtTLGFBQUwsSUFBc0IsU0FBeEM7O0FBRUFSLEdBQUVTLE1BQUYsR0FBVyxJQUFJWixNQUFNYSxhQUFWLEVBQVg7QUFDQVYsR0FBRVcsVUFB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QUFULElBQWtCRyxNQUExQjtBQUNBLFVBQU8sSUFBSW5HLE1BQU00RixPQUFWLENBQWtCN0MsQ0FBbEIsRUFBcUJDLENBQXJCLEVBQXdCdUQsQ0FBeEIsQ0FBUDtBQUNBLEdBL0RrQjtBQWdFbkJZLFdBQVMsaUJBQVVoRCxLQUFWLEVBQWlCO0FBQ3pCLE9BQUkyQixNQUFNM0IsTUFBTTRCLE1BQU4sRUFBVjtBQUNBLFVBQU8sSUFBSS9GLE1BQU00RixPQUFWLENBQ05FLElBQUlHLENBQUosR0FBUSxHQURGLEVBRU5ILElBQUlNLENBQUosR0FBUSxHQUZGLEVBR05OLElBQUlRLENBQUosR0FBUSxHQUhGLENBQVA7QUFLQSxHQXZFa0I7QUF3RW5CYyxXQUFTLGlCQUFVakQsS0FBVixFQUFpQjtBQUN6QixPQUFJdUMsTUFBTUMsU0FBU3hDLE1BQU00QixNQUFOLEVBQVQsQ0FBVjtBQUNBLFVBQU8sSUFBSS9GLE1BQU00RixPQUFWLENBQ05jLElBQUlULENBQUosR0FBUSxHQURGLEVBRU5TLElBQUlOLENBQUosR0FBUSxHQUZGLEVBR05NLElBQUlFLENBQUosR0FBUSxHQUhGLENBQVA7QUFLQTtBQS9Fa0I7QUFqSEMsQ0FBdEI7O0FBb01BLElBQUlELFdBQVcsU0FBWEEsUUFBVyxDQUFTYixHQUFULEVBQWM7QUFDNUIsS0FBSUcsSUFBSUgsSUFBSUcsQ0FBWjtBQUNBLEtBQUlHLElBQUlOLElBQUlNLENBQVo7QUFDQSxLQUFJRSxJQUFJUixJQUFJUSxDQUFaO0FBQ0FGLE1BQUtFLElBQUksRUFBSixHQUFTQSxDQUFULEdBQWEsSUFBSUEsQ0FBdEI7QUFDQSxRQUFPO0FBQ05MLEtBQUdBLENBREc7QUFFTkcsS0FBRyxJQUFJQSxDQUFKLElBQVNFLElBQUlGLENBQWIsQ0FGRztBQUdOUSxLQUFHTixJQUFJRjtBQUhELEVBQVA7QUFLQSxDQVZEOztBQVlBLGVBQWVuRyxTQUFmIiwiZmlsZSI6InZlcnRpZmllci5qcyIsInNvdXJjZVJvb3QiOiJHOi9kZXYvcmFpbmJvd3NwYWNlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0YXRlIGZyb20gJy4vc3RhdGUnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5sZXQgVmVydGlmaWVyID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0bGV0IHQgPSB0aGlzO1xuXHR0LmltYWdlVXJsID0gYXJncy5pbWFnZVVybCB8fCBjb25zb2xlLmJyZWFrKCdNSVNTSU5HIElNQUdFIFVSTCcpO1xuXHR0LmNhbGxiYWNrID0gYXJncy5jYWxsYmFjayB8fCBjb25zb2xlLmJyZWFrKCdNSVNTSU5HIENBTExCQUNLJyk7XG5cdHQuZGF0YUNhbnZhcyA9IGFyZ3MuZGF0YUNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0dC5tYXBNZXRob2ROYW1lID0gYXJncy5tYXBNZXRob2ROYW1lIHx8ICdyZ2JDdWJlJztcblxuXHR0LmxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XG5cdHQudmVydGV4R2VvbSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHR0LnZlcnRleE1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtcblx0XHRzaXplOiA1ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG5cdFx0c2l6ZUF0dGVudWF0aW9uOiBmYWxzZSxcblx0XHR2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9yc1xuXHR9KTtcblx0dC5wYXJ0aWNsZVN5c3RlbSA9IG5ldyBUSFJFRS5Qb2ludHMoXG5cdFx0dC52ZXJ0ZXhHZW9tLFxuXHRcdHQudmVydGV4TWF0ZXJpYWxcblx0KTtcblx0dC5sb2FkSW1hZ2UoKTtcbn07XG5cblZlcnRpZmllci5sb2FkZWRJbWFnZU1hcCA9IHt9O1xuVmVydGlmaWVyLmxvYWRlZEdlb21NYXAgPSB7fTtcblxuVmVydGlmaWVyLnByb3RvdHlwZSA9IHtcblx0Y3Jvc3NPcmlnaW5Qcm94eTogJ2h0dHA6Ly9jcm9zc29yaWdpbi5tZS8nLFxuXHRsb2FkSW1hZ2U6IGZ1bmN0aW9uKGltYWdlVXJsLCB0cnlXaXRoQ3Jvc3NPcmlnaW4pe1xuXHRcdGxldCB0ID0gdGhpcztcblx0XHRsZXQgaW1hZ2VLZXkgPSB0LmltYWdlVXJsID0gaW1hZ2VVcmwgfHwgdC5pbWFnZVVybDsgLy9UT0RPOiBicmFpbiBiZXR0ZXIgbGF0ZXIuIGZvcmNlIGxleGljYWwgY2FwdHVyaW5nIG5vdy5cblx0XHRsZXQgb3JpZ2luID0gdHJ5V2l0aENyb3NzT3JpZ2luID8gdC5jcm9zc09yaWdpblByb3h5IDogJyc7XG5cdFx0bGV0IGltYWdlID0gVmVydGlmaWVyLmxvYWRlZEltYWdlTWFwW2ltYWdlS2V5XTtcblx0XHRsZXQgZ2VvbWV0cnkgPSBWZXJ0aWZpZXIubG9hZGVkR2VvbU1hcFtpbWFnZUtleV07XG5cdFx0aWYoaW1hZ2UgJiYgZ2VvbWV0cnkpe1xuXHRcdFx0Y29uc29sZS5sb2coJ1ZlcnRpZmllci5sb2FkSW1hZ2U6IHVzaW5nIGFscmVhZHkgbG9hZGVkICcgKyBpbWFnZUtleSk7XG5cdFx0XHR0LnN3YXBHZW9tZXRyeShnZW9tZXRyeSk7XG5cdFx0fSBlbHNlIGlmIChpbWFnZSAmJiAhZ2VvbWV0cnkpIHtcblx0XHRcdGdlb21ldHJ5ID0gVmVydGlmaWVyLmxvYWRlZEdlb21NYXBbaW1hZ2VLZXldID0gdC5tYWtlR2VvbWV0cnlGcm9tSW1hZ2UoaW1hZ2UpO1xuXHRcdFx0dC5zd2FwR2VvbWV0cnkoZ2VvbWV0cnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0LmxvYWRlci5sb2FkKFxuXHRcdFx0XHRvcmlnaW4gKyBpbWFnZUtleSxcblx0XHRcdFx0ZnVuY3Rpb24gKHRleHR1cmUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnVmVydGlmaWVyLmxvYWRJbWFnZTogZmluaXNoZWQgbG9hZGluZyAnICsgaW1hZ2VLZXkpO1xuXHRcdFx0XHRcdGltYWdlID0gVmVydGlmaWVyLmxvYWRlZEltYWdlTWFwW2ltYWdlS2V5XSA9IHRleHR1cmUuaW1hZ2U7XG5cdFx0XHRcdFx0Z2VvbWV0cnkgPSBWZXJ0aWZpZXIubG9hZGVkR2VvbU1hcFtpbWFnZUtleV0gPSB0Lm1ha2VHZW9tZXRyeUZyb21JbWFnZShpbWFnZSk7XG5cdFx0XHRcdFx0dC5zd2FwR2VvbWV0cnkoZ2VvbWV0cnkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0LmxvYWRQcm9ncmVzcyxcblx0XHRcdFx0ZnVuY3Rpb24oeGhyKXtcblx0XHRcdFx0XHRpZighdHJ5V2l0aENyb3NzT3JpZ2luKXtcblx0XHRcdFx0XHRcdHQubG9hZEltYWdlKGltYWdlVXJsLCB0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dC5sb2FkRmFpbHVyZSh4aHIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cdGltYWdlU291cmNlVG9DYW52YXM6IGZ1bmN0aW9uIChzb3VyY2UsIGNhbnZhcywgeCwgeSl7XG5cdFx0bGV0IHdpZHRoID0geCB8fCBzb3VyY2Uud2lkdGg7XG5cdFx0bGV0IGhlaWdodCA9IHkgfHwgc291cmNlLmhlaWdodDtcblx0XHRsZXQgY2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGNhbnZhc0NvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcblx0XHRpZihzdGF0ZS5zY2FsZUltYWdlcyl7XG5cdFx0XHRsZXQgc2hyYW5rID0gdGhpcy5jYWxjdWxhdGVBc3BlY3RSYXRpb0ZpdCh3aWR0aCwgaGVpZ2h0LCAyNTYsIDI1Nik7XG5cdFx0XHR3aWR0aCA9IHNocmFuay53aWR0aDtcblx0XHRcdGhlaWdodCA9IHNocmFuay5oZWlnaHQ7XG5cdFx0XHRzdGF0ZS5zY2FsZUltYWdlcyA9IGZhbHNlO1xuXHRcdH1cblx0XHRjYW52YXMud2lkdGggPSAwO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSAwO1xuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0Y2FudmFzQ29udGV4dC5kcmF3SW1hZ2Uoc291cmNlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRyZXR1cm4gY2FudmFzQ29udGV4dDtcblx0fSxcblx0Y2FsY3VsYXRlQXNwZWN0UmF0aW9GaXQ6IGZ1bmN0aW9uKHNyY1dpZHRoLCBzcmNIZWlnaHQsIG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcblx0XHRsZXQgcmF0aW8gPSBNYXRoLm1pbihtYXhXaWR0aCAvIHNyY1dpZHRoLCBtYXhIZWlnaHQgLyBzcmNIZWlnaHQpO1xuXHRcdHJldHVybiB7IHdpZHRoOiBzcmNXaWR0aCpyYXRpbywgaGVpZ2h0OiBzcmNIZWlnaHQqcmF0aW8gfTtcblx0fSxcblx0bWFrZUdlb21ldHJ5RnJvbUltYWdlOiBmdW5jdGlvbiAoaW1hZ2UpIHtcblx0XHRsZXQgdCA9IHRoaXM7XG5cdFx0bGV0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0bGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcblx0XHRsZXQgZHVwbGljYXRlQ29sb3JNYXAgPSB7fTtcblx0XHRsZXQgY29sb3JzID0gW107XG5cdFx0bGV0IGNvbG9yO1xuXHRcdGxldCByZ2JTdHJpbmc7XG5cdFx0bGV0IG9mZnNldDtcblx0XHRsZXQgciwgZywgYiwgYTtcblx0XHRsZXQgbnVtUGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7XG5cdFx0bGV0IGRhdGFDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRsZXQgY29udGV4dCA9IHQuaW1hZ2VTb3VyY2VUb0NhbnZhcyhpbWFnZSwgZGF0YUNhbnZhcywgd2lkdGgsIGhlaWdodCk7XG5cdFx0bGV0IGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuXHRcdGxldCB2ZXJ0ZXhHZW9tID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1QaXhlbHM7IGkrKykge1xuXHRcdFx0b2Zmc2V0ID0gaSAqIDQ7XG5cdFx0XHRyID0gZGF0YVtvZmZzZXRdO1xuXHRcdFx0ZyA9IGRhdGFbb2Zmc2V0ICsgMV07XG5cdFx0XHRiID0gZGF0YVtvZmZzZXQgKyAyXTtcblx0XHRcdGEgPSBkYXRhW29mZnNldCArIDNdO1xuXHRcdFx0cmdiU3RyaW5nID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcpJztcblx0XHRcdGlmICghZHVwbGljYXRlQ29sb3JNYXBbcmdiU3RyaW5nXSAmJiBhID4gMTkyKSB7XG5cdFx0XHRcdGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKHJnYlN0cmluZyk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yKTtcblx0XHRcdH1cblx0XHRcdGR1cGxpY2F0ZUNvbG9yTWFwW3JnYlN0cmluZ10gPSB0cnVlO1xuXHRcdH1cblx0XHR2ZXJ0ZXhHZW9tLmNvbG9ycyA9IGNvbG9ycztcblx0XHR2ZXJ0ZXhHZW9tLmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHZlcnRleEdlb20uZGF0YUNhbnZhcyA9IGRhdGFDYW52YXM7XG5cdFx0cmV0dXJuIHZlcnRleEdlb207XG5cdH0sXG5cdHN3YXBHZW9tZXRyeSh2ZXJ0ZXhHZW9tKXtcblx0XHRsZXQgdCA9IHRoaXM7XG5cdFx0dC52ZXJ0ZXhHZW9tID0gdmVydGV4R2VvbTtcblx0XHR0LmltYWdlU291cmNlVG9DYW52YXModC52ZXJ0ZXhHZW9tLmRhdGFDYW52YXMsIHQuZGF0YUNhbnZhcyk7XG5cdFx0aWYodC52ZXJ0ZXhHZW9tLmxhc3RNYXBwaW5nICE9PSB0Lm1hcE1ldGhvZE5hbWUpe1xuXHRcdFx0dC5tYXBDb2xvcnNUb1ZlcnRzKCk7XG5cdFx0fVxuXHRcdHQucGFydGljbGVTeXN0ZW0uZ2VvbWV0cnkgPSB0LnZlcnRleEdlb20gPSB2ZXJ0ZXhHZW9tO1xuXHRcdHQuY2FsbGJhY2sodCk7XG5cdH0sXG5cdGxvYWRQcm9ncmVzczogZnVuY3Rpb24gKHhocikge1xuXHRcdGNvbnNvbGUubG9nKCh4aHIubG9hZGVkIC8geGhyLnRvdGFsICogMTAwKSArICclIGxvYWRlZCcpO1xuXHR9LFxuXHRsb2FkRmFpbHVyZTogZnVuY3Rpb24gKHhocikge1xuXHRcdGNvbnNvbGUubG9nKCdBbiBlcnJvciBoYXBwZW5lZCcsIHhocik7XG5cdFx0YWxlcnQoJ1NvcnJ5LCB3YXMgbm90IGFibGUgdG8gbG9hZCB0aGF0IGltYWdlIC0gc3RpbGwgd29ya2luZyBvdXQgYWxsIHRoZSBidWdzLiBUcnkgYW4gaW1hZ2UgZnJvbSBhbm90aGVyIHNvdXJjZT8nKTtcblx0fSxcblx0bWFwQ29sb3JzVG9WZXJ0czogZnVuY3Rpb24gKG1hcE1ldGhvZE5hbWUpIHtcblx0XHRsZXQgdCA9IHRoaXM7XG5cdFx0dC5tYXBNZXRob2ROYW1lID0gbWFwTWV0aG9kTmFtZSB8fCB0Lm1hcE1ldGhvZE5hbWU7XG5cdFx0dC52ZXJ0ZXhHZW9tLnZlcnRpY2VzID0gdC52ZXJ0ZXhHZW9tLmNvbG9ycy5tYXAodC5tYXBOb3JtYWxpemVkUkdCVG9bdC5tYXBNZXRob2ROYW1lXSk7XG5cdFx0dC52ZXJ0ZXhHZW9tLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dC52ZXJ0ZXhHZW9tLmxhc3RNYXBwaW5nID0gbWFwTWV0aG9kTmFtZTtcblx0fSxcblx0bWFwTm9ybWFsaXplZFJHQlRvOiB7XG5cdFx0cmdiQ3ViZTogZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdGNvbG9yLnIgLSAwLjUsXG5cdFx0XHRcdGNvbG9yLmcgLSAwLjUsXG5cdFx0XHRcdGNvbG9yLmIgLSAwLjVcblx0XHRcdCk7XG5cdFx0fSxcblx0XHRoc2xDeWxpbmRlcjogZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0XHRsZXQgaHNsID0gY29sb3IuZ2V0SFNMKCk7XG5cdFx0XHRsZXQgYW5nbGUgPSAtaHNsLmggKiBNYXRoLlBJICogMjtcblx0XHRcdGxldCByYWRpdXMgPSBoc2wucyAqIDAuNTtcblx0XHRcdGxldCB4ID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0bGV0IHkgPSBoc2wubCAtIDAuNTtcblx0XHRcdGxldCB6ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopO1xuXHRcdH0sXG5cdFx0aHN2Q3lsaW5kZXI6IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdFx0bGV0IGhzdiA9IGhzbFRvSHN2KGNvbG9yLmdldEhTTCgpKTtcblx0XHRcdGxldCBhbmdsZSA9IC1oc3YuaCAqIE1hdGguUEkgKiAyO1xuXHRcdFx0bGV0IHJhZGl1cyA9IGhzdi5zICogMC41O1xuXHRcdFx0bGV0IHggPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXM7XG5cdFx0XHRsZXQgeSA9IGhzdi52IC0gMC41O1xuXHRcdFx0bGV0IHogPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXM7XG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoeCwgeSwgeik7XG5cdFx0fSxcblx0XHRoc2xDb25lczogZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0XHRsZXQgaHNsID0gY29sb3IuZ2V0SFNMKCk7XG5cdFx0XHRsZXQgYW5nbGUgPSAtaHNsLmggKiBNYXRoLlBJICogMjtcblx0XHRcdGxldCByYWRpdXMgPSAoMSAtIChNYXRoLmFicyhoc2wubCAtIDAuNSkgKiAyKSkgKiBoc2wucyAqIDAuNTtcblx0XHRcdGxldCB4ID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0bGV0IHkgPSBoc2wubCAtIDAuNTtcblx0XHRcdGxldCB6ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopO1xuXHRcdH0sXG5cdFx0aHN2Q29uZTogZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0XHRsZXQgaHN2ID0gaHNsVG9Ic3YoY29sb3IuZ2V0SFNMKCkpO1xuXHRcdFx0bGV0IGFuZ2xlID0gLWhzdi5oICogTWF0aC5QSSAqIDI7XG5cdFx0XHRsZXQgcmFkaXVzID0gaHN2LnYgKiBoc3YucyAqIDAuNTtcblx0XHRcdGxldCB4ID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0bGV0IHkgPSBoc3YudiAtIDAuNTtcblx0XHRcdGxldCB6ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopO1xuXHRcdH0sXG5cdFx0aHNsU3BoZXJlOiBmdW5jdGlvbiAoY29sb3IpIHtcblx0XHRcdGxldCBoc2wgPSBjb2xvci5nZXRIU0woKTtcblx0XHRcdGxldCBhbmdsZSA9IC1oc2wuaCAqIE1hdGguUEkgKiAyO1xuXHRcdFx0bGV0IGxvbiA9IGhzbC5sICogTWF0aC5QSTtcblx0XHRcdGxldCByYWRpdXMgPSBNYXRoLnNpbihsb24pICogaHNsLnMgKiAwLjU7XG5cdFx0XHRsZXQgeCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cztcblx0XHRcdGxldCB5ID0gTWF0aC5jb3MobG9uKSAqIC0wLjU7XG5cdFx0XHRsZXQgeiA9IE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cztcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyh4LCB5LCB6KTtcblx0XHR9LFxuXHRcdGhzdlNwaGVyZTogZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0XHRsZXQgaHN2ID0gaHNsVG9Ic3YoY29sb3IuZ2V0SFNMKCkpO1xuXHRcdFx0bGV0IGFuZ2xlID0gLWhzdi5oICogTWF0aC5QSSAqIDI7XG5cdFx0XHRsZXQgbG9uID0gaHN2LnYgKiBNYXRoLlBJO1xuXHRcdFx0bGV0IHJhZGl1cyA9IE1hdGguc2luKGxvbikgKiBoc3YucyAqIDAuNTtcblx0XHRcdGxldCB4ID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0bGV0IHkgPSBNYXRoLmNvcyhsb24pICogLTAuNTtcblx0XHRcdGxldCB6ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopO1xuXHRcdH0sXG5cdFx0aHNsQ3ViZTogZnVuY3Rpb24gKGNvbG9yKSB7XG5cdFx0XHRsZXQgaHNsID0gY29sb3IuZ2V0SFNMKCk7XG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdGhzbC5oIC0gMC41LFxuXHRcdFx0XHRoc2wucyAtIDAuNSxcblx0XHRcdFx0aHNsLmwgLSAwLjVcblx0XHRcdCk7XG5cdFx0fSxcblx0XHRoc3ZDdWJlOiBmdW5jdGlvbiAoY29sb3IpIHtcblx0XHRcdGxldCBoc3YgPSBoc2xUb0hzdihjb2xvci5nZXRIU0woKSk7XG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdGhzdi5oIC0gMC41LFxuXHRcdFx0XHRoc3YucyAtIDAuNSxcblx0XHRcdFx0aHN2LnYgLSAwLjVcblx0XHRcdCk7XG5cdFx0fSxcblx0fSxcbn07XG5cbmxldCBoc2xUb0hzdiA9IGZ1bmN0aW9uKGhzbCkge1xuXHRsZXQgaCA9IGhzbC5oO1xuXHRsZXQgcyA9IGhzbC5zO1xuXHRsZXQgbCA9IGhzbC5sO1xuXHRzICo9IGwgPCAuNSA/IGwgOiAxIC0gbDtcblx0cmV0dXJuIHtcblx0XHRoOiBoLFxuXHRcdHM6IDIgKiBzIC8gKGwgKyBzKSxcblx0XHR2OiBsICsgc1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBWZXJ0aWZpZXI7XG4iXX0=\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.THREE = global.THREE || {})));\n}(this, (function (exports) { 'use strict';\n\n\t// Polyfills\n\n\tif ( Number.EPSILON === undefined ) {\n\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n\t}\n\n\t//\n\n\tif ( Math.sign === undefined ) {\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\t\tMath.sign = function ( x ) {\n\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t\t};\n\n\t}\n\n\tif ( Function.prototype.name === undefined ) {\n\n\t\t// Missing in IE9-11.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tif ( Object.assign === undefined ) {\n\n\t\t// Missing in IE.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t\t( function () {\n\n\t\t\tObject.assign = function ( target ) {\n\n\t\t\t\t'use strict';\n\n\t\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t\t}\n\n\t\t\t\tvar output = Object( target );\n\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t};\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\n\tfunction EventDispatcher() {}\n\n\tObject.assign( EventDispatcher.prototype, {\n\n\t\taddEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\t\tlisteners[ type ] = [];\n\n\t\t\t}\n\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\t\tlisteners[ type ].push( listener );\n\n\t\t\t}\n\n\t\t},\n\n\t\thasEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return false;\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispatchEvent: function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar array = [], i = 0;\n\t\t\t\tvar length = listenerArray.length;\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tvar REVISION = '82';\n\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\tvar CullFaceNone = 0;\n\tvar CullFaceBack = 1;\n\tvar CullFaceFront = 2;\n\tvar CullFaceFrontBack = 3;\n\tvar FrontFaceDirectionCW = 0;\n\tvar FrontFaceDirectionCCW = 1;\n\tvar BasicShadowMap = 0;\n\tvar PCFShadowMap = 1;\n\tvar PCFSoftShadowMap = 2;\n\tvar FrontSide = 0;\n\tvar BackSide = 1;\n\tvar DoubleSide = 2;\n\tvar FlatShading = 1;\n\tvar SmoothShading = 2;\n\tvar NoColors = 0;\n\tvar FaceColors = 1;\n\tvar VertexColors = 2;\n\tvar NoBlending = 0;\n\tvar NormalBlending = 1;\n\tvar AdditiveBlending = 2;\n\tvar SubtractiveBlending = 3;\n\tvar MultiplyBlending = 4;\n\tvar CustomBlending = 5;\n\tvar BlendingMode = {\n\t\tNoBlending: NoBlending,\n\t\tNormalBlending: NormalBlending,\n\t\tAdditiveBlending: AdditiveBlending,\n\t\tSubtractiveBlending: SubtractiveBlending,\n\t\tMultiplyBlending: MultiplyBlending,\n\t\tCustomBlending: CustomBlending\n\t};\n\tvar AddEquation = 100;\n\tvar SubtractEquation = 101;\n\tvar ReverseSubtractEquation = 102;\n\tvar MinEquation = 103;\n\tvar MaxEquation = 104;\n\tvar ZeroFactor = 200;\n\tvar OneFactor = 201;\n\tvar SrcColorFactor = 202;\n\tvar OneMinusSrcColorFactor = 203;\n\tvar SrcAlphaFactor = 204;\n\tvar OneMinusSrcAlphaFactor = 205;\n\tvar DstAlphaFactor = 206;\n\tvar OneMinusDstAlphaFactor = 207;\n\tvar DstColorFactor = 208;\n\tvar OneMinusDstColorFactor = 209;\n\tvar SrcAlphaSaturateFactor = 210;\n\tvar NeverDepth = 0;\n\tvar AlwaysDepth = 1;\n\tvar LessDepth = 2;\n\tvar LessEqualDepth = 3;\n\tvar EqualDepth = 4;\n\tvar GreaterEqualDepth = 5;\n\tvar GreaterDepth = 6;\n\tvar NotEqualDepth = 7;\n\tvar MultiplyOperation = 0;\n\tvar MixOperation = 1;\n\tvar AddOperation = 2;\n\tvar NoToneMapping = 0;\n\tvar LinearToneMapping = 1;\n\tvar ReinhardToneMapping = 2;\n\tvar Uncharted2ToneMapping = 3;\n\tvar CineonToneMapping = 4;\n\tvar UVMapping = 300;\n\tvar CubeReflectionMapping = 301;\n\tvar CubeRefractionMapping = 302;\n\tvar EquirectangularReflectionMapping = 303;\n\tvar EquirectangularRefractionMapping = 304;\n\tvar SphericalReflectionMapping = 305;\n\tvar CubeUVReflectionMapping = 306;\n\tvar CubeUVRefractionMapping = 307;\n\tvar TextureMapping = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tvar RepeatWrapping = 1000;\n\tvar ClampToEdgeWrapping = 1001;\n\tvar MirroredRepeatWrapping = 1002;\n\tvar TextureWrapping = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tvar NearestFilter = 1003;\n\tvar NearestMipMapNearestFilter = 1004;\n\tvar NearestMipMapLinearFilter = 1005;\n\tvar LinearFilter = 1006;\n\tvar LinearMipMapNearestFilter = 1007;\n\tvar LinearMipMapLinearFilter = 1008;\n\tvar TextureFilter = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t};\n\tvar UnsignedByteType = 1009;\n\tvar ByteType = 1010;\n\tvar ShortType = 1011;\n\tvar UnsignedShortType = 1012;\n\tvar IntType = 1013;\n\tvar UnsignedIntType = 1014;\n\tvar FloatType = 1015;\n\tvar HalfFloatType = 1016;\n\tvar UnsignedShort4444Type = 1017;\n\tvar UnsignedShort5551Type = 1018;\n\tvar UnsignedShort565Type = 1019;\n\tvar UnsignedInt248Type = 1020;\n\tvar AlphaFormat = 1021;\n\tvar RGBFormat = 1022;\n\tvar RGBAFormat = 1023;\n\tvar LuminanceFormat = 1024;\n\tvar LuminanceAlphaFormat = 1025;\n\tvar RGBEFormat = RGBAFormat;\n\tvar DepthFormat = 1026;\n\tvar DepthStencilFormat = 1027;\n\tvar RGB_S3TC_DXT1_Format = 2001;\n\tvar RGBA_S3TC_DXT1_Format = 2002;\n\tvar RGBA_S3TC_DXT3_Format = 2003;\n\tvar RGBA_S3TC_DXT5_Format = 2004;\n\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\tvar RGB_ETC1_Format = 2151;\n\tvar LoopOnce = 2200;\n\tvar LoopRepeat = 2201;\n\tvar LoopPingPong = 2202;\n\tvar InterpolateDiscrete = 2300;\n\tvar InterpolateLinear = 2301;\n\tvar InterpolateSmooth = 2302;\n\tvar ZeroCurvatureEnding = 2400;\n\tvar ZeroSlopeEnding = 2401;\n\tvar WrapAroundEnding = 2402;\n\tvar TrianglesDrawMode = 0;\n\tvar TriangleStripDrawMode = 1;\n\tvar TriangleFanDrawMode = 2;\n\tvar LinearEncoding = 3000;\n\tvar sRGBEncoding = 3001;\n\tvar GammaEncoding = 3007;\n\tvar RGBEEncoding = 3002;\n\tvar LogLuvEncoding = 3003;\n\tvar RGBM7Encoding = 3004;\n\tvar RGBM16Encoding = 3005;\n\tvar RGBDEncoding = 3006;\n\tvar BasicDepthPacking = 3200;\n\tvar RGBADepthPacking = 3201;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar _Math = {\n\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\n\t\tgenerateUUID: function () {\n\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\tvar uuid = new Array( 36 );\n\t\t\tvar rnd = 0, r;\n\n\t\t\treturn function generateUUID() {\n\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn uuid.join( '' );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclamp: function ( value, min, max ) {\n\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t\t},\n\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\teuclideanModulo: function ( n, m ) {\n\n\t\t\treturn ( ( n % m ) + m ) % m;\n\n\t\t},\n\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t\t},\n\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\tlerp: function ( x, y, t ) {\n\n\t\t\treturn ( 1 - t ) * x + t * y;\n\n\t\t},\n\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\tsmoothstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t},\n\n\t\tsmootherstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t\t},\n\n\t\trandom16: function () {\n\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\n\t\t},\n\n\t\t// Random integer from <low, high> interval\n\n\t\trandInt: function ( low, high ) {\n\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t\t},\n\n\t\t// Random float from <low, high> interval\n\n\t\trandFloat: function ( low, high ) {\n\n\t\t\treturn low + Math.random() * ( high - low );\n\n\t\t},\n\n\t\t// Random float from <-range/2, range/2> interval\n\n\t\trandFloatSpread: function ( range ) {\n\n\t\t\treturn range * ( 0.5 - Math.random() );\n\n\t\t},\n\n\t\tdegToRad: function ( degrees ) {\n\n\t\t\treturn degrees * _Math.DEG2RAD;\n\n\t\t},\n\n\t\tradToDeg: function ( radians ) {\n\n\t\t\treturn radians * _Math.RAD2DEG;\n\n\t\t},\n\n\t\tisPowerOfTwo: function ( value ) {\n\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t\t},\n\n\t\tnearestPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tnextPowerOfTwo: function ( value ) {\n\n\t\t\tvalue --;\n\t\t\tvalue |= value >> 1;\n\t\t\tvalue |= value >> 2;\n\t\t\tvalue |= value >> 4;\n\t\t\tvalue |= value >> 8;\n\t\t\tvalue |= value >> 16;\n\t\t\tvalue ++;\n\n\t\t\treturn value;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tfunction Vector2( x, y ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\n\t}\n\n\tVector2.prototype = {\n\n\t\tconstructor: Vector2,\n\n\t\tisVector2: true,\n\n\t\tget width() {\n\n\t\t\treturn this.x;\n\n\t\t},\n\n\t\tset width( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t},\n\n\t\tget height() {\n\n\t\t\treturn this.y;\n\n\t\t},\n\n\t\tset height( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t},\n\n\t\t//\n\n\t\tset: function ( x, y ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\tmax = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t\t},\n\n\t\tlengthManhattan: function() {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tangle: function () {\n\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\t\treturn angle;\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateAround: function ( center, angle ) {\n\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\n\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.sourceFile = '';\n\n\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\n\tTexture.prototype = {\n\n\t\tconstructor: Texture,\n\n\t\tisTexture: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\t\tthis.mapping = source.mapping;\n\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\n\t\t\tthis.anisotropy = source.anisotropy;\n\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tfunction getDataURL( image ) {\n\n\t\t\t\tvar canvas;\n\n\t\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\t\tcanvas = image;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\n\t\t\t\tmapping: this.mapping,\n\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\n\t\t\t\tflipY: this.flipY\n\t\t\t};\n\n\t\t\tif ( this.image !== undefined ) {\n\n\t\t\t\t// TODO: Move to THREE.Image\n\n\t\t\t\tvar image = this.image;\n\n\t\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t\t}\n\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\n\t\t\t}\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t},\n\n\t\ttransformUv: function ( uv ) {\n\n\t\t\tif ( this.mapping !== UVMapping )  return;\n\n\t\t\tuv.multiply( this.repeat );\n\t\t\tuv.add( this.offset );\n\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.flipY ) {\n\n\t\t\t\tuv.y = 1 - uv.y;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\n\tvar count = 0;\n\tfunction TextureIdCount() { return count++; }\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector4( x, y, z, w ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tVector4.prototype = {\n\n\t\tconstructor: Vector4,\n\n\t\tisVector4: true,\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( w ) {\n\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t\t// q is assumed to be normalized\n\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\t\tif ( s < 0.0001 ) {\n\n\t\t\t\t this.x = 1;\n\t\t\t\t this.y = 0;\n\t\t\t\t this.z = 0;\n\n\t\t\t} else {\n\n\t\t\t\t this.x = q.x / s;\n\t\t\t\t this.y = q.y / s;\n\t\t\t\t this.z = q.z / s;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\t\tte = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t\t}\n\n\t\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\t\tangle = Math.PI;\n\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.set( x, y, z, angle );\n\n\t\t\t\treturn this; // return 180 deg rotation\n\n\t\t\t}\n\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\tmax = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tfunction WebGLRenderTarget( width, height, options ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\toptions = options || {};\n\n\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\n\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\n\t\tisWebGLRenderTarget: true,\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\n\t\t\tthis.viewport.copy( source.viewport );\n\n\t\t\tthis.texture = source.texture.clone();\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\n\tfunction WebGLRenderTargetCube( width, height, options ) {\n\n\t\tWebGLRenderTarget.call( this, width, height, options );\n\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\n\t}\n\n\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\n\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Quaternion( x, y, z, w ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tQuaternion.prototype = {\n\n\t\tconstructor: Quaternion,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget w () {\n\n\t\t\treturn this._w;\n\n\t\t},\n\n\t\tset w ( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t\t},\n\n\t\tcopy: function ( quaternion ) {\n\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromEuler: function ( euler, update ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\t\tvar order = euler.order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t}\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\n\t\t\tif ( trace > 0 ) {\n\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t\t} else if ( m22 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t\t} else {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromUnitVectors: function () {\n\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\tvar v1, r;\n\n\t\t\tvar EPS = 0.000001;\n\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\t\tif ( r < EPS ) {\n\n\t\t\t\t\tr = 0;\n\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t\t}\n\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\n\t\t\t\treturn this.normalize();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tinverse: function () {\n\n\t\t\treturn this.conjugate().normalize();\n\n\t\t},\n\n\t\tconjugate: function () {\n\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tvar l = this.length();\n\n\t\t\tif ( l === 0 ) {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\n\t\t\t} else {\n\n\t\t\t\tl = 1 / l;\n\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( q, p ) {\n\n\t\t\tif ( p !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions( this, q );\n\n\t\t},\n\n\t\tpremultiply: function ( q ) {\n\n\t\t\treturn this.multiplyQuaternions( q, this );\n\n\t\t},\n\n\t\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tslerp: function ( qb, t ) {\n\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copy( qb );\n\n\t\t\t}\n\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( quaternion ) {\n\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\tObject.assign( Quaternion, {\n\n\t\tslerp: function( qa, qb, qm, t ) {\n\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t\t},\n\n\t\tslerpFlat: function(\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\t\tvar s = 1 - t,\n\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t\t}\n\n\t\t\t\tvar tDir = t * dir;\n\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector3( x, y, z ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\n\t}\n\n\tVector3.prototype = {\n\n\t\tconstructor: Vector3,\n\n\t\tisVector3: true,\n\n\t\tset: function ( x, y, z ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyEuler: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyEuler( euler ) {\n\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyAxisAngle: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix3: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyProjection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 projection matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyQuaternion: function ( q ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t\t// calculate quat * vector\n\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t\t// calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function project( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tunproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function unproject( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttransformDirection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\t\treturn this.normalize();\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\tmax = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tcross: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\n\t\t\t}\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\tthis.z = x * v.y - y * v.x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossVectors: function ( a, b ) {\n\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tprojectOnVector: function ( vector ) {\n\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t\t},\n\n\t\tprojectOnPlane: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\t\treturn this.sub( v1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\treflect: function () {\n\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\n\t\t\tvar v1;\n\n\t\t\treturn function reflect( normal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tangleTo: function ( v ) {\n\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t\t},\n\n\t\tsetFromSpherical: function( s ) {\n\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixPosition: function ( m ) {\n\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t\t},\n\n\t\tsetFromMatrixScale: function ( m ) {\n\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\t\tif ( typeof m === 'number' ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\tvar temp = m;\n\t\t\t\tm = index;\n\t\t\t\tindex = temp;\n\n\t\t\t}\n\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Matrix4() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix4.prototype = {\n\n\t\tconstructor: Matrix4,\n\n\t\tisMatrix4: true,\n\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new Matrix4().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tthis.elements.set( m.elements );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyPosition: function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0,       0,       0,       1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractRotation: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function extractRotation( m ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeRotationFromEuler: function ( euler ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t\t}\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlookAt: function () {\n\n\t\t\tvar x, y, z;\n\n\t\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\t\tif ( x === undefined ) {\n\n\t\t\t\t\tx = new Vector3();\n\t\t\t\t\ty = new Vector3();\n\t\t\t\t\tz = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z = 1;\n\n\t\t\t\t}\n\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\ty.crossVectors( z, x );\n\n\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiply: function ( m, n ) {\n\n\t\t\tif ( n !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t},\n\n\t\tpremultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t},\n\n\t\tmultiplyMatrices: function ( a, b ) {\n\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyToArray: function ( a, b, r ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tthis.multiplyMatrices( a, b );\n\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\n\t\t\t);\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetPosition: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function getPosition() {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetPosition: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tscale: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetMaxScaleOnAxis: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t\t},\n\n\t\tmakeTranslation: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationX: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0,  0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s,  c, 0,\n\t\t\t\t0, 0,  0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationY: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationZ: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts,  c, 0, 0,\n\t\t\t\t0,  0, 1, 0,\n\t\t\t\t0,  0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\n\t\t\tthis.set(\n\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\t return this;\n\n\t\t},\n\n\t\tmakeScale: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompose: function ( position, quaternion, scale ) {\n\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdecompose: function () {\n\n\t\t\tvar vector, matrix;\n\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\tmatrix = new Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) {\n\n\t\t\t\t\tsx = - sx;\n\n\t\t\t\t}\n\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\n\t\t\t\t// scale the rotation part\n\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\tvar ymin = - ymax;\n\t\t\tvar xmin = ymin * aspect;\n\t\t\tvar xmax = ymax * aspect;\n\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t\t},\n\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( matrix ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tCubeTexture.prototype = Object.create( Texture.prototype );\n\tCubeTexture.prototype.constructor = CubeTexture;\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\t\tget: function () {\n\n\t\t\treturn this.image;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.image = value;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\n\tvar emptyTexture = new Texture();\n\tvar emptyCubeTexture = new CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tfunction UniformContainer() {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tvar arrayCacheF32 = [];\n\tvar arrayCacheI32 = [];\n\n\t// Flattening for arrays of vectors and matrices\n\n\tfunction flatten( array, nBlocks, blockSize ) {\n\n\t\tvar firstElem = array[ 0 ];\n\n\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t// unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tvar n = nBlocks * blockSize,\n\t\t\tr = arrayCacheF32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Float32Array( n );\n\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t}\n\n\t\tif ( nBlocks !== 0 ) {\n\n\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n\t// Texture unit allocation\n\n\tfunction allocTexUnits( renderer, n ) {\n\n\t\tvar r = arrayCacheI32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Int32Array( n );\n\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\treturn r;\n\n\t}\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t// Single scalar\n\n\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\n\t// Single float vector (from flat array or THREE.VectorN)\n\n\tfunction setValue2fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t}\n\n\tfunction setValue3fv( gl, v ) {\n\n\t\tif ( v.x !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\telse if ( v.r !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\telse\n\t\t\tgl.uniform3fv( this.addr, v );\n\n\t}\n\n\tfunction setValue4fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t}\n\n\t// Single matrix (from flat array or MatrixN)\n\n\tfunction setValue2fm( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue3fm( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue4fm( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t}\n\n\t// Single texture (2D / Cube)\n\n\tfunction setValueT1( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t}\n\n\tfunction setValueT6( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t}\n\n\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\n\t// Helper to pick the right setter for the singular case\n\n\tfunction getSingularSetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// Array of scalars\n\n\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\n\t// Array of vectors (flat or from THREE classes)\n\n\tfunction setValueV2a( gl, v ) {\n\n\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t}\n\n\tfunction setValueV3a( gl, v ) {\n\n\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t}\n\n\tfunction setValueV4a( gl, v ) {\n\n\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t}\n\n\t// Array of matrices (flat or from THREE clases)\n\n\tfunction setValueM2a( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t}\n\n\tfunction setValueM3a( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t}\n\n\tfunction setValueM4a( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t}\n\n\t// Array of textures (2D / Cube)\n\n\tfunction setValueT1a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\tfunction setValueT6a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\tfunction getPureArraySetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// --- Uniform Classes ---\n\n\tfunction SingleUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction StructuredUniform( id ) {\n\n\t\tthis.id = id;\n\n\t\tUniformContainer.call( this ); // mix-in\n\n\t}\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n\t// extracts\n\t// \t- the identifier (member name or array index)\n\t//  - followed by an optional right bracket (found when array index)\n\t//  - followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform( container, uniformObject ) {\n\n\t\tcontainer.seq.push( uniformObject );\n\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t}\n\n\tfunction parseUniform( activeInfo, addr, container ) {\n\n\t\tvar path = activeInfo.name,\n\t\t\tpathLength = path.length;\n\n\t\t// reset RegExp object, because of the early exit of a previous run\n\t\tRePathPart.lastIndex = 0;\n\n\t\tfor (; ;) {\n\n\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\tid = match[ 1 ],\n\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\tif ( subscript === undefined ||\n\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\tvar map = container.map,\n\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Root Container\n\n\tfunction WebGLUniforms( gl, program, renderer ) {\n\n\t\tUniformContainer.call( this );\n\n\t\tthis.renderer = renderer;\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\tpath = info.name,\n\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\t/**\n\t * Uniform Utilities\n\t */\n\n\tvar UniformsUtils = {\n\n\t\tmerge: function ( uniforms ) {\n\n\t\t\tvar merged = {};\n\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn merged;\n\n\t\t},\n\n\t\tclone: function ( uniforms_src ) {\n\n\t\t\tvar uniforms_dst = {};\n\n\t\t\tfor ( var u in uniforms_src ) {\n\n\t\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uniforms_dst;\n\n\t\t}\n\n\t};\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\n\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\n\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\n\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars: lights_pars,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_template: lights_template,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_flip: normal_flip,\n\t\tnormal_fragment: normal_fragment,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Color( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tColor.prototype = {\n\n\t\tconstructor: Color,\n\n\t\tisColor: true,\n\n\t\tr: 1, g: 1, b: 1,\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( (value && value.isColor) ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHex: function ( hex ) {\n\n\t\t\thex = Math.floor( hex );\n\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRGB: function ( r, g, b ) {\n\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHSL: function () {\n\n\t\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\t\t\tif ( s === 0 ) {\n\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetStyle: function ( style ) {\n\n\t\t\tfunction handleAlpha( string ) {\n\n\t\t\t\tif ( string === undefined ) return;\n\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar m;\n\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t\t// rgb / hsl\n\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t\t// hex color\n\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\n\t\t\t\tif ( size === 3 ) {\n\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( style && style.length > 0 ) {\n\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t\t},\n\n\t\tcopy: function ( color ) {\n\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertGammaToLinear: function () {\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertLinearToGamma: function () {\n\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetHex: function () {\n\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t\t},\n\n\t\tgetHexString: function () {\n\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t\t},\n\n\t\tgetHSL: function ( optionalTarget ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\t\tif ( min === max ) {\n\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar delta = max - min;\n\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\t\tswitch ( max ) {\n\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\n\t\t\t}\n\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\n\t\t\treturn hsl;\n\n\t\t},\n\n\t\tgetStyle: function () {\n\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t\t},\n\n\t\toffsetHSL: function ( h, s, l ) {\n\n\t\t\tvar hsl = this.getHSL();\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( color ) {\n\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddColors: function ( color1, color2 ) {\n\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function( color ) {\n\n\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( color ) {\n\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerp: function ( color, alpha ) {\n\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( c ) {\n\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\treturn this.getHex();\n\n\t\t}\n\n\t};\n\n\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tvar UniformsLib = {\n\n\t\tcommon: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\n\t\t\tspecularMap: { value: null },\n\t\t\talphaMap: { value: null },\n\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\treflectivity: { value: 1.0 },\n\t\t\trefractionRatio: { value: 0.98 }\n\n\t\t},\n\n\t\taomap: {\n\n\t\t\taoMap: { value: null },\n\t\t\taoMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\tlightmap: {\n\n\t\t\tlightMap: { value: null },\n\t\t\tlightMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\temissivemap: {\n\n\t\t\temissiveMap: { value: null }\n\n\t\t},\n\n\t\tbumpmap: {\n\n\t\t\tbumpMap: { value: null },\n\t\t\tbumpScale: { value: 1 }\n\n\t\t},\n\n\t\tnormalmap: {\n\n\t\t\tnormalMap: { value: null },\n\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t\t},\n\n\t\tdisplacementmap: {\n\n\t\t\tdisplacementMap: { value: null },\n\t\t\tdisplacementScale: { value: 1 },\n\t\t\tdisplacementBias: { value: 0 }\n\n\t\t},\n\n\t\troughnessmap: {\n\n\t\t\troughnessMap: { value: null }\n\n\t\t},\n\n\t\tmetalnessmap: {\n\n\t\t\tmetalnessMap: { value: null }\n\n\t\t},\n\n\t\tfog: {\n\n\t\t\tfogDensity: { value: 0.00025 },\n\t\t\tfogNear: { value: 1 },\n\t\t\tfogFar: { value: 2000 },\n\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t\t},\n\n\t\tlights: {\n\n\t\t\tambientLightColor: { value: [] },\n\n\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tcolor: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\t\tspotLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdirection: {},\n\t\t\t\tdistance: {},\n\t\t\t\tconeCos: {},\n\t\t\t\tpenumbraCos: {},\n\t\t\t\tdecay: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tspotShadowMap: { value: [] },\n\t\t\tspotShadowMatrix: { value: [] },\n\n\t\t\tpointLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdecay: {},\n\t\t\t\tdistance: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tpointShadowMap: { value: [] },\n\t\t\tpointShadowMatrix: { value: [] },\n\n\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tskyColor: {},\n\t\t\t\tgroundColor: {}\n\t\t\t} }\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\t\t\tsize: { value: 1.0 },\n\t\t\tscale: { value: 1.0 },\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\n\tvar ShaderLib = {\n\n\t\tbasic: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t\t},\n\n\t\tlambert: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t\t},\n\n\t\tphong: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t\t},\n\n\t\tstandard: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.points,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\n\t\t},\n\n\t\tdashed: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.fog,\n\n\t\t\t\t{\n\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t\t},\n\n\t\tdepth: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.displacementmap\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t\t},\n\n\t\tnormal: {\n\n\t\t\tuniforms: {\n\n\t\t\t\topacity : { value: 1.0 }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tcube: {\n\n\t\t\tuniforms: {\n\t\t\t\ttCube: { value: null },\n\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tequirect: {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t\ttFlip: { value: - 1 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t\t},\n\n\t\tdistanceRGBA: {\n\n\t\t\tuniforms: {\n\n\t\t\t\tlightPos: { value: new Vector3() }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t\t}\n\n\t};\n\n\tShaderLib.physical = {\n\n\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\tShaderLib.standard.uniforms,\n\n\t\t\t{\n\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Box2( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n\t}\n\n\tBox2.prototype = {\n\n\t\tconstructor: Box2,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlarePlugin( renderer, flares ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar shader, program, attributes, uniforms;\n\n\t\tvar tempTexture, occlusionTexture;\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t- 1,  1,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\t// buffers\n\n\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\telementBuffer    = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\t// textures\n\n\t\t\ttempTexture      = gl.createTexture();\n\t\t\tocclusionTexture = gl.createTexture();\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tshader = {\n\n\t\t\t\tvertexShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" ),\n\n\t\t\t\tfragmentShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t// pink square\n\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t\t// restore\n\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t\t// flare\n\n\t\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" )\n\n\t\t\t};\n\n\t\t\tprogram = createProgram( shader );\n\n\t\t\tattributes = {\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t};\n\n\t\t}\n\n\t\t/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\n\t\tthis.render = function ( scene, camera, viewport ) {\n\n\t\t\tif ( flares.length === 0 ) return;\n\n\t\t\tvar tempPosition = new Vector3();\n\n\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\t\tvar size = 16 / viewport.w,\n\t\t\t\tscale = new Vector2( size * invAspect, size );\n\n\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\n\t\t\tvar validArea = new Box2();\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t// setup gl and common used attribs/uniforms\n\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.setDepthWrite( false );\n\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t\t// calc object screen position\n\n\t\t\t\tvar flare = flares[ i ];\n\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t\t// setup arrays for gl programs\n\n\t\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t\t// screen cull\n\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// render pink quad\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// restore graphics\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// update object positions\n\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render flares\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\tstate.setDepthWrite( true );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram( shader ) {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t\tgl.compileShader( fragmentShader );\n\t\t\tgl.compileShader( vertexShader );\n\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\tgl.attachShader( program, vertexShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpritePlugin( renderer, sprites ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\n\t\tvar texture;\n\n\t\t// decompose matrixWorld\n\n\t\tvar spritePosition = new Vector3();\n\t\tvar spriteRotation = new Quaternion();\n\t\tvar spriteScale = new Vector3();\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\tprogram = createProgram();\n\n\t\t\tattributes = {\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\t\ttexture = new Texture( canvas );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( sprites.length === 0 ) return;\n\n\t\t\t// setup gl\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\n\t\t\tif ( fog ) {\n\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\t\tif ( (fog && fog.isFog) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\n\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\n\t\t\t}\n\n\n\t\t\t// update positions and sort\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t\t}\n\n\t\t\tsprites.sort( painterSortStable );\n\n\t\t\t// render all sprites\n\n\t\t\tvar scale = [];\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\n\t\t\t\tif ( material.visible === false ) continue;\n\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\t\tvar fogType = 0;\n\n\t\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\t\tfogType = sceneFogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram() {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t\t'}',\n\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn b.id - a.id;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Material() {\n\n\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\t\tthis.visible = true;\n\n\t\tthis._needsUpdate = true;\n\n\t}\n\n\tMaterial.prototype = {\n\n\t\tconstructor: Material,\n\n\t\tisMaterial: true,\n\n\t\tget needsUpdate() {\n\n\t\t\treturn this._needsUpdate;\n\n\t\t},\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.update();\n\t\t\tthis._needsUpdate = value;\n\n\t\t},\n\n\t\tsetValues: function ( values ) {\n\n\t\t\tif ( values === undefined ) return;\n\n\t\t\tfor ( var key in values ) {\n\n\t\t\t\tvar newValue = values[ key ];\n\n\t\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar isRoot = meta === undefined;\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t\t}\n\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t\t}\n\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t\t}\n\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t\t}\n\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\t\tdata.skinning = this.skinning;\n\t\t\tdata.morphTargets = this.morphTargets;\n\n\t\t\t// TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.shading = source.shading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\n\t\t\tthis.colorWrite = source.colorWrite;\n\n\t\t\tthis.precision = source.precision;\n\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\t\tthis.alphaTest = source.alphaTest;\n\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\t\tthis.overdraw = source.overdraw;\n\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\n\t\t\tif ( srcPlanes !== null ) {\n\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t};\n\n\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\n\tvar count$1 = 0;\n\tfunction MaterialIdCount() { return count$1++; }\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction ShaderMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype = Object.create( Material.prototype );\n\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tShaderMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\n\t\tthis.defines = source.defines;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.skinning = source.skinning;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.extensions = source.extensions;\n\n\t\treturn this;\n\n\t};\n\n\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshDepthMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Box3( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n\t}\n\n\tBox3.prototype = {\n\n\t\tconstructor: Box3,\n\n\t\tisBox3: true,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromArray: function ( array ) {\n\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t\t}\n\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromObject: function () {\n\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromObject( object ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\t\tthis.makeEmpty();\n\n\t\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\t\tvar array, offset, stride;\n\n\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\tstride = 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\n\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsSphere: ( function () {\n\n\t\t\tvar closestPoint;\n\n\t\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\t\tvar min, max;\n\n\t\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t\t} else {\n\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t\t}\n\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetBoundingSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Sphere();\n\n\t\t\t\tthis.getCenter( result.center );\n\n\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar points = [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t];\n\n\t\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\t\tthis.setFromPoints( points );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Sphere( center, radius ) {\n\n\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n\t}\n\n\tSphere.prototype = {\n\n\t\tconstructor: Sphere,\n\n\t\tset: function ( center, radius ) {\n\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function () {\n\n\t\t\tvar box = new Box3();\n\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\t\tvar center = this.center;\n\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t\t}\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( sphere ) {\n\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tempty: function () {\n\n\t\t\treturn ( this.radius <= 0 );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsSphere( this );\n\n\t\t},\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t// the center of the sphere to the plane.\n\t\t\t//\n\t\t\t// distance = q * n - d\n\t\t\t//\n\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t// then there is no intersection.\n\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.copy( point );\n\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\t\tvar box = optionalTarget || new Box3();\n\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\n\t\t\treturn box;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.center.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( sphere ) {\n\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\n\tfunction Matrix3() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix3.prototype = {\n\n\t\tconstructor: Matrix3,\n\n\t\tisMatrix3: true,\n\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix4: function( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t\t},\n\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t\t}\n\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar tmp, m = this.elements;\n\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t\t},\n\n\t\ttransposeIntoArray: function ( r ) {\n\n\t\t\tvar m = this.elements;\n\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Plane( normal, constant ) {\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tPlane.prototype = {\n\n\t\tconstructor: Plane,\n\n\t\tset: function ( normal, constant ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponents: function ( x, y, z, w ) {\n\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCoplanarPoints: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( plane ) {\n\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\n\t\t},\n\n\t\tdistanceToSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t\t},\n\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t\t},\n\n\t\torthoPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t\t},\n\n\t\tintersectLine: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tvar direction = line.delta( v1 );\n\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsLine: function ( line ) {\n\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsPlane( this );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn sphere.intersectsPlane( this );\n\n\t\t},\n\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar m1 = new Matrix3();\n\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t\t// transform normal based on theory here:\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( plane ) {\n\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tthis.planes = [\n\n\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t\t];\n\n\t}\n\n\tFrustum.prototype = {\n\n\t\tconstructor: Frustum,\n\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( frustum ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix: function ( m ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tintersectsObject: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsObject( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSprite: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsBox: function () {\n\n\t\t\tvar p1 = new Vector3(),\n\t\t\t\tp2 = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\tvar planes = this.planes;\n\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t}(),\n\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\n\t\tvar _gl = _renderer.context,\n\t\t_state = _renderer.state,\n\t\t_frustum = new Frustum(),\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_lightShadows = _lights.shadows,\n\n\t\t_shadowMapSize = new Vector2(),\n\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\n\t\t_lookTarget = new Vector3(),\n\t\t_lightPositionWorld = new Vector3(),\n\n\t\t_renderList = [],\n\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t_materialCache = {};\n\n\t\tvar cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tvar cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t\tvar cube2DViewPorts = [\n\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t];\n\n\t\t// init\n\n\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\tdepthMaterialTemplate.clipping = true;\n\n\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\tdefines: {\n\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t},\n\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning,\n\t\t\t\tclipping: true\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tthis.enabled = false;\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.renderReverseSided = true;\n\t\tthis.renderSingleSided = true;\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.setDepthTest( true );\n\t\t\t_state.setScissorTest( false );\n\n\t\t\t// render depth map\n\n\t\t\tvar faceCount, isPointLight;\n\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\t\tif ( (light && light.isPointLight) ) {\n\n\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\tisPointLight = true;\n\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\tisPointLight = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\n\t\t\t\t\tshadow.update( light );\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t\t// compute shadow matrix\n\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t\t_renderList.length = 0;\n\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t\t// render shadow map\n\t\t\t\t\t// render regular objects\n\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Restore GL state.\n\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t};\n\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tvar result = null;\n\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t\t}\n\n\t\t\tif ( ! customMaterial ) {\n\n\t\t\t\tvar useMorphing = false;\n\n\t\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\t\tvar variantIndex = 0;\n\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t\t} else {\n\n\t\t\t\tresult = customMaterial;\n\n\t\t\t}\n\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tvar side = material.side;\n\n\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\n\t\t\t\tside = FrontSide;\n\n\t\t\t}\n\n\t\t\tif ( scope.renderReverseSided ) {\n\n\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\n\t\t\t}\n\n\t\t\tresult.side = side;\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Ray( origin, direction ) {\n\n\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n\t}\n\n\tRay.prototype = {\n\n\t\tconstructor: Ray,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( ray ) {\n\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t\t},\n\n\t\tlookAt: function ( v ) {\n\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trecast: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function recast( t ) {\n\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn result.copy( this.origin );\n\n\t\t\t}\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t\t},\n\n\t\tdistanceSqToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t\t// point behind the ray\n\n\t\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t\t}\n\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\t\treturn v1.distanceToSquared( point );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceSqToSegment: function () {\n\n\t\t\tvar segCenter = new Vector3();\n\t\t\tvar segDir = new Vector3();\n\t\t\tvar diff = new Vector3();\n\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\t\tif ( det > 0 ) {\n\n\t\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\n\t\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t\t}\n\n\t\t\t\treturn sqrDist;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t\t},\n\n\t\tdistanceToPlane: function ( plane ) {\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t\t// Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t :  null;\n\n\t\t},\n\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\t\tvar t = this.distanceToPlane( plane );\n\n\t\t\tif ( t === null ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn this.at( t, optionalTarget );\n\n\t\t},\n\n\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// check if the ray lies on the plane first\n\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\t\tif ( distToPoint === 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tintersectBox: function ( box, optionalTarget ) {\n\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\t\tvar origin = this.origin;\n\n\t\t\tif ( invdirx >= 0 ) {\n\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t\t} else {\n\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t\t}\n\n\t\t\tif ( invdiry >= 0 ) {\n\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t\t} else {\n\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\t\tif ( invdirz >= 0 ) {\n\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t\t} else {\n\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t\t//return point closest to the ray (positive side)\n\n\t\t\tif ( tmax < 0 ) return null;\n\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t\t},\n\n\t\tintersectsBox: ( function () {\n\n\t\t\tvar v = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectTriangle: function () {\n\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new Vector3();\n\t\t\tvar edge1 = new Vector3();\n\t\t\tvar edge2 = new Vector3();\n\t\t\tvar normal = new Vector3();\n\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\n\t\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\n\t\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix4: function ( matrix4 ) {\n\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.sub( this.origin );\n\t\t\tthis.direction.normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( ray ) {\n\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Euler( x, y, z, order ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || Euler.DefaultOrder;\n\n\t}\n\n\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\n\tEuler.DefaultOrder = 'XYZ';\n\n\tEuler.prototype = {\n\n\t\tconstructor: Euler,\n\n\t\tisEuler: true,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget order () {\n\n\t\t\treturn this._order;\n\n\t\t},\n\n\t\tset order ( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, order ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t\t},\n\n\t\tcopy: function ( euler ) {\n\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\t\tvar clamp = _Math.clamp;\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\torder = order || this._order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t\t}\n\n\t\t\tthis._order = order;\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromQuaternion: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromVector3: function ( v, order ) {\n\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t\t},\n\n\t\treorder: function () {\n\n\t\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t\tvar q = new Quaternion();\n\n\t\t\treturn function reorder( newOrder ) {\n\n\t\t\t\tq.setFromEuler( this );\n\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( euler ) {\n\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t\t},\n\n\t\tfromArray: function ( array ) {\n\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoVector3: function ( optionalResult ) {\n\n\t\t\tif ( optionalResult ) {\n\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t\t} else {\n\n\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t\t}\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Layers() {\n\n\t\tthis.mask = 1;\n\n\t}\n\n\tLayers.prototype = {\n\n\t\tconstructor: Layers,\n\n\t\tset: function ( channel ) {\n\n\t\t\tthis.mask = 1 << channel;\n\n\t\t},\n\n\t\tenable: function ( channel ) {\n\n\t\t\tthis.mask |= 1 << channel;\n\n\t\t},\n\n\t\ttoggle: function ( channel ) {\n\n\t\t\tthis.mask ^= 1 << channel;\n\n\t\t},\n\n\t\tdisable: function ( channel ) {\n\n\t\t\tthis.mask &= ~ ( 1 << channel );\n\n\t\t},\n\n\t\ttest: function ( layers ) {\n\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\n\tfunction Object3D() {\n\n\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\tvar position = new Vector3();\n\t\tvar rotation = new Euler();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.userData = {};\n\n\t\tthis.onBeforeRender = function(){}; \n\t\tthis.onAfterRender = function(){};\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\n\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\n\t\tisObject3D: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t\t},\n\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t\t},\n\n\t\tsetRotationFromEuler: function ( euler ) {\n\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t\t},\n\n\t\tsetRotationFromMatrix: function ( m ) {\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t\t},\n\n\t\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t\t// assumes q is normalized\n\n\t\t\tthis.quaternion.copy( q );\n\n\t\t},\n\n\t\trotateOnAxis: function () {\n\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar q1 = new Quaternion();\n\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateOnAxis: function () {\n\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function translateX( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function translateY( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function translateZ( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlocalToWorld: function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t\t},\n\n\t\tworldToLocal: function () {\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function worldToLocal( vector ) {\n\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tadd: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object === this ) {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( (object && object.isObject3D) ) {\n\n\t\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\t\tthis.children.push( object );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tremove: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar index = this.children.indexOf( object );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tobject.parent = null;\n\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetObjectById: function ( id ) {\n\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\n\t\t},\n\n\t\tgetObjectByName: function ( name ) {\n\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\n\t\t},\n\n\t\tgetObjectByProperty: function ( name, value ) {\n\n\t\t\tif ( this[ name ] === value ) return this;\n\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\t\tif ( object !== undefined ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t},\n\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t\t},\n\n\t\tgetWorldQuaternion: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar scale = new Vector3();\n\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Quaternion();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldRotation: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Euler();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldScale: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldDirection: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\traycast: function () {},\n\n\t\ttraverse: function ( callback ) {\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverse( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseVisible: function ( callback ) {\n\n\t\t\tif ( this.visible === false ) return;\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseAncestors: function ( callback ) {\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tcallback( parent );\n\n\t\t\t\tparent.traverseAncestors( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrix: function () {\n\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t\t},\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\tforce = true;\n\n\t\t\t}\n\n\t\t\t// update children\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\t// meta is '' when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\t\tvar output = {};\n\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// standard Object3D serialization\n\n\t\t\tvar object = {};\n\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\n\t\t\tobject.matrix = this.matrix.toArray();\n\n\t\t\t//\n\n\t\t\tif ( this.geometry !== undefined ) {\n\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.material !== undefined ) {\n\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = this.material.uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.children.length > 0 ) {\n\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t\t}\n\n\t\t\toutput.object = object;\n\n\t\t\treturn output;\n\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function ( recursive ) {\n\n\t\t\treturn new this.constructor().copy( this, recursive );\n\n\t\t},\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tif ( recursive === undefined ) recursive = true;\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.up.copy( source.up );\n\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\tthis.visible = source.visible;\n\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\tvar count$2 = 0;\n\tfunction Object3DIdCount() { return count$2++; }\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Line3( start, end ) {\n\n\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n\t}\n\n\tLine3.prototype = {\n\n\t\tconstructor: Line3,\n\n\t\tset: function ( start, end ) {\n\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( line ) {\n\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tdelta: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\n\t\t},\n\n\t\tdistanceSq: function () {\n\n\t\t\treturn this.start.distanceToSquared( this.end );\n\n\t\t},\n\n\t\tdistance: function () {\n\n\t\t\treturn this.start.distanceTo( this.end );\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tclosestPointToPointParameter: function () {\n\n\t\t\tvar startP = new Vector3();\n\t\t\tvar startEnd = new Vector3();\n\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\t\tif ( clampToLine ) {\n\n\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t\treturn t;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( line ) {\n\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Triangle( a, b, c ) {\n\n\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n\t}\n\n\tTriangle.normal = function () {\n\n\t\tvar v0 = new Vector3();\n\n\t\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\tresult.cross( v0 );\n\n\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t\t}\n\n\t\t\treturn result.set( 0, 0, 0 );\n\n\t\t};\n\n\t}();\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tTriangle.barycoordFromPoint = function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t\t}\n\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn result.set( 1 - u - v, v, u );\n\n\t\t};\n\n\t}();\n\n\tTriangle.containsPoint = function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t\t};\n\n\t}();\n\n\tTriangle.prototype = {\n\n\t\tconstructor: Triangle,\n\n\t\tset: function ( a, b, c ) {\n\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( triangle ) {\n\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tarea: function () {\n\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function area() {\n\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmidpoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t\t},\n\n\t\tnormal: function ( optionalTarget ) {\n\n\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tplane: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Plane();\n\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t\t},\n\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t\t},\n\n\t\tclosestPointToPoint: function () {\n\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\t\tif ( plane === undefined ) {\n\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\n\t\t\t\t// project the point onto the plane of the triangle\n\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t\t// check if the projection lies within the triangle\n\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t\t// if so, this is the closest point\n\n\t\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( triangle ) {\n\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\t}\n\n\tFace3.prototype = {\n\n\t\tconstructor: Face3,\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\n\t\t\tthis.materialIndex = source.materialIndex;\n\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\n\tfunction MeshBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferAttribute( array, itemSize, normalized ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized === true;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tBufferAttribute.prototype = {\n\n\t\tconstructor: BufferAttribute,\n\n\t\tisBufferAttribute: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyArray: function ( array ) {\n\n\t\t\tthis.array.set( array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyColorsArray: function ( colors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tvar color = colors[ i ];\n\n\t\t\t\tif ( color === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new Color();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyIndicesArray: function ( indices ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tvar index = indices[ i ];\n\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector2sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector3sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector4sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize ];\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Int8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n\t}\n\n\tfunction Int16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\n\t}\n\n\tfunction Int32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float64Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\n\t}\n\n\t// Deprecated\n\n\tfunction DynamicBufferAttribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Geometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\tthis.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\n\t\tisGeometry: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfromBufferGeometry: function ( geometry ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\t\tscope.faces.push( face );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\t\tvar matrix = new Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tthis.applyMatrix( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tvar face = this.faces[ f ];\n\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t\tvertices = new Array( this.vertices.length );\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new Vector3();\n\n\t\t\t}\n\n\t\t\tif ( areaWeighted ) {\n\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].normalize();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeFlatVertexNormals: function () {\n\n\t\t\tvar f, fl, face;\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeMorphNormals: function () {\n\n\t\t\tvar i, il, f, fl, face;\n\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\t\tvar tmpGeo = new Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\t// create on first access\n\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t\t// set vertices to morph target\n\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t\t// compute morph normals\n\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t\t// store morph normals\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore original normals\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeTangents: function () {\n\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t\t},\n\n\t\tcomputeLineDistances: function () {\n\n\t\t\tvar d = 0;\n\t\t\tvar vertices = this.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tif ( i > 0 ) {\n\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\t\tif ( matrix !== undefined ) {\n\n\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\t\tvertices1.push( vertexCopy );\n\n\t\t\t}\n\n\t\t\t// colors\n\n\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\t\tfaces1.push( faceCopy );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\t\tif ( uv === undefined ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tuvs1.push( uvCopy );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmergeMesh: function ( mesh ) {\n\n\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t\t},\n\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\n\t\tmergeVertices: function () {\n\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = this.faces[ i ];\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t\tvar dupIndex = - 1;\n\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Use unique set of vertices\n\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\n\t\t},\n\n\t\tsortFacesByMaterialIndex: function () {\n\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\n\t\t\t// tag faces\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tfaces[ i ]._id = i;\n\n\t\t\t}\n\n\t\t\t// sort faces\n\n\t\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t}\n\n\t\t\tfaces.sort( materialIndexSort );\n\n\t\t\t// sort uvs\n\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\t\tvar newUvs1, newUvs2;\n\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar id = faces[ i ]._id;\n\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t\t}\n\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Geometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\t\tvar faceType = 0;\n\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\n\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t\t}\n\n\t\t\tfunction getNormalIndex( normal ) {\n\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getColorIndex( color ) {\n\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getUvIndex( uv ) {\n\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tdata.data = {};\n\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new Geometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\tthis.colors = [];\n\n\t\t\tvar vertices = source.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar colors = source.colors;\n\n\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar faces = source.faces;\n\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tvar count$3 = 0;\n\tfunction GeometryIdCount() { return count$3++; }\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'DirectGeometry';\n\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeGroups: function ( geometry ) {\n\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex;\n\n\t\t\tvar faces = geometry.faces;\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// materials\n\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( group !== undefined ) {\n\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\n\t\t\t}\n\n\t\t\tthis.groups = groups;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t\t// morphs\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\t\tvar morphTargetsPosition;\n\n\t\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\t\tmorphTargetsPosition = [];\n\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t\t}\n\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\t\tvar morphTargetsNormal;\n\n\t\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\t\tmorphTargetsNormal = [];\n\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t\t//\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar normal = face.normal;\n\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = face.color;\n\n\t\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// morphs\n\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t\t}\n\n\t\t\t\t// skins\n\n\t\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeGroups( geometry );\n\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t}\n\n\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tisBufferGeometry: true,\n\n\t\tgetIndex: function () {\n\n\t\t\treturn this.index;\n\n\t\t},\n\n\t\tsetIndex: function ( index ) {\n\n\t\t\tthis.index = index;\n\n\t\t},\n\n\t\taddAttribute: function ( name, attribute ) {\n\n\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( name === 'index' ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.attributes[ name ] = attribute;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetAttribute: function ( name ) {\n\n\t\t\treturn this.attributes[ name ];\n\n\t\t},\n\n\t\tremoveAttribute: function ( name ) {\n\n\t\t\tdelete this.attributes[ name ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddGroup: function ( start, count, materialIndex ) {\n\n\t\t\tthis.groups.push( {\n\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t\t} );\n\n\t\t},\n\n\t\tclearGroups: function () {\n\n\t\t\tthis.groups = [];\n\n\t\t},\n\n\t\tsetDrawRange: function ( start, count ) {\n\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\n\t\t},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tvar normal = this.attributes.normal;\n\n\t\t\tif ( normal !== undefined ) {\n\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\tnormal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\n\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( (object && object.isMesh) ) {\n\n\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateFromObject: function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isMesh) ) {\n\n\t\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\t\tdirect = undefined;\n\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( direct === undefined ) {\n\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t\tgeometry = direct;\n\n\t\t\t}\n\n\t\t\tvar attribute;\n\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.normal;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.color;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.uv;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t\t},\n\n\t\tfromDirectGeometry: function ( geometry ) {\n\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t\t}\n\n\t\t\t// groups\n\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\t// morphs\n\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t\t}\n\n\t\t\t// skinning\n\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position.array;\n\n\t\t\tif ( positions !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t\t} else {\n\n\t\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t\t}\n\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tvar box = new Box3();\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t\t}\n\n\t\t\t\tvar positions = this.attributes.position;\n\n\t\t\t\tif ( positions ) {\n\n\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\t// backwards compatibility\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( attributes.position ) {\n\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset existing normals to zero\n\n\t\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\tvar vA, vB, vC,\n\n\t\t\t\tpA = new Vector3(),\n\t\t\t\tpB = new Vector3(),\n\t\t\t\tpC = new Vector3(),\n\n\t\t\t\tcb = new Vector3(),\n\t\t\t\tab = new Vector3();\n\n\t\t\t\t// indexed elements\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\n\t\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmerge: function ( geometry, offset ) {\n\n\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalizeNormals: function () {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\n\t\t\tvar x, y, z, n;\n\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoNonIndexed: function () {\n\n\t\t\tif ( this.index === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar geometry2 = new BufferGeometry();\n\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tdata.data = { attributes: {} };\n\n\t\t\tvar index = this.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = this.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new BufferGeometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tvar index = source.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.setIndex( index.clone() );\n\n\t\t\t}\n\n\t\t\tvar attributes = source.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t\t}\n\n\t\t\tvar groups = source.groups;\n\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tBufferGeometry.MaxIndex = 65535;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\n\tfunction Mesh( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t\tthis.drawMode = TrianglesDrawMode;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Mesh,\n\n\t\tisMesh: true,\n\n\t\tsetDrawMode: function ( value ) {\n\n\t\t\tthis.drawMode = value;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.drawMode = source.drawMode;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateMorphTargets: function () {\n\n\t\t\tvar morphTargets = this.geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\tvar vA = new Vector3();\n\t\t\tvar vB = new Vector3();\n\t\t\tvar vC = new Vector3();\n\n\t\t\tvar tempA = new Vector3();\n\t\t\tvar tempB = new Vector3();\n\t\t\tvar tempC = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tvar barycoord = new Vector3();\n\n\t\t\tvar intersectionPoint = new Vector3();\n\t\t\tvar intersectionPointWorld = new Vector3();\n\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\t\treturn uv1.clone();\n\n\t\t\t}\n\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\t\tvar intersect;\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersect === null ) return null;\n\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t\t}\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\tif ( material === undefined ) return;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\t// Check boundingBox before continuing\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t\t}\n\n\t\t\t\tvar uvs, intersection;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tvar scope = this;\n\n\t\t// segments\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\tvar numberOfVertices = 0;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// build each side of the box geometry\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount( w, h, d ) {\n\n\t\t\tvar vertices = 0;\n\n\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\t\treturn vertices;\n\n\t\t}\n\n\t\tfunction calculateIndexCount( w, h, d ) {\n\n\t\t\tvar index = 0;\n\n\t\t\t// calculate the amount of squares for each side\n\t\t\tindex += w * h * 2; // xy\n\t\t\tindex += w * d * 2; // xz\n\t\t\tindex += d * h * 2; // zy\n\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t\t}\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// uvs\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PlaneBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\t\tvar offset = 0;\n\t\tvar offset2 = 0;\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segment_height - height_half;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\t\tvertices[ offset ] = x;\n\t\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\toffset += 3;\n\t\t\t\toffset2 += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\toffset = 0;\n\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices[ offset ] = a;\n\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\t\toffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction Camera() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\t\tthis.projectionMatrix = new Matrix4();\n\n\t}\n\n\tCamera.prototype = Object.create( Object3D.prototype );\n\tCamera.prototype.constructor = Camera;\n\n\tCamera.prototype.isCamera = true;\n\n\tCamera.prototype.getWorldDirection = function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.lookAt = function () {\n\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.clone = function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t};\n\n\tCamera.prototype.copy = function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\n\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: PerspectiveCamera,\n\n\t\tisPerspectiveCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\n\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t\t},\n\n\t\tgetEffectiveFOV: function () {\n\n\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t\t},\n\n\t\tgetFilmWidth: function () {\n\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t\t},\n\n\t\tgetFilmHeight: function () {\n\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t\t},\n\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\n\t\t\tif ( view !== null ) {\n\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\n\t\t\t}\n\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\n\t\t\tdata.object.aspect = this.aspect;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\n\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: OrthographicCamera,\n\n\t\tisOrthographicCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\n\t\t\tif ( this.view !== null ) {\n\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tvar type, size;\n\n\t\tfunction setIndex( index ) {\n\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\tsize = 4;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\tsize = 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawElements( mode, count, type, start * size );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry, start, count ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tsetMode: setMode,\n\t\t\tsetIndex: setIndex,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar position = geometry.attributes.position;\n\n\t\t\tvar count = 0;\n\n\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\n\t\t\t\tcount = position.data.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t} else {\n\n\t\t\t\tcount = position.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t}\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetMode: setMode,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLLights() {\n\n\t\tvar lights = {};\n\n\t\treturn {\n\n\t\t\tget: function ( light ) {\n\n\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\t\treturn lights[ light.id ];\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms;\n\n\t\t\t\tswitch ( light.type ) {\n\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\t\treturn uniforms;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\tfunction WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material.isRawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( ! material.isShaderMaterial ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLPrograms( renderer, capabilities ) {\n\n\t\tvar programs = [];\n\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points'\n\t\t};\n\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t];\n\n\n\t\tfunction allocateBones( object ) {\n\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\t\treturn 1024;\n\n\t\t\t} else {\n\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\t\tvar encoding;\n\n\t\t\tif ( ! map ) {\n\n\t\t\t\tencoding = LinearEncoding;\n\n\t\t\t} else if ( (map && map.isTexture) ) {\n\n\t\t\t\tencoding = map.encoding;\n\n\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\n\t\t\t}\n\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\t\tencoding = GammaEncoding;\n\n\t\t\t}\n\n\t\t\treturn encoding;\n\n\t\t}\n\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tvar maxBones = allocateBones( object );\n\t\t\tvar precision = renderer.getPrecision();\n\n\t\t\tif ( material.precision !== null ) {\n\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\t\tvar parameters = {\n\n\t\t\t\tshaderID: shaderID,\n\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\t\tcombine: material.combine,\n\n\t\t\t\tvertexColors: material.vertexColors,\n\n\t\t\t\tfog: !! fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\n\t\t\t\tflatShading: material.shading === FlatShading,\n\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\t\tskinning: material.skinning,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t\t};\n\n\t\t\treturn parameters;\n\n\t\t};\n\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\t\tvar array = [];\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tarray.push( parameters.shaderID );\n\n\t\t\t} else {\n\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\n\t\t\t}\n\n\t\t\tif ( material.defines !== undefined ) {\n\n\t\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\treturn array.join();\n\n\t\t};\n\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\t\tvar program;\n\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\t\tvar programInfo = programs[ p ];\n\n\t\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\tprograms.push( program );\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t};\n\n\t\tthis.releaseProgram = function( program ) {\n\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLGeometries( gl, properties, info ) {\n\n\t\tvar geometries = {};\n\n\t\tfunction onGeometryDispose( event ) {\n\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t\t}\n\n\t\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\t\tdelete geometries[ geometry.id ];\n\n\t\t\t// TODO\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe ) {\n\n\t\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( geometry );\n\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( buffergeometry );\n\n\t\t\t//\n\n\t\t\tinfo.memory.geometries --;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction deleteAttribute( attribute ) {\n\n\t\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\t\tif ( buffer !== undefined ) {\n\n\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction deleteAttributes( attributes ) {\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tproperties.delete( attribute.data );\n\n\t\t\t} else {\n\n\t\t\t\tproperties.delete( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\t\t\treturn geometries[ geometry.id ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t\tvar buffergeometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tbuffergeometry = geometry;\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t\t\t}\n\n\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\t\t\tinfo.memory.geometries ++;\n\n\t\t\t\treturn buffergeometry;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLObjects( gl, properties, info ) {\n\n\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\n\t\t//\n\n\t\tfunction update( object ) {\n\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\t\tvar geometry = geometries.get( object );\n\n\t\t\tif ( object.geometry.isGeometry ) {\n\n\t\t\t\tgeometry.updateFromObject( object );\n\n\t\t\t}\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var name in morphAttributes ) {\n\n\t\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\t\tvar attributeProperties = properties.get( data );\n\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tif ( data.dynamic === false ) {\n\n\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\n\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\n\t\t\t\t// Not using update ranges\n\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t\t}\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction getWireframeAttribute( geometry ) {\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\t\treturn property.wireframe;\n\n\t\t\t}\n\n\t\t\tvar indices = [];\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar position = attributes.position;\n\n\t\t\t// console.time( 'wireframe' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar edges = {};\n\t\t\t\tvar array = index.array;\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar array = attributes.position.array;\n\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'wireframe' );\n\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\tproperty.wireframe = attribute;\n\n\t\t\treturn attribute;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\n\t\t\tupdate: update\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\t\tvar _infoMemory = info.memory;\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t\t//\n\n\t\tfunction clampToMaxSize( image, maxSize ) {\n\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t\t}\n\n\t\tfunction makePowerOfTwo( image ) {\n\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Fallback filters for non-power-of-2 textures\n\n\t\tfunction filterFallback( f ) {\n\n\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\t\treturn _gl.NEAREST;\n\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onTextureDispose( event ) {\n\n\t\t\tvar texture = event.target;\n\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\t\tdeallocateTexture( texture );\n\n\t\t\t_infoMemory.textures --;\n\n\n\t\t}\n\n\t\tfunction onRenderTargetDispose( event ) {\n\n\t\t\tvar renderTarget = event.target;\n\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t\t_infoMemory.textures --;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction deallocateTexture( texture ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t\t} else {\n\n\t\t\t\t// 2D texture\n\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\t// remove all webgl properties\n\t\t\tproperties.delete( texture );\n\n\t\t}\n\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\tif ( ! renderTarget ) return;\n\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t\t}\n\n\t\t\tproperties.delete( renderTarget.texture );\n\t\t\tproperties.delete( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\n\n\t\tfunction setTexture2D( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tvar image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureCube( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image.length === 6 ) {\n\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\n\t\t\t\t\tvar cubeImage = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension ) {\n\n\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\t\timage = makePowerOfTwo( image );\n\n\t\t\t}\n\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\t}\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\n\t\t\t\t}\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\t// Render targets\n\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else {\n\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t}\n\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t\t}\n\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('Unknown depthTexture format')\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t\t// Setup framebuffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\t// Setup color buffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t// Setup depth and stencil buffers\n\n\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\t\tvar texture = renderTarget.texture;\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\n\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n\t}\n\n\t/**\n\t * @author fordacious / fordacious.github.io\n\t */\n\n\tfunction WebGLProperties() {\n\n\t\tvar properties = {};\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar uuid = object.uuid;\n\t\t\t\tvar map = properties[ uuid ];\n\n\t\t\t\tif ( map === undefined ) {\n\n\t\t\t\t\tmap = {};\n\t\t\t\t\tproperties[ uuid ] = map;\n\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\n\t\t\t},\n\n\t\t\tdelete: function ( object ) {\n\n\t\t\t\tdelete properties[ object.uuid ];\n\n\t\t\t},\n\n\t\t\tclear: function () {\n\n\t\t\t\tproperties = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\n\t\tfunction ColorBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar color = new Vector4();\n\t\t\tvar currentColorMask = null;\n\t\t\tvar currentColorClear = new Vector4();\n\n\t\t\treturn {\n\n\t\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( r, g, b, a ) {\n\n\t\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentDepthMask = null;\n\t\t\tvar currentDepthFunc = null;\n\t\t\tvar currentDepthClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentStencilMask = null;\n\t\t\tvar currentStencilFunc = null;\n\t\t\tvar currentStencilRef = null;\n\t\t\tvar currentStencilFuncMask = null;\n\t\t\tvar currentStencilFail  = null;\n\t\t\tvar currentStencilZFail = null;\n\t\t\tvar currentStencilZPass = null;\n\t\t\tvar currentStencilClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tvar colorBuffer = new ColorBuffer();\n\t\tvar depthBuffer = new DepthBuffer();\n\t\tvar stencilBuffer = new StencilBuffer();\n\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\t\tvar capabilities = {};\n\n\t\tvar compressedTextureFormats = null;\n\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\n\t\tvar currentLineWidth = null;\n\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\n\t\tvar currentScissorTest = null;\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\n\t\tvar currentScissor = new Vector4();\n\t\tvar currentViewport = new Vector4();\n\n\t\tfunction createTexture( type, target, count ) {\n\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t\t//\n\n\t\tfunction init() {\n\n\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\tclearDepth( 1 );\n\t\t\tclearStencil( 0 );\n\n\t\t\tenable( gl.DEPTH_TEST );\n\t\t\tsetDepthFunc( LessEqualDepth );\n\n\t\t\tsetFlipSided( false );\n\t\t\tsetCullFace( CullFaceBack );\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tenable( gl.BLEND );\n\t\t\tsetBlending( NormalBlending );\n\n\t\t}\n\n\t\tfunction initAttributes() {\n\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tnewAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttribute( attribute ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getCompressedTextureFormats() {\n\n\t\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\t\tcompressedTextureFormats = [];\n\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn compressedTextureFormats;\n\n\t\t}\n\n\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\t\tif ( blending !== NoBlending ) {\n\n\t\t\t\tenable( gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.BLEND );\n\n\t\t\t}\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( blending === AdditiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blending === CustomBlending ) {\n\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t\t}\n\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction setColorWrite( colorWrite ) {\n\n\t\t\tcolorBuffer.setMask( colorWrite );\n\n\t\t}\n\n\t\tfunction setDepthTest( depthTest ) {\n\n\t\t\tdepthBuffer.setTest( depthTest );\n\n\t\t}\n\n\t\tfunction setDepthWrite( depthWrite ) {\n\n\t\t\tdepthBuffer.setMask( depthWrite );\n\n\t\t}\n\n\t\tfunction setDepthFunc( depthFunc ) {\n\n\t\t\tdepthBuffer.setFunc( depthFunc );\n\n\t\t}\n\n\t\tfunction setStencilTest( stencilTest ) {\n\n\t\t\tstencilBuffer.setTest( stencilTest );\n\n\t\t}\n\n\t\tfunction setStencilWrite( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( stencilWrite );\n\n\t\t}\n\n\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t}\n\n\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction setFlipSided( flipSided ) {\n\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\t\tif ( flipSided ) {\n\n\t\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setCullFace( cullFace ) {\n\n\t\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\t\tenable( gl.CULL_FACE );\n\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\n\t\t}\n\n\t\tfunction setLineWidth( width ) {\n\n\t\t\tif ( width !== currentLineWidth ) {\n\n\t\t\t\tgl.lineWidth( width );\n\n\t\t\t\tcurrentLineWidth = width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\t\tif ( polygonOffset ) {\n\n\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getScissorTest() {\n\n\t\t\treturn currentScissorTest;\n\n\t\t}\n\n\t\tfunction setScissorTest( scissorTest ) {\n\n\t\t\tcurrentScissorTest = scissorTest;\n\n\t\t\tif ( scissorTest ) {\n\n\t\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// texture\n\n\t\tfunction activeTexture( webglSlot ) {\n\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\tactiveTexture();\n\n\t\t\t}\n\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\t\tif ( boundTexture === undefined ) {\n\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t\t}\n\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction texImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction clearColor( r, g, b, a ) {\n\n\t\t\tcolorBuffer.setClear( r, g, b, a );\n\n\t\t}\n\n\t\tfunction clearDepth( depth ) {\n\n\t\t\tdepthBuffer.setClear( depth );\n\n\t\t}\n\n\t\tfunction clearStencil( stencil ) {\n\n\t\t\tstencilBuffer.setClear( stencil );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction scissor( scissor ) {\n\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction viewport( viewport ) {\n\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction reset() {\n\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcapabilities = {};\n\n\t\t\tcompressedTextureFormats = null;\n\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\n\t\t\tcurrentBlending = null;\n\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\n\t\t\tinit: init,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\t\tsetBlending: setBlending,\n\n\t\t\tsetColorWrite: setColorWrite,\n\t\t\tsetDepthTest: setDepthTest,\n\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\tsetStencilTest: setStencilTest,\n\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\tsetStencilOp: setStencilOp,\n\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\t\tgetScissorTest: getScissorTest,\n\t\t\tsetScissorTest: setScissorTest,\n\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\n\t\t\tclearColor: clearColor,\n\t\t\tclearDepth: clearDepth,\n\t\t\tclearStencil: clearStencil,\n\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\n\t\t\treset: reset\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\t\tvar maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t\t} else {\n\n\t\t\t\tmaxAnisotropy = 0;\n\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\n\t\t}\n\n\t\tfunction getMaxPrecision( precision ) {\n\n\t\t\tif ( precision === 'highp' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'highp';\n\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\n\t\t\t}\n\n\t\t\tif ( precision === 'mediump' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'mediump';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\n\t\t}\n\n\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tvar maxPrecision = getMaxPrecision( precision );\n\n\t\tif ( maxPrecision !== precision ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\tprecision = maxPrecision;\n\n\t\t}\n\n\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\t\treturn {\n\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLExtensions( gl ) {\n\n\t\tvar extensions = {};\n\n\t\treturn {\n\n\t\t\tget: function ( name ) {\n\n\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\t\treturn extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tvar extension;\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\textensions[ name ] = extension;\n\n\t\t\t\treturn extension;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction WebGLClipping() {\n\n\t\tvar scope = this,\n\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\n\t\t\tplane = new Plane(),\n\t\t\tviewNormalMatrix = new Matrix3(),\n\n\t\t\tuniform = { value: null, needsUpdate: false };\n\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\n\t\t\treturn enabled;\n\n\t\t};\n\n\t\tthis.beginShadows = function() {\n\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\n\t\t};\n\n\t\tthis.endShadows = function() {\n\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\n\t\t};\n\n\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t// there's no local clipping\n\n\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t// there's no global clipping\n\n\t\t\t\t\tprojectPlanes( null );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\n\t\t\tif ( uniform.value !== globalState ) {\n\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\n\t\t}\n\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\n\t\t\tif ( nPlanes !== 0 ) {\n\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\n\tfunction WebGLRenderer( parameters ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\t\tparameters = parameters || {};\n\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\t\tvar lights = [];\n\n\t\tvar opaqueObjects = [];\n\t\tvar opaqueObjectsLastIndex = - 1;\n\t\tvar transparentObjects = [];\n\t\tvar transparentObjectsLastIndex = - 1;\n\n\t\tvar morphInfluences = new Float32Array( 8 );\n\n\t\tvar sprites = [];\n\t\tvar lensFlares = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\n\t\t// physical lights\n\n\t\tthis.physicallyCorrectLights = false;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\n\t\t// morphs\n\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\n\t\t// internal properties\n\n\t\tvar _this = this,\n\n\t\t// internal state cache\n\n\t\t_currentProgram = null,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\t\t_currentGeometryProgram = '',\n\t\t_currentCamera = null,\n\n\t\t_currentScissor = new Vector4(),\n\t\t_currentScissorTest = null,\n\n\t\t_currentViewport = new Vector4(),\n\n\t\t//\n\n\t\t_usedTextureUnits = 0,\n\n\t\t//\n\n\t\t_clearColor = new Color( 0x000000 ),\n\t\t_clearAlpha = 0,\n\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\n\t\t_pixelRatio = 1,\n\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\n\t\t// frustum\n\n\t\t_frustum = new Frustum(),\n\n\t\t// clipping\n\n\t\t_clipping = new WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\n\t\t_sphere = new Sphere(),\n\n\t\t// camera matrices cache\n\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_vector3 = new Vector3(),\n\n\t\t// light arrays cache\n\n\t\t_lights = {\n\n\t\t\thash: '',\n\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: [],\n\n\t\t\tshadows: []\n\n\t\t},\n\n\t\t// info\n\n\t\t_infoRender = {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t};\n\n\t\tthis.info = {\n\n\t\t\trender: _infoRender,\n\t\t\tmemory: {\n\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\n\t\t\t},\n\t\t\tprograms: null\n\n\t\t};\n\n\n\t\t// initialize\n\n\t\tvar _gl;\n\n\t\ttry {\n\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t\t}\n\n\t\tvar extensions = new WebGLExtensions( _gl );\n\n\t\textensions.get( 'WEBGL_depth_texture' );\n\t\textensions.get( 'OES_texture_float' );\n\t\textensions.get( 'OES_texture_float_linear' );\n\t\textensions.get( 'OES_texture_half_float' );\n\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\textensions.get( 'OES_standard_derivatives' );\n\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\n\t\t}\n\n\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\tvar properties = new WebGLProperties();\n\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\tvar lightCache = new WebGLLights();\n\n\t\tthis.info.programs = programCache.programs;\n\n\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t\t//\n\n\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t);\n\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\tnew ShaderMaterial( {\n\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tfog: false\n\t\t\t} )\n\t\t);\n\n\t\t//\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\tfunction glClearColor( r, g, b, a ) {\n\n\t\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t}\n\n\t\t\tstate.clearColor( r, g, b, a );\n\n\t\t}\n\n\t\tfunction setDefaultGLState() {\n\n\t\t\tstate.init();\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t}\n\n\t\tfunction resetGLState() {\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\n\t\t\tstate.reset();\n\n\t\t}\n\n\t\tsetDefaultGLState();\n\n\t\tthis.context = _gl;\n\t\tthis.capabilities = capabilities;\n\t\tthis.extensions = extensions;\n\t\tthis.properties = properties;\n\t\tthis.state = state;\n\n\t\t// shadow map\n\n\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\n\t\tthis.shadowMap = shadowMap;\n\n\n\t\t// Plugins\n\n\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t\t};\n\n\t\tthis.getMaxAnisotropy = function () {\n\n\t\t\treturn capabilities.getMaxAnisotropy();\n\n\t\t};\n\n\t\tthis.getPrecision = function () {\n\n\t\t\treturn capabilities.precision;\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t\t};\n\n\t\tthis.getSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\n\t\t\tif ( updateStyle !== false ) {\n\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function () {\n\n\t\t\treturn _clearColor;\n\n\t\t};\n\n\t\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t\t_clearColor.set( color );\n\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn _clearAlpha;\n\n\t\t};\n\n\t\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t\t_clearAlpha = alpha;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\tvar bits = 0;\n\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\n\t\t};\n\n\t\t// Reset\n\n\t\tthis.resetGLState = resetGLState;\n\n\t\tthis.dispose = function() {\n\n\t\t\ttransparentObjects = [];\n\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\topaqueObjects = [];\n\t\t\topaqueObjectsLastIndex = -1;\n\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tresetGLState();\n\t\t\tsetDefaultGLState();\n\n\t\t\tproperties.clear();\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tvar material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\tproperties.delete( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReference( material ) {\n\n\t\t\tvar programInfo = properties.get( material ).program;\n\n\t\t\tmaterial.program = undefined;\n\n\t\t\tif ( programInfo !== undefined ) {\n\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar buffers = properties.get( object );\n\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( object.hasPositions ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasNormals ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t       material.shading === FlatShading ) {\n\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\t\tobject.count = 0;\n\n\t\t};\n\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\t\tsetMaterial( material );\n\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\tvar updateBuffers = false;\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\t\tvar activeInfluences = [];\n\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t\t}\n\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\n\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\n\t\t\t\t}\n\n\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\t\tvar rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\tvar renderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( index );\n\n\t\t\t} else {\n\n\t\t\t\trenderer = bufferRenderer;\n\n\t\t\t}\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar dataCount = 0;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdataCount = index.count;\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\tdataCount = position.count;\n\n\t\t\t}\n\n\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t\tif ( drawCount === 0 ) return;\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t}\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor ( var name in programAttributes ) {\n\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t}\n\n\t\t// Sorting\n\n\t\tfunction absNumericalSort( a, b ) {\n\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\n\t\t\t\treturn a.material.program.id - b.material.program.id;\n\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\t\treturn a.material.id - b.material.id;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn a.z - b.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction reversePainterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// reset caching for this frame\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\tlights.length = 0;\n\n\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\ttransparentObjectsLastIndex = - 1;\n\n\t\t\tsprites.length = 0;\n\t\t\tlensFlares.length = 0;\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\t\tprojectObject( scene, camera );\n\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\t\tsetupShadows( lights );\n\n\t\t\tshadowMap.render( scene, camera );\n\n\t\t\tsetupLights( lights, camera );\n\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t\t//\n\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\trenderTarget = null;\n\n\t\t\t}\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t\t//\n\n\t\t\tvar background = scene.background;\n\n\t\t\tif ( background === null ) {\n\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t\t} else if ( background && background.isColor ) {\n\n\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\tforceClear = true;\n\n\t\t\t}\n\n\t\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t\t}\n\n\t\t\tif ( background && background.isCubeTexture ) {\n\n\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t\tobjects.update( backgroundBoxMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t\t} else if ( background && background.isTexture ) {\n\n\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t\tobjects.update( backgroundPlaneMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.overrideMaterial ) {\n\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t\t} else {\n\n\t\t\t\t// opaque pass (front-to-back order)\n\n\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\t\t// transparent pass (back-to-front order)\n\n\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\n\t\t\t}\n\n\t\t\t// custom render plugins (post pass)\n\n\t\t\tspritePlugin.render( scene, camera );\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t\t}\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.setDepthTest( true );\n\t\t\tstate.setDepthWrite( true );\n\t\t\tstate.setColorWrite( true );\n\n\t\t\t// _gl.finish();\n\n\t\t};\n\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\t\tvar array, index;\n\n\t\t\t// allocate the next position in the appropriate array\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tarray = transparentObjects;\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t\t} else {\n\n\t\t\t\tarray = opaqueObjects;\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t\t}\n\n\t\t\t// recycle existing render item or grow the array\n\n\t\t\tvar renderItem = array[ index ];\n\n\t\t\tif ( renderItem !== undefined ) {\n\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\trenderItem.group = group;\n\n\t\t\t} else {\n\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\n\t\t\t\t// assert( index === array.length );\n\t\t\t\tarray.push( renderItem );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Duplicated code (Frustum)\n\n\t\tfunction isObjectViewable( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSpriteViewable( sprite ) {\n\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSphereViewable( sphere ) {\n\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\t\tif ( numPlanes === 0 ) return true;\n\n\t\t\tvar planes = _this.clippingPlanes,\n\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\n\t\t\tdo {\n\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t\t} while ( ++ i !== numPlanes );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\tlights.push( object );\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isLensFlare ) {\n\n\t\t\t\t\tlensFlares.push( object );\n\n\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tsetMaterial( material );\n\n\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t\t\t}\n\n\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMaterial( material, fog, object ) {\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t} else if ( program.code !== code ) {\n\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\n\t\t\t}\n\n\t\t\tif ( programChange ) {\n\n\t\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\n\t\t\t}\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t       material.clipping === true ) {\n\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t\t}\n\n\t\t\tmaterialProperties.fog = fog;\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t\t}\n\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\t}\n\n\t\tfunction setMaterial( material ) {\n\n\t\t\tmaterial.side === DoubleSide\n\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t: state.enable( _gl.CULL_FACE );\n\n\t\t\tstate.setFlipSided( material.side === BackSide );\n\n\t\t\tmaterial.transparent === true\n\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t: state.setBlending( NoBlending );\n\n\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t}\n\n\t\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t\t_usedTextureUnits = 0;\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tif ( _clippingEnabled ) {\n\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate === false ) {\n\n\t\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate ) {\n\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t_currentProgram = program.id;\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.envMap ) {\n\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t     material.skinning ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t\t}\n\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\n\t\t\tif ( material.skinning ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tif ( material.lights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isMeshDepthMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh single material specific uniforms\n\n\t\t\t\tif ( material.isLineBasicMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t\t}\n\n\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t\t}\n\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// Uniforms (refresh uniforms objects)\n\n\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t\tif ( material.emissive ) {\n\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t}\n\n\t\t\tuniforms.map.value = material.map;\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\tif ( material.aoMap ) {\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\n\t\t\tvar uvScaleMap;\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t} else if ( material.roughnessMap ) {\n\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t\t} else if ( material.metalnessMap ) {\n\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t}\n\n\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t}\n\n\t\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\n\t\t}\n\n\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _height * 0.5;\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tvar offset = material.map.offset;\n\t\t\t\tvar repeat = material.map.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\t\tuniforms.fogColor.value = fog.color;\n\n\t\t\tif ( fog.isFog ) {\n\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif ( material.roughnessMap ) {\n\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.metalnessMap ) {\n\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t\tif ( material.envMap ) {\n\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\t// Lighting\n\n\t\tfunction setupShadows( lights ) {\n\n\t\t\tvar lightShadowsLength = 0;\n\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.shadows.length = lightShadowsLength;\n\n\t\t}\n\n\t\tfunction setupLights( lights, camera ) {\n\n\t\t\tvar l, ll, light,\n\t\t\tr = 0, g = 0, b = 0,\n\t\t\tcolor,\n\t\t\tintensity,\n\t\t\tdistance,\n\t\t\tshadowMap,\n\n\t\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\t\tdirectionalLength = 0,\n\t\t\tpointLength = 0,\n\t\t\tspotLength = 0,\n\t\t\themiLength = 0;\n\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\t\tlight = lights[ l ];\n\n\t\t\t\tcolor = light.color;\n\t\t\t\tintensity = light.intensity;\n\t\t\t\tdistance = light.distance;\n\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\n\t\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t_lights.ambient[ 2 ] = b;\n\n\t\t\t_lights.directional.length = directionalLength;\n\t\t\t_lights.spot.length = spotLength;\n\t\t\t_lights.point.length = pointLength;\n\t\t\t_lights.hemi.length = hemiLength;\n\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t\t}\n\n\t\t// GL state setting\n\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\t\tstate.setCullFace( cullFace );\n\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\n\t\t};\n\n\t\t// Textures\n\n\t\tfunction allocTextureUnit() {\n\n\t\t\tvar textureUnit = _usedTextureUnits;\n\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t\t}\n\n\t\t\t_usedTextureUnits += 1;\n\n\t\t\treturn textureUnit;\n\n\t\t}\n\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTexture = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTexture( texture, slot ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTextureCube = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.getCurrentRenderTarget = function() {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t}\n\n\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\tvar framebuffer;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t\t}\n\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = null;\n\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t\t}\n\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tstate.viewport( _currentViewport );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tvar restore = false;\n\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\trestore = true;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Map three.js constants to WebGL constants\n\n\t\tfunction paramThreeToGL( p ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\n\t\t\tif ( p === HalfFloatType ) {\n\n\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t\t}\n\n\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\n\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t}\n\n\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction FogExp2 ( color, density ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tFogExp2.prototype.clone = function () {\n\n\t\treturn new FogExp2( this.color.getHex(), this.density );\n\n\t};\n\n\tFogExp2.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Fog ( color, near, far ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tFog.prototype.clone = function () {\n\n\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\n\t};\n\n\tFog.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Scene () {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t}\n\n\tScene.prototype = Object.create( Object3D.prototype );\n\n\tScene.prototype.constructor = Scene;\n\n\tScene.prototype.copy = function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t};\n\n\tScene.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlare( texture, size, distance, blending, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.lensFlares = [];\n\n\t\tthis.positionScreen = new Vector3();\n\t\tthis.customUpdateCallback = undefined;\n\n\t\tif ( texture !== undefined ) {\n\n\t\t\tthis.add( texture, size, distance, blending, color );\n\n\t\t}\n\n\t}\n\n\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LensFlare,\n\n\t\tisLensFlare: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\t\tif ( size === undefined ) size = - 1;\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\t\tthis.lensFlares.push( {\n\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\tcolor: color,\t\t// color\n\t\t\t\tblending: blending\t// blending\n\t\t\t} );\n\n\t\t},\n\n\t\t/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\n\t\tupdateLensFlares: function () {\n\n\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\tvar flare;\n\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\n\tfunction SpriteMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\t\tthis.map = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\n\tSpriteMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\n\t\tthis.rotation = source.rotation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Sprite( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Sprite';\n\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t}\n\n\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Sprite,\n\n\t\tisSprite: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\tpoint: this.position,\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LOD() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\n\t}\n\n\n\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LOD,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\t\tvar levels = source.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddLevel: function ( object, distance ) {\n\n\t\t\tif ( distance === undefined ) distance = 0;\n\n\t\t\tdistance = Math.abs( distance );\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\t\tthis.add( object );\n\n\t\t},\n\n\t\tgetObjectForDistance: function ( distance ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tupdate: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar levels = this.levels;\n\n\t\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.levels = [];\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.generateMipmaps  = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n\tDataTexture.prototype = Object.create( Texture.prototype );\n\tDataTexture.prototype.constructor = DataTexture;\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t\tthis.identityMatrix = new Matrix4();\n\n\t\t// copy the bone array\n\n\t\tbones = bones || [];\n\n\t\tthis.bones = bones.slice( 0 );\n\n\t\t// create a bone texture or an array of floats\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\tsize = Math.max( size, 4 );\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t\t}\n\n\t\t// use the supplied bone inverses or calculate the inverses\n\n\t\tif ( boneInverses === undefined ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tObject.assign( Skeleton.prototype, {\n\n\t\tcalculateInverses: function () {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tvar inverse = new Matrix4();\n\n\t\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tvar bone;\n\n\t\t\t// recover the bind-time world matrices\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// compute the local matrices, positions, rotations and scales\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: ( function () {\n\n\t\t\tvar offsetMatrix = new Matrix4();\n\n\t\t\treturn function update() {\n\n\t\t\t\t// flatten bone matrices to array\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclone: function () {\n\n\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Bone( skin ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Bone';\n\n\t\tthis.skin = skin;\n\n\t}\n\n\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Bone,\n\n\t\tisBone: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.skin = source.skin;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = \"attached\";\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\t// init bones\n\n\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t// convenience) for THREE.SkinnedMesh to do this.\n\n\t\tvar bones = [];\n\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\t\tvar bone, gbone;\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tbone = new Bone( this );\n\t\t\t\tbones.push( bone );\n\n\t\t\t\tbone.name = gbone.name;\n\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t}\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.normalizeSkinWeights();\n\n\t\tthis.updateMatrixWorld( true );\n\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n\t}\n\n\n\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\t\tconstructor: SkinnedMesh,\n\n\t\tisSkinnedMesh: true,\n\n\t\tbind: function( skeleton, bindMatrix ) {\n\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif ( bindMatrix === undefined ) {\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tthis.skeleton.pose();\n\n\t\t},\n\n\t\tnormalizeSkinWeights: function () {\n\n\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\n\t\t\t\tvar vec = new Vector4();\n\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrixWorld: function( force ) {\n\n\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function() {\n\n\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\n\tfunction LineBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tLineBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Line( geometry, material, mode ) {\n\n\t\tif ( mode === 1 ) {\n\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new LineSegments( geometry, material );\n\n\t\t}\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Line,\n\n\t\tisLine: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar vStart = new Vector3();\n\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\tvar interRay = new Vector3();\n\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LineSegments( geometry, material ) {\n\n\t\tLine.call( this, geometry, material );\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\t\tconstructor: LineSegments,\n\n\t\tisLineSegments: true\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\n\tfunction PointsMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tPointsMaterial.prototype = Object.create( Material.prototype );\n\tPointsMaterial.prototype.constructor = PointsMaterial;\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tPointsMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Points( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Points,\n\n\t\tisPoints: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new Vector3();\n\n\t\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Group() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Group';\n\n\t}\n\n\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Group\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.generateMipmaps = false;\n\n\t\tvar scope = this;\n\n\t\tfunction update() {\n\n\t\t\trequestAnimationFrame( update );\n\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\t\tscope.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdate();\n\n\t}\n\n\tVideoTexture.prototype = Object.create( Texture.prototype );\n\tVideoTexture.prototype.constructor = VideoTexture;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\tCompressedTexture.prototype.constructor = CompressedTexture;\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\tCanvasTexture.prototype.constructor = CanvasTexture;\n\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t * @author atix / arthursilber.de\n\t */\n\n\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\n\t\t}\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\tDepthTexture.prototype = Object.create( Texture.prototype );\n\tDepthTexture.prototype.constructor = DepthTexture;\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WireframeGeometry( geometry ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar numEdges = 0;\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// Indexed BufferGeometry\n\n\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar numEdges = 0;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\tvar numTris = numEdges / 3;\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ParametricBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// generate vertices and uvs\n\n\t\tvar vertices = [];\n\t\tvar uvs = [];\n\n\t\tvar i, j, p;\n\t\tvar u, v;\n\n\t\tvar sliceCount = slices + 1;\n\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\t\tv = i / stacks;\n\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tu = j / slices;\n\n\t\t\t\tp = func( u, v );\n\t\t\t\tvertices.push( p.x, p.y, p.z );\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tvar indices = [];\n\t\tvar a, b, c, d;\n\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\t\ta = i * sliceCount + j;\n\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t}\n\n\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricGeometry( func, slices, stacks ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tvar vertexBuffer = [];\n\t\tvar uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tappplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\tthis.normalizeNormals();\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tvar cols = Math.pow( 2, detail );\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tvar v = [];\n\n\t\t\tvar i, j;\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tvar rows = cols - i;\n\n\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction appplyRadius( radius ) {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tvar stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\tvar centroid = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tvar azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\t\tvar vertices = [\n\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction TetrahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction OctahedronBufferGeometry( radius,detail ) {\n\n\t\tvar vertices = [\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction OctahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tvar vertices = [\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction IcosahedronGeometry( radius, detail ) {\n\n\t \tGeometry.call( this );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\n\t\tvar vertices = [\n\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t r, - t,  0,     r,  t,  0,\n\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t- t,  0,  r,     t,  0,  r\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\n\tfunction DodecahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t *\n\t */\n\n\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TubeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\ttubularSegments = tubularSegments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\n\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar i, j;\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\t\tvar indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tvar N = frames.normals[ i ];\n\t\t\tvar B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t */\n\n\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = bufferGeometry.tangents;\n\t\tthis.normals = bufferGeometry.normals;\n\t\tthis.binormals = bufferGeometry.binormals;\n\n\t\t// create geometry\n\n\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\tTubeGeometry.prototype.constructor = TubeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar i, j, index = 0, indexOffset = 0;\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar P1 = new Vector3();\n\t\tvar P2 = new Vector3();\n\n\t\tvar B = new Vector3();\n\t\tvar T = new Vector3();\n\t\tvar N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t */\n\n\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\n\t\t// helper variables\n\t\tvar center = new Vector3();\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t\t// uv\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t\t// update offsets\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offset\n\t\t\t\tindexBufferOffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\n\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n\t}\n\n\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusGeometry.prototype.constructor = TorusGeometry;\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar ShapeUtils = {\n\n\t\t// calculate area of the contour polygon\n\n\t\tarea: function ( contour ) {\n\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\n\t\t},\n\n\t\ttriangulate: ( function () {\n\n\t\t\t/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\t\tvar p;\n\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\tvar cx, cy, px, py;\n\n\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// takes in an contour array and returns\n\n\t\t\treturn function triangulate( contour, indices ) {\n\n\t\t\t\tvar n = contour.length;\n\n\t\t\t\tif ( n < 3 ) return null;\n\n\t\t\t\tvar result = [],\n\t\t\t\t\tverts = [],\n\t\t\t\t\tvertIndices = [];\n\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\t\tvar u, v, w;\n\n\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t\t}\n\n\t\t\t\tvar nv = n;\n\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnv --;\n\n\t\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t} )(),\n\n\t\ttriangulateShape: function ( contour, holes ) {\n\n\t\t\tfunction removeDupEndPts(points) {\n\n\t\t\t\tvar l = points.length;\n\n\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\t\tpoints.pop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tremoveDupEndPts( contour );\n\t\t\tholes.forEach( removeDupEndPts );\n\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\n\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t\t// return real intersection point\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t// both segments are points\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t\t// The order of legs is important\n\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t\t// angle != 180 deg.\n\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\tvar hole;\n\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar indepHoles = [];\n\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tindepHoles.push( h );\n\n\t\t\t\t}\n\n\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\t\tcounter --;\n\t\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t\t}\n\n\n\t\t\tvar i, il, f, face,\n\t\t\t\tkey, index,\n\t\t\t\tallPointsMap = {};\n\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t\tvar allpoints = contour.concat();\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t\t}\n\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t\t// prepare all points map\n\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\n\t\t\t\t}\n\n\t\t\t\tallPointsMap[ key ] = i;\n\n\t\t\t}\n\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t\t// check all face vertices against all points map\n\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\t\tface = triangles[ i ];\n\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangles.concat();\n\n\t\t},\n\n\t\tisClockWise: function ( pts ) {\n\n\t\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t\t},\n\n\t\t// Bezier Curves formulas obtained from\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t\t// Quad Bezier Functions\n\n\t\tb2: ( function () {\n\n\t\t\tfunction b2p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p1( t, p ) {\n\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p2( t, p ) {\n\n\t\t\t\treturn t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\t// Cubic Bezier Functions\n\n\t\tb3: ( function () {\n\n\t\t\tfunction b3p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p1( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * k * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p2( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * t * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p3( t, p ) {\n\n\t\t\t\treturn t * t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ExtrudeGeometry( shapes, options ) {\n\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\t\tshapes = [];\n\t\t\treturn;\n\n\t\t}\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\n\t\t//this.computeVertexNormals();\n\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n\t}\n\n\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tvar sl = shapes.length;\n\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\n\t\tvar shapesOffset = this.vertices.length;\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\n\t\t}\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\t\td += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.WorldUVGenerator = {\n\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t];\n\n\t\t},\n\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\t\tvar d = vertices[ indexD ];\n\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\n\tfunction TextGeometry( text, parameters ) {\n\n\t\tparameters = parameters || {};\n\n\t\tvar font = parameters.font;\n\n\t\tif ( (font && font.isFont) === false ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new Geometry();\n\n\t\t}\n\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tExtrudeGeometry.call( this, shapes, parameters );\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\tTextGeometry.prototype.constructor = TextGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * based on THREE.SphereGeometry\n\t */\n\n\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'SphereBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\tvar index = 0, vertices = [], normal = new Vector3();\n\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar verticesRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\t\tvar u = x / widthSegments;\n\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\tverticesRow.push( index );\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvertices.push( verticesRow );\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', positions );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n\t}\n\n\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\tSphereGeometry.prototype.constructor = SphereGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 20;\n\t\touterRadius = outerRadius || 50;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// some helper variables\n\t\tvar index = 0, indexOffset = 0, segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\t// values are generate from the inside of the ring to the outside\n\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex++;\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t}\n\n\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n\t/**\n\t * @author Kaleb Murphy\n\t */\n\n\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n\t}\n\n\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\tRingGeometry.prototype.constructor = RingGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n\t}\n\n\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t // points - to create a closed torus, one must use a set of points\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t // segments - the number of circumference segments to create\n\t // phiStart - the starting radian\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t //    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'LatheBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\tvar indexCount = segments * points.length * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar index = 0, indexOffset = 0, base;\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar i, j;\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tbase = j + i * points.length;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif( phiLength === Math.PI * 2 ) {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new Vector3();\n\t\t\tvar n2 = new Vector3();\n\t\t\tvar n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\tbase = segments * points.length * 3;\n\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t} // next row\n\n\t\t}\n\n\t}\n\n\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\n\t// points - to create a closed torus, one must use a set of points\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t// segments - the number of circumference segments to create\n\t// phiStart - the starting radian\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t//    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\tLatheGeometry.prototype.constructor = LatheGeometry;\n\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t *\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t * ExtrudeGeometry.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t *\n\t *\tmaterial: <int> // material index for front and back faces\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ShapeGeometry( shapes, options ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t}\n\n\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\n\t/**\n\t * Add an array of shapes to THREE.ShapeGeometry.\n\t */\n\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tthis.addShape( shapes[ i ], options );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t */\n\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tif ( options === undefined ) options = {};\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar material = options.material;\n\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t\t//\n\n\t\tvar i, l, hole;\n\n\t\tvar shapesOffset = this.vertices.length;\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\t\thole = holes[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false;\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t// Vertices\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\t\t\tvertices = vertices.concat( hole );\n\n\t\t}\n\n\t\t//\n\n\t\tvar vert, vlen = vertices.length;\n\t\tvar face, flen = faces.length;\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = vertices[ i ];\n\n\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\n\t\t}\n\n\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tvar geometry2;\n\n\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tgeometry2 = new Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry2 = geometry.clone();\n\n\t\t}\n\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\n\t\tvar vertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t\t} else {\n\n\t\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = [];\n\n\t\tfor ( var key in hash ) {\n\n\t\t\tvar h = hash[ key ];\n\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\n\t}\n\n\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CylinderBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tvar scope = this;\n\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\theight = height !== undefined ? height : 100;\n\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t\t// used to calculate buffer length\n\n\t\tvar nbCap = 0;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t\t}\n\n\t\tvar vertexCount = calculateVertexCount();\n\t\tvar indexCount = calculateIndexCount();\n\n\t\t// buffers\n\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\n\t\tvar index = 0,\n\t\t    indexOffset = 0,\n\t\t    indexArray = [],\n\t\t    halfHeight = height / 2;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount() {\n\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction calculateIndexCount() {\n\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction generateTorso() {\n\n\t\t\tvar x, y;\n\t\t\tvar normal = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tvar indexRow = [];\n\n\t\t\t\tvar v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\tindexRow.push( index );\n\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\t\tvar uv = new Vector2();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = 0.5;\n\t\t\t\tuv.y = 0.5;\n\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tcenterIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t}\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\tConeGeometry.prototype.constructor = ConeGeometry;\n\n\t/**\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CircleBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tvar vertices = segments + 2;\n\n\t\tvar positions = new Float32Array( vertices * 3 );\n\t\tvar normals = new Float32Array( vertices * 3 );\n\t\tvar uvs = new Float32Array( vertices * 2 );\n\n\t\t// center data is already zero, but need to set a few extras\n\t\tnormals[ 2 ] = 1.0;\n\t\tuvs[ 0 ] = 0.5;\n\t\tuvs[ 1 ] = 0.5;\n\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\t/**\n\t * @author hughes\n\t */\n\n\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n\t}\n\n\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\tCircleGeometry.prototype.constructor = CircleGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\n\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\tBoxGeometry.prototype.constructor = BoxGeometry;\n\n\n\n\tvar Geometries = Object.freeze({\n\t\tWireframeGeometry: WireframeGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingBufferGeometry,\n\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\tBoxGeometry: BoxGeometry\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ShadowMaterial() {\n\n\t\tShaderMaterial.call( this, {\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t} );\n\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\n\t\tObject.defineProperties( this, {\n\t\t\topacity: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction RawShaderMaterial( parameters ) {\n\n\t\tShaderMaterial.call( this, parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MultiMaterial( materials ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.type = 'MultiMaterial';\n\n\t\tthis.materials = materials instanceof Array ? materials : [];\n\n\t\tthis.visible = true;\n\n\t}\n\n\tMultiMaterial.prototype = {\n\n\t\tconstructor: MultiMaterial,\n\n\t\tisMultiMaterial: true,\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.2,\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\ttype: this.type,\n\t\t\t\tmaterials: []\n\t\t\t};\n\n\t\t\tvar materials = this.materials;\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\tdelete material.metadata;\n\n\t\t\t\toutput.materials.push( material );\n\n\t\t\t}\n\n\t\t\toutput.visible = this.visible;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\tvar material = new this.constructor();\n\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tmaterial.visible = this.visible;\n\n\t\t\treturn material;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshStandardMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\n\tfunction MeshPhysicalMaterial( parameters ) {\n\n\t\tMeshStandardMaterial.call( this );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.reflectivity = source.reflectivity;\n\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshPhongMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshNormalMaterial( parameters ) {\n\n\t\tMaterial.call( this, parameters );\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshLambertMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\n\tfunction LineDashedMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tLineDashedMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t};\n\n\n\n\tvar Materials = Object.freeze({\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMultiMaterial: MultiMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar Cache = {\n\n\t\tenabled: false,\n\n\t\tfiles: {},\n\n\t\tadd: function ( key, file ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[ key ] = file;\n\n\t\t},\n\n\t\tget: function ( key ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[ key ];\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete this.files[ key ];\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.files = {};\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tvar DefaultLoadingManager = new LoadingManager();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction XHRLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( XHRLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\t// Check for data: URI\n\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\tif ( dataUriRegexResult ) {\n\n\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tvar data = dataUriRegexResult[3];\n\n\t\t\t\tdata = window.decodeURIComponent(data);\n\n\t\t\t\tif( isBase64 ) {\n\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar response;\n\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\trequest.open( 'GET', url, true );\n\n\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\tvar response = event.target.response;\n\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( onProgress !== undefined ) {\n\n\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\t\t\tonProgress( event );\n\n\t\t\t\t\t}, false );\n\n\t\t\t\t}\n\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn request;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetResponseType: function ( value ) {\n\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\n\tfunction CompressedTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( CompressedTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar images = [];\n\n\t\t\tvar texture = new CompressedTexture();\n\t\t\ttexture.image = images;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\tvar loaded = 0;\n\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\t\tloadTexture( i );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\n\tvar DataTextureLoader = BinaryTextureLoader;\n\tfunction BinaryTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( BinaryTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new DataTexture();\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\t\tif ( ! texData ) return;\n\n\t\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\t\ttexture.image = texData.image;\n\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\t\ttexture.format = texData.format;\n\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\t\ttexture.type = texData.type;\n\n\t\t\t\t}\n\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t}, onProgress, onError );\n\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ImageLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( ImageLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\timage.onload = function () {\n\n\t\t\t\timage.onload = null;\n\n\t\t\t\tURL.revokeObjectURL( image.src );\n\n\t\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\t\t\timage.onerror = onError;\n\n\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\timage.src = url;\n\n\t\t\t} else {\n\n\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn image;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( CubeTextureLoader.prototype, {\n\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new CubeTexture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\t\tloaded ++;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, undefined, onError );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction TextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( TextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new Texture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( image ) {\n\n\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Light( color, intensity ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\t\tthis.receiveShadow = undefined;\n\n\t}\n\n\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Light,\n\n\t\tisLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\t\tLight.call( this, skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.castShadow = undefined;\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: HemisphereLight,\n\n\t\tisHemisphereLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.groundColor.copy( source.groundColor );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LightShadow( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.matrix = new Matrix4();\n\n\t}\n\n\tObject.assign( LightShadow.prototype, {\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.camera = source.camera.clone();\n\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\n\t\t\tthis.mapSize.copy( source.mapSize );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar object = {};\n\n\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\tdelete object.camera.matrix;\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SpotLightShadow() {\n\n\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t}\n\n\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: SpotLightShadow,\n\n\t\tisSpotLightShadow: true,\n\n\t\tupdate: function ( light ) {\n\n\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || 500;\n\n\t\t\tvar camera = this.camera;\n\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: SpotLight,\n\n\t\tisSpotLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\n\tfunction PointLight( color, intensity, distance, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t}\n\n\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: PointLight,\n\n\t\tisPointLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectionalLightShadow( light ) {\n\n\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: DirectionalLightShadow\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DirectionalLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: DirectionalLight,\n\n\t\tisDirectionalLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AmbientLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t\tthis.castShadow = undefined;\n\n\t}\n\n\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: AmbientLight,\n\n\t\tisAmbientLight: true,\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tvar AnimationUtils = {\n\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function( array, from, to ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t\t}\n\n\t\t\treturn array.slice( from, to );\n\n\t\t},\n\n\t\t// converts an array to a specific type\n\t\tconvertArray: function( array, type, forceClone ) {\n\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\t\treturn new type( array ); // create typed array\n\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t\t},\n\n\t\tisTypedArray: function( object ) {\n\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\n\t\t},\n\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function( times ) {\n\n\t\t\tfunction compareTime( i, j ) {\n\n\t\t\t\treturn times[ i ] - times[ j ];\n\n\t\t\t}\n\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\t\tresult.sort( compareTime );\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function( values, stride, order ) {\n\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t}\n\n\t\t\tif ( key === undefined ) return; // no data\n\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t// ...assume THREE.Math-ish\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\n\tfunction Interpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t}\n\n\tInterpolant.prototype = {\n\n\t\tconstructor: Interpolant,\n\n\t\tevaluate: function( t ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\n\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\tvalidate_interval: {\n\n\t\t\t\tseek: {\n\n\t\t\t\t\tvar right;\n\n\t\t\t\t\tlinear_scan: {\n\t//- See http://jsperf.com/comparison-to-undefined/3\n\t//- slower code:\n\t//-\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t//- slower code:\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t\t} // linear scan\n\n\t\t\t\t\t// binary search\n\n\t\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t\t// check boundary cases, again\n\n\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // seek\n\n\t\t\t\tthis._cachedIndex = i1;\n\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t\t} // validate_interval\n\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t\t},\n\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\n\t\t// --- Protected interface\n\n\t\tDefaultSettings_: {},\n\n\t\tgetSettings_: function() {\n\n\t\t\treturn this.settings || this.DefaultSettings_;\n\n\t\t},\n\n\t\tcopySampleValue_: function( index ) {\n\n\t\t\t// copies a sample value to the result buffer\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// Template methods for derived classes:\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t// implementations shall return this.resultBuffer\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\t// empty\n\n\t\t}\n\n\t};\n\n\tObject.assign( Interpolant.prototype, {\n\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_,\n\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_\n\n\t} );\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction CubicInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = -0;\n\t\tthis._offsetPrev = -0;\n\t\tthis._weightNext = -0;\n\t\tthis._offsetNext = -0;\n\n\t}\n\n\tCubicInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: CubicInterpolant,\n\n\t\tDefaultSettings_: {\n\n\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\n\t\t\tif ( tPrev === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tNext === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\n\t\t},\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\n\t\t\t// evaluate polynomials\n\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t\t// combine data linearly\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction LinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: LinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction DiscreteInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tDiscreteInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: DiscreteInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t}\n\n\t} );\n\n\tvar KeyframeTrackPrototype;\n\n\tKeyframeTrackPrototype = {\n\n\t\tTimeBufferType: Float32Array,\n\t\tValueBufferType: Float32Array,\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new LinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\t\treturn new CubicInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tsetInterpolation: function( interpolation ) {\n\n\t\t\tvar factoryMethod;\n\n\t\t\tswitch ( interpolation ) {\n\n\t\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( factoryMethod === undefined ) {\n\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( message );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\n\t\t},\n\n\t\tgetInterpolation: function() {\n\n\t\t\tswitch ( this.createInterpolant ) {\n\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\t\treturn InterpolateSmooth;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetValueSize: function() {\n\n\t\t\treturn this.values.length / this.times.length;\n\n\t\t},\n\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function( timeOffset ) {\n\n\t\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function( timeScale ) {\n\n\t\t\tif( timeScale !== 1.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function( startTime, endTime ) {\n\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t\t++ to; // inclusive -> exclusive bound\n\n\t\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function() {\n\n\t\t\tvar valid = true;\n\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\n\t\t\t\tnKeys = times.length;\n\n\t\t\tif( nKeys === 0 ) {\n\n\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar prevTime = null;\n\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\t\tvar currTime = times[ i ];\n\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\n\t\t\t}\n\n\t\t\tif ( values !== undefined ) {\n\n\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn valid;\n\n\t\t},\n\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function() {\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\n\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\t\twriteIndex = 1,\n\t\t\t\tlastIndex = times.length - 1;\n\n\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\t\tvar keep = false;\n\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else keep = true;\n\n\t\t\t\t}\n\n\t\t\t\t// in-place compaction\n\n\t\t\t\tif ( keep ) {\n\n\t\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t++ writeIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flush last keyframe (compaction looks ahead)\n\n\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\n\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t\tif ( writeIndex !== times.length ) {\n\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\t\tif( times === undefined || times.length === 0 ) {\n\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t\t}\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t\tthis.validate();\n\t\tthis.optimize();\n\n\t}\n\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tVectorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: VectorKeyframeTrack,\n\n\t\tValueTypeName: 'vector'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction QuaternionLinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tQuaternionLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: QuaternionLinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset = i1 * stride,\n\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: QuaternionKeyframeTrack,\n\n\t\tValueTypeName: 'quaternion',\n\n\t\t// ValueBufferType is inherited\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tNumberKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: NumberKeyframeTrack,\n\n\t\tValueTypeName: 'number',\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tStringKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: StringKeyframeTrack,\n\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction BooleanKeyframeTrack( name, times, values ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\n\t}\n\n\tBooleanKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: BooleanKeyframeTrack,\n\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tColorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: ColorKeyframeTrack,\n\n\t\tValueTypeName: 'color'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\n\t} );\n\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.apply( this, arguments );\n\n\t}\n\n\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\n\t// Static methods:\n\n\tObject.assign( KeyframeTrack, {\n\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\t\tparse: function( json ) {\n\n\t\t\tif( json.type === undefined ) {\n\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t\t}\n\n\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\t\tif ( json.times === undefined ) {\n\n\t\t\t\tvar times = [], values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\n\t\t\t}\n\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\t\treturn trackType.parse( json );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\treturn new trackType(\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function( track ) {\n\n\t\t\tvar trackType = track.constructor;\n\n\t\t\tvar json;\n\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\t\tjson = trackType.toJSON( track );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t\t};\n\n\t\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\n\t\t},\n\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\t\tcase \"scalar\":\n\t\t\t\tcase \"double\":\n\t\t\t\tcase \"float\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"integer\":\n\n\t\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\t\tcase \"vector\":\n\t\t\t\tcase \"vector2\":\n\t\t\t\tcase \"vector3\":\n\t\t\t\tcase \"vector4\":\n\n\t\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\t\tcase \"color\":\n\n\t\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\t\tcase \"quaternion\":\n\n\t\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\t\tcase \"bool\":\n\t\t\t\tcase \"boolean\":\n\n\t\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\t\tcase \"string\":\n\n\t\t\t\t\treturn StringKeyframeTrack;\n\n\t\t\t}\n\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tfunction AnimationClip( name, duration, tracks ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t\tthis.optimize();\n\n\t}\n\n\tAnimationClip.prototype = {\n\n\t\tconstructor: AnimationClip,\n\n\t\tresetDuration: function() {\n\n\t\t\tvar tracks = this.tracks,\n\t\t\t\tduration = 0;\n\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\t\tvar track = this.tracks[ i ];\n\n\t\t\t\tduration = Math.max(\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\n\t\t},\n\n\t\ttrim: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\toptimize: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].optimize();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t// Static methods:\n\n\tObject.assign( AnimationClip, {\n\n\t\tparse: function( json ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t\t},\n\n\n\t\ttoJSON: function( clip ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\n\t\t\tvar json = {\n\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn json;\n\n\t\t},\n\n\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, -1, tracks );\n\n\t\t},\n\n\t\tfindByName: function( objectOrClipArray, name ) {\n\n\t\t\tvar clipArray = objectOrClipArray;\n\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\t\treturn clipArray[ i ];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\t\tvar animationToMorphTargets = {};\n\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar clips = [];\n\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t\t}\n\n\t\t\treturn clips;\n\n\t\t},\n\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function( animation, bones ) {\n\n\t\t\tif ( ! animation ) {\n\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || -1;\n\t\t\tvar fps = animation.fps || 30;\n\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\n\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tracks.length === 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MaterialLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.textures = {};\n\n\t}\n\n\tObject.assign( MaterialLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTextures: function ( value ) {\n\n\t\t\tthis.textures = value;\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar textures = this.textures;\n\n\t\t\tfunction getTexture( name ) {\n\n\t\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn textures[ name ];\n\n\t\t\t}\n\n\t\t\tvar material = new Materials[ json.type ]();\n\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\n\t\t\t// for PointsMaterial\n\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t\t// maps\n\n\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\n\t\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\t\tvar normalScale = json.normalScale;\n\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t\t}\n\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t\t// MultiMaterial\n\n\t\t\tif ( json.materials !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometryLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( BufferGeometryLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar geometry = new BufferGeometry();\n\n\t\t\tvar index = json.data.index;\n\n\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t'Float64Array': Float64Array\n\t\t\t};\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tvar attributes = json.data.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t\t}\n\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif ( groups !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\t\tvar center = new Vector3();\n\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Loader() {\n\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\n\t}\n\n\tLoader.prototype = {\n\n\t\tconstructor: Loader,\n\n\t\tcrossOrigin: undefined,\n\n\t\textractUrlBase: function ( url ) {\n\n\t\t\tvar parts = url.split( '/' );\n\n\t\t\tif ( parts.length === 1 ) return './';\n\n\t\t\tparts.pop();\n\n\t\t\treturn parts.join( '/' ) + '/';\n\n\t\t},\n\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tcreateMaterial: ( function () {\n\n\t\t\tvar color, textureLoader, materialLoader;\n\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\n\t\t\t\t// convert from old material format\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\t\tvar texture;\n\n\t\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\t\treturn uuid;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\n\t\t\t\tfor ( var name in m ) {\n\n\t\t\t\t\tvar value = m[ name ];\n\n\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\t\treturn materialLoader.parse( json );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\tLoader.Handlers = {\n\n\t\thandlers: [],\n\n\t\tadd: function ( regex, loader ) {\n\n\t\t\tthis.handlers.push( regex, loader );\n\n\t\t},\n\n\t\tget: function ( file ) {\n\n\t\t\tvar handlers = this.handlers;\n\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction JSONLoader( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.withCredentials = false;\n\n\t}\n\n\tObject.assign( JSONLoader.prototype, {\n\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tparse: function ( json, texturePath ) {\n\n\t\t\tvar geometry = new Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\t\tparseModel( scale );\n\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tfunction parseModel( scale ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\toffset, zLength,\n\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\n\t\t\t\tnUvLayers = 0;\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseSkin() {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseMorphing( scale ) {\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations() {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t}\n\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\treturn { geometry: geometry };\n\n\t\t\t} else {\n\n\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ObjectLoader ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\n\t}\n\n\tObject.assign( ObjectLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( this.texturePath === '' ) {\n\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tparse: function ( json, onLoad ) {\n\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t} );\n\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\t\tif ( json.animations ) {\n\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t\t}\n\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t},\n\n\t\tparseGeometries: function ( json ) {\n\n\t\t\tvar geometries = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometries;\n\n\t\t},\n\n\t\tparseMaterials: function ( json, textures ) {\n\n\t\t\tvar materials = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tparseAnimations: function ( json ) {\n\n\t\t\tvar animations = [];\n\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\t\tanimations.push( clip );\n\n\t\t\t}\n\n\t\t\treturn animations;\n\n\t\t},\n\n\t\tparseImages: function ( json, onLoad ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\n\t\t\tfunction loadImage( url ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\treturn loader.load( url, function () {\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, undefined, function () {\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\tparseTextures: function ( json, images ) {\n\n\t\t\tfunction parseConstant( value, type ) {\n\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\t\treturn type[ value ];\n\n\t\t\t}\n\n\t\t\tvar textures = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textures;\n\n\t\t},\n\n\t\tparseObject: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\t\tvar object;\n\n\t\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometries[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn materials[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'Scene':\n\n\t\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LOD':\n\n\t\t\t\t\t\tobject = new LOD();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Line':\n\n\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LineSegments':\n\n\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Group':\n\n\t\t\t\t\t\tobject = new Group();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tobject = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t\tobject.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\t\tif ( data.shadow ) {\n\n\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\t\tvar levels = data.levels;\n\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t};\n\n\t\t}()\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTangentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.SplineCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\n\tfunction Curve() {}\n\n\tCurve.prototype = {\n\n\t\tconstructor: Curve,\n\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\t\tgetPointAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t );\n\n\t\t},\n\n\t\t// Get sequence of points using getPoint( t )\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get sequence of points using getPointAt( u )\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get total curve arc length\n\n\t\tgetLength: function () {\n\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\n\t\t},\n\n\t\t// Get list of cumulative segment lengths\n\n\t\tgetLengths: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\t\tif ( this.cacheArcLengths\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\treturn this.cacheArcLengths;\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\n\t\t\tcache.push( 0 );\n\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t\t},\n\n\t\tupdateArcLengths: function() {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\t\tgetUtoTmapping: function ( u, distance ) {\n\n\t\t\tvar arcLengths = this.getLengths();\n\n\t\t\tvar i = 0, il = arcLengths.length;\n\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\t\tif ( distance ) {\n\n\t\t\t\ttargetArcLength = distance;\n\n\t\t\t} else {\n\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t\t}\n\n\t\t\t//var time = Date.now();\n\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\t\tvar low = 0, high = il - 1, comparison;\n\n\t\t\twhile ( low <= high ) {\n\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\t\tlow = i + 1;\n\n\t\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\t\thigh = i - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// DONE\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\treturn t;\n\n\t\t\t}\n\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t\t// determine where we are between the 'before' and 'after' points\n\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t\t// add that fractional amount to t\n\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\t\treturn t;\n\n\t\t},\n\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\t\tgetTangent: function( t ) {\n\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\n\t\t\t// Capping in case of danger\n\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\n\t\t},\n\n\t\tgetTangentAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\n\t\t},\n\n\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\t\tvar normal = new Vector3();\n\n\t\t\tvar tangents = [];\n\t\t\tvar normals = [];\n\t\t\tvar binormals = [];\n\n\t\t\tvar vec = new Vector3();\n\t\t\tvar mat = new Matrix4();\n\n\t\t\tvar i, u, theta;\n\n\t\t\t// compute the tangent vectors for each segment on the curve\n\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\t\tu = i / segments;\n\n\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\ttangents[ i ].normalize();\n\n\t\t\t}\n\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\tvar min = Number.MAX_VALUE;\n\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\t\tif ( tx <= min ) {\n\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( ty <= min ) {\n\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t\t}\n\n\t\t\tif ( tz <= min ) {\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t}\n\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\t\tvec.normalize();\n\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t\t}\n\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\t\tif ( closed === true ) {\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\t\ttheta = - theta;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\t// TODO: Transformation for Curves?\n\n\t/**************************************************************\n\t *\t3D Curves\n\t **************************************************************/\n\n\t// A Factory method for creating new curve subclasses\n\n\tCurve.create = function ( constructor, getPointFunc ) {\n\n\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.getPoint = getPointFunc;\n\n\t\treturn constructor;\n\n\t};\n\n\t/**************************************************************\n\t *\tLine\n\t **************************************************************/\n\n\tfunction LineCurve( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tLineCurve.prototype = Object.create( Curve.prototype );\n\tLineCurve.prototype.constructor = LineCurve;\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tLineCurve.prototype.getPoint = function ( t ) {\n\n\t\tif ( t === 1 ) {\n\n\t\t\treturn this.v2.clone();\n\n\t\t}\n\n\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\treturn point;\n\n\t};\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\n\tLineCurve.prototype.getPointAt = function ( u ) {\n\n\t\treturn this.getPoint( u );\n\n\t};\n\n\tLineCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\t\treturn tangent.normalize();\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\n\tfunction CurvePath() {\n\n\t\tthis.curves = [];\n\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\t\tconstructor: CurvePath,\n\n\t\tadd: function ( curve ) {\n\n\t\t\tthis.curves.push( curve );\n\n\t\t},\n\n\t\tclosePath: function () {\n\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\n\t\t\t// To think about boundaries points.\n\n\t\t\twhile ( i < curveLengths.length ) {\n\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t\t},\n\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\t\tgetLength: function () {\n\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\n\t\t},\n\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\t\tgetCurveLengths: function () {\n\n\t\t\t// We use cache values if curves and cache array are same length\n\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\t\treturn this.cacheLengths;\n\n\t\t\t}\n\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\t\t\tvar lengths = [], sums = 0;\n\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\n\t\t\treturn lengths;\n\n\t\t},\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 40;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tdivisions = divisions || 12;\n\n\t\t\tvar points = [], last;\n\n\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\t\tvar curve = curves[ i ];\n\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t: divisions;\n\n\t\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\n\t\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push( point );\n\t\t\t\t\tlast = point;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\n\t\t/// Generate geometry from path points (for Line or Points objects)\n\n\t\tcreatePointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\t// Generate geometry from equidistant sampling along the path\n\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\tcreateGeometry: function ( points ) {\n\n\t\t\tvar geometry = new Geometry();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**************************************************************\n\t *\tEllipse curve\n\t **************************************************************/\n\n\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation || 0;\n\n\t}\n\n\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\tEllipseCurve.prototype.constructor = EllipseCurve;\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tEllipseCurve.prototype.getPoint = function( t ) {\n\n\t\tvar twoPi = Math.PI * 2;\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\n\t\t\tvar tx = x - this.aX;\n\t\t\tvar ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn new Vector2( x, y );\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar CurveUtils = {\n\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t\t},\n\n\t\t// Puay Bing, thanks for helping with this derivative!\n\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t3 * t * t * p3;\n\n\t\t},\n\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\t// To check if my formulas are correct\n\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\t\treturn h00 + h10 + h01 + h11;\n\n\t\t},\n\n\t\t// Catmull-Rom\n\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t};\n\n\t/**************************************************************\n\t *\tSpline curve\n\t **************************************************************/\n\n\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t}\n\n\tSplineCurve.prototype = Object.create( Curve.prototype );\n\tSplineCurve.prototype.constructor = SplineCurve;\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tSplineCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\treturn new Vector2(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t);\n\n\t};\n\n\t/**************************************************************\n\t *\tCubic Bezier curve\n\t **************************************************************/\n\n\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b3 = ShapeUtils.b3;\n\n\t\treturn new Vector2(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t);\n\n\t};\n\n\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t).normalize();\n\n\t};\n\n\t/**************************************************************\n\t *\tQuadratic Bezier curve\n\t **************************************************************/\n\n\n\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n\n\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b2 = ShapeUtils.b2;\n\n\t\treturn new Vector2(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t);\n\n\t};\n\n\n\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t).normalize();\n\n\t};\n\n\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\t\tfromPoints: function ( vectors ) {\n\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmoveTo: function ( x, y ) {\n\n\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\t},\n\n\t\tlineTo: function ( x, y ) {\n\n\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( x, y );\n\n\t\t},\n\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\t\tvar curve = new SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\t},\n\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t},\n\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\tthis.currentPoint.copy( lastPoint );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\n\tfunction Shape() {\n\n\t\tPath.apply( this, arguments );\n\n\t\tthis.holes = [];\n\n\t}\n\n\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\n\t\tconstructor: Shape,\n\n\t\tgetPointsHoles: function ( divisions ) {\n\n\t\t\tvar holesPts = [];\n\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t\t}\n\n\t\t\treturn holesPts;\n\n\t\t},\n\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\t\textractAllPoints: function ( divisions ) {\n\n\t\t\treturn {\n\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t\t};\n\n\t\t},\n\n\t\textractPoints: function ( divisions ) {\n\n\t\t\treturn this.extractAllPoints( divisions );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t *\n\t **/\n\n\tfunction Path( points ) {\n\n\t\tCurvePath.call( this );\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.fromPoints( points );\n\n\t\t}\n\n\t}\n\n\tPath.prototype = PathPrototype;\n\tPathPrototype.constructor = Path;\n\n\n\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\tfunction ShapePath() {\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\t}\n\n\tShapePath.prototype = {\n\t\tmoveTo: function ( x, y ) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo( x, y );\n\t\t},\n\t\tlineTo: function ( x, y ) {\n\t\t\tthis.currentPath.lineTo( x, y );\n\t\t},\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t},\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t},\n\t\tsplineThru: function ( pts ) {\n\t\t\tthis.currentPath.splineThru( pts );\n\t\t},\n\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\t\tvar shapes = [];\n\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn\tinside;\n\n\t\t\t}\n\n\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\t\tvar subPaths = this.subPaths;\n\t\t\tif ( subPaths.length === 0 ) return [];\n\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\t\tif ( subPaths.length === 1 ) {\n\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\t\tif ( solid ) {\n\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t\t//console.log('cw', i);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t\t//console.log('ccw', i);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tif ( newShapes.length > 1 ) {\n\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar tmpHoles;\n\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Font( data ) {\n\n\t\tthis.data = data;\n\n\t}\n\n\tObject.assign( Font.prototype, {\n\n\t\tisFont: true,\n\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\t\tfunction createPaths( text ) {\n\n\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tvar paths = [];\n\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\toffset += ret.offset;\n\n\t\t\t\t\tpaths.push( ret.path );\n\n\t\t\t\t}\n\n\t\t\t\treturn paths;\n\n\t\t\t}\n\n\t\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\t\tif ( ! glyph ) return;\n\n\t\t\t\tvar path = new ShapePath();\n\n\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\t\tif ( glyph.o ) {\n\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\t\tvar data = this.data;\n\n\t\t\tvar paths = createPaths( text );\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction FontLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( FontLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar font = scope.parse( json );\n\n\t\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\treturn new Font( json );\n\n\t\t}\n\n\t} );\n\n\tvar context;\n\n\tfunction getAudioContext() {\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction AudioLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( AudioLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar context = getAudioContext();\n\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction StereoCamera() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t}\n\n\tObject.assign( StereoCamera.prototype, {\n\n\t\tupdate: ( function () {\n\n\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\n\t\t\tvar eyeRight = new Matrix4();\n\t\t\tvar eyeLeft = new Matrix4();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tinstance = this;\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t\t// translate xOffset\n\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t\t// for left eye\n\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t\t// for right eye\n\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CubeCamera( near, far, cubeResolution ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tvar fov = 90, aspect = 1;\n\n\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t};\n\n\t}\n\n\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\tCubeCamera.prototype.constructor = CubeCamera;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioListener() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = getAudioContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t}\n\n\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: AudioListener,\n\n\t\tgetInput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tremoveFilter: function ( ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.filter;\n\n\t\t},\n\n\t\tsetFilter: function ( value ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t\t} else {\n\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\n\t\t},\n\n\t\tgetMasterVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\t\tsetMasterVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3();\n\n\t\t\tvar orientation = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction Audio( listener ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.context = listener.context;\n\t\tthis.source = this.context.createBufferSource();\n\t\tthis.source.onended = this.onEnded.bind( this );\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.startTime = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis.filters = [];\n\n\t}\n\n\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Audio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tsetNodeSource: function ( audioNode ) {\n\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetBuffer: function ( audioBuffer ) {\n\n\t\t\tthis.source.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\n\t\t\tif ( this.autoplay ) this.play();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tplay: function () {\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar source = this.context.createBufferSource();\n\n\t\t\tsource.buffer = this.source.buffer;\n\t\t\tsource.loop = this.source.loop;\n\t\t\tsource.onended = this.source.onended;\n\t\t\tsource.start( 0, this.startTime );\n\t\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\t\tthis.isPlaying = true;\n\n\t\t\tthis.source = source;\n\n\t\t\treturn this.connect();\n\n\t\t},\n\n\t\tpause: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = 0;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdisconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilters: function () {\n\n\t\t\treturn this.filters;\n\n\t\t},\n\n\t\tsetFilters: function ( value ) {\n\n\t\t\tif ( ! value ) value = [];\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\n\t\t\t} else {\n\n\t\t\t\tthis.filters = value;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.getFilters()[ 0 ];\n\n\t\t},\n\n\t\tsetFilter: function ( filter ) {\n\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t\t},\n\n\t\tsetPlaybackRate: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetPlaybackRate: function () {\n\n\t\t\treturn this.playbackRate;\n\n\t\t},\n\n\t\tonEnded: function () {\n\n\t\t\tthis.isPlaying = false;\n\n\t\t},\n\n\t\tgetLoop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn this.source.loop;\n\n\t\t},\n\n\t\tsetLoop: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.loop = value;\n\n\t\t},\n\n\t\tgetVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\n\t\tsetVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PositionalAudio( listener ) {\n\n\t\tAudio.call( this, listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\t\tconstructor: PositionalAudio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.panner;\n\n\t\t},\n\n\t\tgetRefDistance: function () {\n\n\t\t\treturn this.panner.refDistance;\n\n\t\t},\n\n\t\tsetRefDistance: function ( value ) {\n\n\t\t\tthis.panner.refDistance = value;\n\n\t\t},\n\n\t\tgetRolloffFactor: function () {\n\n\t\t\treturn this.panner.rolloffFactor;\n\n\t\t},\n\n\t\tsetRolloffFactor: function ( value ) {\n\n\t\t\tthis.panner.rolloffFactor = value;\n\n\t\t},\n\n\t\tgetDistanceModel: function () {\n\n\t\t\treturn this.panner.distanceModel;\n\n\t\t},\n\n\t\tsetDistanceModel: function ( value ) {\n\n\t\t\tthis.panner.distanceModel = value;\n\n\t\t},\n\n\t\tgetMaxDistance: function () {\n\n\t\t\treturn this.panner.maxDistance;\n\n\t\t},\n\n\t\tsetMaxDistance: function ( value ) {\n\n\t\t\tthis.panner.maxDistance = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioAnalyser( audio, fftSize ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\tObject.assign( AudioAnalyser.prototype, {\n\n\t\tgetFrequencyData: function () {\n\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\t\treturn this.data;\n\n\t\t},\n\n\t\tgetAverageFrequency: function () {\n\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tvalue += data[ i ];\n\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t\t}\n\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\n\t\tthis._mixBufferRegion = mixFunction;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\tPropertyMixer.prototype = {\n\n\t\tconstructor: PropertyMixer,\n\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function( accuIndex, weight ) {\n\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\t\tif ( currentWeight === 0 ) {\n\n\t\t\t\t// accuN := incoming * weight\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\n\t\t\t} else {\n\n\t\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\n\t\t},\n\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function( accuIndex ) {\n\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tweight = this.cumulativeWeight,\n\n\t\t\t\tbinding = this.binding;\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t\tif ( weight < 1 ) {\n\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t\t}\n\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function() {\n\n\t\t\tvar binding = this.binding;\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toriginalValueOffset = stride * 3;\n\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t},\n\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function() {\n\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t\t},\n\n\n\t\t// mix functions\n\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tif ( t >= 0.5 ) {\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t\t},\n\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tvar s = 1 - t;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tvar j = dstOffset + i;\n\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t}\n\n\tPropertyBinding.prototype = {\n\n\t\tconstructor: PropertyBinding,\n\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\n\t\t},\n\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\n\t\t},\n\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function() {\n\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\t\tthis.node = targetObject;\n\n\t\t\t}\n\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\n\t \t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( objectName ) {\n\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\n\t\t\t\t\tcase 'materials':\n\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\t\tif ( nodeProperty === undefined ) {\n\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t}\n\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\n\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else {\n\n\t\t\t\tthis.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tthis.node = null;\n\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\n\t\t}\n\n\t};\n\n\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function() {},\n\t\t_setValue_unavailable: function() {},\n\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\n\t\tGetterByBindingType: [\n\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\t\tvar source = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t\t}\n\n\t\t],\n\n\t\tSetterByBindingTypeAndVersioning: [\n\n\t\t\t[\n\t\t\t\t// Direct\n\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// EntireArray\n\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// ArrayElement\n\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// HasToFromArray\n\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t]\n\n\t\t]\n\n\t} );\n\n\tPropertyBinding.Composite =\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t};\n\n\tPropertyBinding.Composite.prototype = {\n\n\t\tconstructor: PropertyBinding.Composite,\n\n\t\tgetValue: function( array, offset ) {\n\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t\t},\n\n\t\tsetValue: function( array, offset ) {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].bind();\n\n\t\t\t}\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].unbind();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.create = function( root, path, parsedPath ) {\n\n\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.parseTrackName = function( trackName ) {\n\n\t\t// matches strings in the form of:\n\t\t//    nodeName.property\n\t\t//    nodeName.property[accessor]\n\t\t//    nodeName.material.property[accessor]\n\t\t//    uuid.property[accessor]\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t//    parentName/nodeName.property\n\t\t//    parentName/parentName/nodeName.property[index]\n\t\t//    .bone[Armature.DEF_cog].position\n\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t// created and tested via https://regex101.com/#javascript\n\n\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\tvar matches = re.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t\t}\n\n\t\tvar results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ],\n\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t};\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t};\n\n\tPropertyBinding.findNode = function( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\t\treturn bone;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\t\tif ( bone ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction AnimationObjectGroup( var_args ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t},\n\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t\t};\n\n\t}\n\n\tAnimationObjectGroup.prototype = {\n\n\t\tconstructor: AnimationObjectGroup,\n\n\t\tisAnimationObjectGroup: true,\n\n\t\tadd: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index === undefined ) {\n\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\tremove: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// remove & forget\n\t\tuncache: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\t\tindex = bindings.length;\n\n\t\t\tindicesByPath[ path ] = index;\n\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\n\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\n\t\t},\n\n\t\tunsubscribe_: function( path ) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\n\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = -1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n\t}\n\n\tAnimationAction.prototype = {\n\n\t\tconstructor: AnimationAction,\n\n\t\t// State & Scheduling\n\n\t\tplay: function() {\n\n\t\t\tthis._mixer._activateAction( this );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function() {\n\n\t\t\tthis._mixer._deactivateAction( this );\n\n\t\t\treturn this.reset();\n\n\t\t},\n\n\t\treset: function() {\n\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\n\t\t},\n\n\t\tisRunning: function() {\n\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\t// return true when play has been called\n\t\tisScheduled: function() {\n\n\t\t\treturn this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\tstartAt: function( time ) {\n\n\t\t\tthis._startTime = time;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetLoop: function( mode, repetitions ) {\n\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Weight\n\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function( weight ) {\n\n\t\t\tthis.weight = weight;\n\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\t\treturn this.stopFading();\n\n\t\t},\n\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function() {\n\n\t\t\treturn this._effectiveWeight;\n\n\t\t},\n\n\t\tfadeIn: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t\t},\n\n\t\tfadeOut: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t\t},\n\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\n\t\t\tif( warp ) {\n\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t\t},\n\n\t\tstopFading: function() {\n\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\t\tif ( weightInterpolant !== null ) {\n\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Time Scale Control\n\n\t\t// set the weight stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function() {\n\n\t\t\treturn this._effectiveTimeScale;\n\n\t\t},\n\n\t\tsetDuration: function( duration ) {\n\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\tsyncWith: function( action ) {\n\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\thalt: function( duration ) {\n\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t\t},\n\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstopWarping: function() {\n\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Object Accessors\n\n\t\tgetMixer: function() {\n\n\t\t\treturn this._mixer;\n\n\t\t},\n\n\t\tgetClip: function() {\n\n\t\t\treturn this._clip;\n\n\t\t},\n\n\t\tgetRoot: function() {\n\n\t\t\treturn this._localRoot || this._mixer._root;\n\n\t\t},\n\n\t\t// Interna\n\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t// called by the mixer\n\n\t\t\tvar startTime = this._startTime;\n\n\t\t\tif ( startTime !== null ) {\n\n\t\t\t\t// check for scheduled start of action\n\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t\t}\n\n\t\t\t\t// start\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t\t// apply time scale and advance time\n\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\t\t\tvar weight = this._updateWeight( time );\n\n\t\t\tif ( weight > 0 ) {\n\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_updateWeight: function( time ) {\n\n\t\t\tvar weight = 0;\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\n\t\t},\n\n\t\t_updateTimeScale: function( time ) {\n\n\t\t\tvar timeScale = 0;\n\n\t\t\tif ( ! this.paused ) {\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\n\t\t},\n\n\t\t_updateTime: function( deltaTime ) {\n\n\t\t\tvar time = this.time + deltaTime;\n\n\t\t\tif ( deltaTime === 0 ) return time;\n\n\t\t\tvar duration = this._clip.duration,\n\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\n\t\t\tif ( loop === LoopOnce ) {\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\n\t\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\t\ttime = duration;\n\n\t\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\t\ttime = 0;\n\n\t\t\t\t\t} else break handle_stop;\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t// wrap around\n\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\n\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\n\t\t},\n\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\t\tvar settings = this._interpolantSettings;\n\n\t\t\tif ( pingPong ) {\n\n\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\n\t\t\t} else {\n\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\t\tif ( atStart ) {\n\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t\tif ( atEnd ) {\n\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction AnimationMixer( root ) {\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\t\treturn existingAction;\n\n\t\t\t\t}\n\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t\t}\n\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\t\treturn newAction;\n\n\t\t},\n\n\t\t// get an existing action\n\t\texistingAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function() {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tactions[ i ].reset();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].useCount = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// advance the time and update apply the animation\n\t\tupdate: function( deltaTime ) {\n\n\t\t\tdeltaTime *= this.timeScale;\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t\t// run active actions\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tvar action = actions[ i ];\n\n\t\t\t\tif ( action.enabled ) {\n\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update scene graph\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// return this mixer's root target object\n\t\tgetRoot: function() {\n\n\t\t\treturn this._root;\n\n\t\t},\n\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function( clip ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function( root ) {\n\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( action !== undefined ) {\n\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingByName !== undefined ) {\n\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\t\tif ( action !== null ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// Implementation details:\n\n\tObject.assign( AnimationMixer.prototype, {\n\n\t\t_bindAction: function( action, prototypeAction ) {\n\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingsByName === undefined ) {\n\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t}\n\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t\t}\n\n\t\t},\n\n\t\t_activateAction: function( action ) {\n\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t_deactivateAction: function( action ) {\n\n\t\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Memory manager\n\n\t\t_initMemoryManager: function() {\n\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t// }\n\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\n\t\t\tvar scope = this;\n\n\t\t\tthis.stats = {\n\n\t\t\t\tactions: {\n\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Memory management for AnimationAction objects\n\n\t\t_isActiveAction: function( action ) {\n\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\n\t\t},\n\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip === undefined ) {\n\n\t\t\t\tactionsForClip = {\n\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\n\t\t\t\t};\n\n\t\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t\t} else {\n\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t\t},\n\n\t\t_removeInactiveAction: function( action ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\n\t\t\taction._cacheIndex = null;\n\n\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\n\t\t\taction._byClipCacheIndex = null;\n\n\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\t\tdelete actionByRoot[ rootUuid ];\n\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t},\n\n\t\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendAction: function( action ) {\n\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t\t},\n\n\t\t_takeBackAction: function( action ) {\n\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t\t},\n\n\t\t// Memory management for PropertyMixer objects\n\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( bindingByName === undefined ) {\n\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t\t}\n\n\t\t\tbindingByName[ trackName ] = binding;\n\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\n\t\t},\n\n\t\t_removeInactiveBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\n\t\t\tdelete bindingByName[ trackName ];\n\n\t\t\tremove_empty_map: {\n\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t\t},\n\n\t\t_takeBackBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t\t},\n\n\n\t\t// Memory management of Interpolants for weight and time scale\n\n\t\t_lendControlInterpolant: function() {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\t\tif ( interpolant === undefined ) {\n\n\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t\t}\n\n\t\t\treturn interpolant;\n\n\t\t},\n\n\t\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t\t},\n\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Uniform( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferGeometry() {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\n\t}\n\n\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t};\n\n\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized === true;\n\n\t}\n\n\n\tInterleavedBufferAttribute.prototype = {\n\n\t\tconstructor: InterleavedBufferAttribute,\n\n\t\tisInterleavedBufferAttribute: true,\n\n\t\tget count() {\n\n\t\t\treturn this.data.count;\n\n\t\t},\n\n\t\tget array() {\n\n\t\t\treturn this.data.array;\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBuffer( array, stride ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tInterleavedBuffer.prototype = {\n\n\t\tconstructor: InterleavedBuffer,\n\n\t\tisInterleavedBuffer: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\t\tInterleavedBuffer.call( this, array, stride );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\n\t\tBufferAttribute.call( this, array, itemSize );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\n\tfunction Raycaster( origin, direction, near, far ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tRaycaster.prototype = {\n\n\t\tconstructor: Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Clock( autoStart ) {\n\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tClock.prototype = {\n\n\t\tconstructor: Clock,\n\n\t\tstart: function () {\n\n\t\t\tthis.startTime = ( performance || Date ).now();\n\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\n\t\t},\n\n\t\tgetElapsedTime: function () {\n\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\n\t\t},\n\n\t\tgetDelta: function () {\n\n\t\t\tvar diff = 0;\n\n\t\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\t\tthis.start();\n\n\t\t\t}\n\n\t\t\tif ( this.running ) {\n\n\t\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\n\t\t\t\tthis.elapsedTime += diff;\n\n\t\t\t}\n\n\t\t\treturn diff;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Spline from Tween.js, slightly optimized (and trashed)\n\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t *\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Spline( points ) {\n\n\t\tthis.points = points;\n\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\tpoint, intPoint, weight, w2, w3,\n\t\tpa, pb, pc, pd;\n\n\t\tthis.initFromArray = function ( a ) {\n\n\t\t\tthis.points = [];\n\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getPoint = function ( k ) {\n\n\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\tpd = this.points[ c[ 3 ] ];\n\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\t\treturn v3;\n\n\t\t};\n\n\t\tthis.getControlPointsArray = function () {\n\n\t\t\tvar i, p, l = this.points.length,\n\t\t\t\tcoords = [];\n\n\t\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\t\tp = this.points[ i ];\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t\t}\n\n\t\t\treturn coords;\n\n\t\t};\n\n\t\t// approximate length by summing linear segments\n\n\t\tthis.getLength = function ( nSubDivisions ) {\n\n\t\t\tvar i, index, nSamples, position,\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\toldPosition = new Vector3(),\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tchunkLengths = [],\n\t\t\t\ttotalLength = 0;\n\n\t\t\t// first point has 0 length\n\n\t\t\tchunkLengths[ 0 ] = 0;\n\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\t\tindex = i / nSamples;\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\ttmpVec.copy( position );\n\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\t\toldPosition.copy( position );\n\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\tintPoint = Math.floor( point );\n\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// last point ends with total length\n\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t\t};\n\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\t\tvar i, j,\n\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\trealDistance,\n\t\t\t\tsampling, position,\n\t\t\t\tnewpoints = [],\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tsl = this.getLength();\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t\t}\n\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tthis.points = newpoints;\n\n\t\t};\n\n\t\t// Catmull-Rom\n\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\n\tfunction Spherical( radius, phi, theta ) {\n\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\t\treturn this;\n\n\t}\n\n\tSpherical.prototype = {\n\n\t\tconstructor: Spherical,\n\n\t\tset: function ( radius, phi, theta ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function() {\n\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromVector3: function( vec3 ) {\n\n\t\t\tthis.radius = vec3.length();\n\n\t\t\tif ( this.radius === 0 ) {\n\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t};\n\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\r\n\tfunction MorphBlendMesh( geometry, material ) {\n\r\n\t\tMesh.call( this, geometry, material );\r\n\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\t\tvar name = \"__default\";\r\n\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\r\n\t\tvar fps = numFrames / 1;\r\n\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\r\n\t}\r\n\r\n\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\r\n\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\t\tvar animation = {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\r\n\t\t\tlength: end - start + 1,\r\n\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\r\n\t\t\tactive: false,\r\n\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\r\n\t\t};\r\n\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in frameRanges ) {\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t\t}\r\n\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.weight = weight;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = time;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\t\tvar time = 0;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\ttime = animation.time;\r\n\r\n\t\t}\r\n\r\n\t\treturn time;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\t\tvar duration = - 1;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tduration = animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\treturn duration;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.active = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\t\tif ( ! animation.active ) continue;\r\n\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction ImmediateRenderObject( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.material = material;\n\t\tthis.render = function ( renderCallback ) {};\n\n\t}\n\n\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\n\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\n\tVertexNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\t\tvar faces = objGeometry.faces;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction SpotLightHelper( light ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = [\n\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t0, 0, 0,   0, - 1,   1\n\t\t];\n\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\n\tSpotLightHelper.prototype.dispose = function () {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t};\n\n\tSpotLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar vector2 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkeletonHelper( object ) {\n\n\t\tthis.bones = this.getBoneList( object );\n\n\t\tvar geometry = new Geometry();\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.dynamic = true;\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.root = object;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\n\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\n\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\n\t\tvar boneList = [];\n\n\t\tif ( (object && object.isBone) ) {\n\n\t\t\tboneList.push( object );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t\t}\n\n\t\treturn boneList;\n\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\n\t\tvar geometry = this.geometry;\n\n\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\n\t\tvar boneMatrix = new Matrix4();\n\n\t\tvar j = 0;\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tgeometry.computeBoundingSphere();\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PointLightHelper( light, sphereSize ) {\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\t\tvar d = light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\n\t}\n\n\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\tPointLightHelper.prototype.constructor = PointLightHelper;\n\n\tPointLightHelper.prototype.dispose = function () {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t};\n\n\tPointLightHelper.prototype.update = function () {\n\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t/*\n\t\tvar d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction HemisphereLightHelper( light, sphereSize ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.colors = [ new Color(), new Color() ];\n\n\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t\t}\n\n\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\n\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\tthis.add( this.lightSphere );\n\n\t\tthis.update();\n\n\t}\n\n\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\n\tHemisphereLightHelper.prototype.dispose = function () {\n\n\t\tthis.lightSphere.geometry.dispose();\n\t\tthis.lightSphere.material.dispose();\n\n\t};\n\n\tHemisphereLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction GridHelper( size, divisions, color1, color2 ) {\n\n\t\tdivisions = divisions || 1;\n\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\t\tvar center = divisions / 2;\n\t\tvar step = ( size * 2 ) / divisions;\n\t\tvar vertices = [], colors = [];\n\n\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\n\t\t\tvar color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\tGridHelper.prototype.constructor = GridHelper;\n\n\tGridHelper.prototype.setColors = function () {\n\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\n\t}\n\n\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\n\tFaceNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction DirectionalLightHelper( light, size ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t- size,   size, 0,\n\t\t\t  size,   size, 0,\n\t\t\t  size, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size,   size, 0\n\t\t], 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.add( new Line( geometry, material ) );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.add( new Line( geometry, material ));\n\n\t\tthis.update();\n\n\t}\n\n\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\n\tDirectionalLightHelper.prototype.dispose = function () {\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.geometry.dispose();\n\t\tlightPlane.material.dispose();\n\t\ttargetLine.geometry.dispose();\n\t\ttargetLine.material.dispose();\n\n\t};\n\n\tDirectionalLightHelper.prototype.update = function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar v3 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\n\t\t\tlightPlane.lookAt( v3 );\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t\ttargetLine.lookAt( v3 );\n\t\t\ttargetLine.scale.z = v3.length();\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\tfunction CameraHelper( camera ) {\n\n\t\tvar geometry = new Geometry();\n\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\t\tvar pointMap = {};\n\n\t\t// colors\n\n\t\tvar hexFrustum = 0xffaa00;\n\t\tvar hexCone = 0xff0000;\n\t\tvar hexUp = 0x00aaff;\n\t\tvar hexTarget = 0xffffff;\n\t\tvar hexCross = 0x333333;\n\n\t\t// near\n\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t\t// far\n\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t\t// sides\n\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t\t// cone\n\n\t\taddLine( \"p\", \"n1\", hexCone );\n\t\taddLine( \"p\", \"n2\", hexCone );\n\t\taddLine( \"p\", \"n3\", hexCone );\n\t\taddLine( \"p\", \"n4\", hexCone );\n\n\t\t// up\n\n\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\taddLine( \"u3\", \"u1\", hexUp );\n\n\t\t// target\n\n\t\taddLine( \"c\", \"t\", hexTarget );\n\t\taddLine( \"p\", \"c\", hexCross );\n\n\t\t// cross\n\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\t\tfunction addLine( a, b, hex ) {\n\n\t\t\taddPoint( a, hex );\n\t\t\taddPoint( b, hex );\n\n\t\t}\n\n\t\tfunction addPoint( id, hex ) {\n\n\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\tgeometry.colors.push( new Color( hex ) );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t\t}\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.camera = camera;\n\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\tCameraHelper.prototype.constructor = CameraHelper;\n\n\tCameraHelper.prototype.update = function () {\n\n\t\tvar geometry, pointMap;\n\n\t\tvar vector = new Vector3();\n\t\tvar camera = new Camera();\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\t\tvar points = pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function update() {\n\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\n\t\t\tvar w = 1, h = 1;\n\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t\t// center / target\n\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t\t// near\n\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t\t// far\n\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t\t// up\n\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t\t// cross\n\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\t// a helper to show the world-axis-aligned bounding box for an object\n\n\tfunction BoundingBoxHelper( object, hex ) {\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\t\tthis.object = object;\n\n\t\tthis.box = new Box3();\n\n\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n\t}\n\n\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\n\tBoundingBoxHelper.prototype.update = function () {\n\n\t\tthis.box.setFromObject( this.object );\n\n\t\tthis.box.getSize( this.scale );\n\n\t\tthis.box.getCenter( this.position );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BoxHelper( object, color ) {\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tthis.update( object );\n\n\t\t}\n\n\t}\n\n\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\tBoxHelper.prototype.constructor = BoxHelper;\n\n\tBoxHelper.prototype.update = ( function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function update( object ) {\n\n\t\t\tif ( (object && object.isBox3) ) {\n\n\t\t\t\tbox.copy( object );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromObject( object );\n\n\t\t\t}\n\n\t\t\tif ( box.isEmpty() ) return;\n\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t};\n\n\t} )();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\n\tvar lineGeometry = new BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tObject3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\tArrowHelper.prototype.constructor = ArrowHelper;\n\n\tArrowHelper.prototype.setDirection = ( function () {\n\n\t\tvar axis = new Vector3();\n\t\tvar radians;\n\n\t\treturn function setDirection( dir ) {\n\n\t\t\t// dir is assumed to be normalized\n\n\t\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\t\tradians = Math.acos( dir.y );\n\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t};\n\n\tArrowHelper.prototype.setColor = function ( color ) {\n\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\n\t};\n\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AxisHelper( size ) {\n\n\t\tsize = size || 1;\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t0, 0, 0,  0, 0, size\n\t\t] );\n\n\t\tvar colors = new Float32Array( [\n\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t] );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\tAxisHelper.prototype.constructor = AxisHelper;\n\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\tvar CatmullRomCurve3 = ( function() {\n\n\t\tvar\n\t\t\ttmp = new Vector3(),\n\t\t\tpx = new CubicPoly(),\n\t\t\tpy = new CubicPoly(),\n\t\t\tpz = new CubicPoly();\n\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\n\t\tfunction CubicPoly() {}\n\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\t\tthis.c0 = x0;\n\t\t\tthis.c1 = t0;\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t\t};\n\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\t// initCubicPoly\n\t\t\tthis.init( x1, x2, t1, t2 );\n\n\t\t};\n\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t};\n\n\t\tCubicPoly.prototype.calc = function( t ) {\n\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t\t};\n\n\t\t// Subclass Three.js curve\n\t\treturn Curve.create(\n\n\t\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\t\tthis.points = p || [];\n\t\t\t\tthis.closed = false;\n\n\t\t\t},\n\n\t\t\tfunction ( t ) {\n\n\t\t\t\tvar points = this.points,\n\t\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\t\tl = points.length;\n\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\n\t\t\t\tif ( this.closed ) {\n\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\tweight = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate first point\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\tp0 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate last point\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\tp3 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new Vector3(\n\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\tpz.calc( weight )\n\t\t\t\t);\n\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t);\n\n\t} )();\n\n\t/**************************************************************\n\t *\tClosed Spline 3D curve\n\t **************************************************************/\n\n\n\tfunction ClosedSplineCurve3( points ) {\n\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\n\t}\n\n\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\t/**************************************************************\n\t *\tSpline 3D curve\n\t **************************************************************/\n\n\n\tvar SplineCurve3 = Curve.create(\n\n\t\tfunction ( points /* array of Vector3 */ ) {\n\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\t\treturn new Vector3(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tCubic Bezier 3D curve\n\t **************************************************************/\n\n\tvar CubicBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2, v3 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b3 = ShapeUtils.b3;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tQuadratic Bezier 3D curve\n\t **************************************************************/\n\n\tvar QuadraticBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b2 = ShapeUtils.b2;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tLine3D\n\t **************************************************************/\n\n\tvar LineCurve3 = Curve.create(\n\n\t\tfunction ( v1, v2 ) {\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tif ( t === 1 ) {\n\n\t\t\t\treturn this.v2.clone();\n\n\t\t\t}\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\tvector.multiplyScalar( t );\n\t\t\tvector.add( this.v1 );\n\n\t\t\treturn vector;\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tArc curve\n\t **************************************************************/\n\n\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t}\n\n\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\tArcCurve.prototype.constructor = ArcCurve;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tvar SceneUtils = {\n\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\t\tvar group = new Group();\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t},\n\n\t\tdetach: function ( child, parent, scene ) {\n\n\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\tparent.remove( child );\n\t\t\tscene.add( child );\n\n\t\t},\n\n\t\tattach: function ( child, scene, parent ) {\n\n\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\t\tscene.remove( child );\n\t\t\tparent.add( child );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t}\n\n\tvar LineStrip = 0;\n\n\tvar LinePieces = 1;\n\n\tfunction PointCloud ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction ParticleSystem ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction PointCloudMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleBasicMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleSystemMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction Vertex ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new Vector3( x, y, z );\n\t}\n\n\t//\n\n\tfunction EdgesHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\tfunction WireframeHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\t//\n\n\tObject.assign( Box2.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Box3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Line3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix3.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix4.prototype, {\n\t\textractPosition: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\t\t},\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\treturn vector.applyProjection( this );\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t},\n\t\trotateAxis: function ( v ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\ttranslate: function ( v ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t},\n\t\trotateX: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t},\n\t\trotateY: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t},\n\t\trotateZ: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t},\n\t\trotateByAxis: function ( axis, angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.assign( Plane.prototype, {\n\t\tisIntersectionLine: function ( line ) {\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\t}\n\t} );\n\n\tObject.assign( Quaternion.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\t}\n\t} );\n\n\tObject.assign( Ray.prototype, {\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\n\tObject.assign( Shape.prototype, {\n\t\textrude: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t},\n\t\tmakeGeometry: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\treturn new ShapeGeometry( this, options );\n\t\t}\n\t} );\n\n\tObject.assign( Vector3.prototype, {\n\t\tsetEulerFromRotationMatrix: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Object3D.prototype, {\n\t\tgetChildByName: function ( name ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\t\t},\n\t\trenderDepth: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t}\n\t} );\n\n\tObject.defineProperties( Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( LOD.prototype, {\n\t\tobjects: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\n\t};\n\n\t//\n\n\tObject.defineProperties( Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.assign( BufferGeometry.prototype, {\n\t\taddIndex: function ( index ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\t\t},\n\t\tclearDrawCalls: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\t\t},\n\t\tcomputeTangents: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t},\n\t\tcomputeOffsets: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\tmetal: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tEventDispatcher.prototype = Object.assign( Object.create( {\n\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\t\tconstructor: EventDispatcher,\n\n\t\tapply: function ( target ) {\n\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\t\tObject.assign( target, this );\n\n\t\t}\n\n\t} ), EventDispatcher.prototype );\n\n\t//\n\n\tObject.defineProperties( Uniform.prototype, {\n\t\tdynamic: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t}\n\t\t},\n\t\tonUpdate: {\n\t\t\tvalue: function () {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( WebGLRenderer.prototype, {\n\t\tsupportsFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\t\t\treturn this.capabilities.vertexTextures;\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\t\t},\n\t\tinitMaterial: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t},\n\t\taddPrePlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t},\n\t\taddPostPlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t},\n\t\tupdateShadowMap: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t},\n\t\t\tset: function ( cullFace ) {\n\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\tthis.renderReverseSided = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Audio.prototype, {\n\t\tload: function ( file ) {\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\tscope.setBuffer( buffer );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\n\tObject.assign( AudioAnalyser.prototype, {\n\t\tgetData: function ( file ) {\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\t}\n\t} );\n\n\t//\n\n\tvar GeometryUtils = {\n\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\t\tvar matrix;\n\n\t\t\tif ( geometry2.isMesh ) {\n\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t\t}\n\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t\t},\n\n\t\tcenter: function ( geometry ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\n\t\t}\n\n\t};\n\n\tvar ImageUtils = {\n\n\t\tcrossOrigin: undefined,\n\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\t\tvar loader = new TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\t\tvar loader = new CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadCompressedTexture: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t},\n\n\t\tloadCompressedTextureCube: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Projector () {\n\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\t\tthis.projectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\n\t\t};\n\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\n\t\t};\n\n\t\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t\t};\n\n\t}\n\n\t//\n\n\tfunction CanvasRenderer () {\n\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\n\t}\n\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.ShaderLib = ShaderLib;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.FogExp2 = FogExp2;\n\texports.Fog = Fog;\n\texports.Scene = Scene;\n\texports.LensFlare = LensFlare;\n\texports.Sprite = Sprite;\n\texports.LOD = LOD;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.Skeleton = Skeleton;\n\texports.Bone = Bone;\n\texports.Mesh = Mesh;\n\texports.LineSegments = LineSegments;\n\texports.Line = Line;\n\texports.Points = Points;\n\texports.Group = Group;\n\texports.VideoTexture = VideoTexture;\n\texports.DataTexture = DataTexture;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CubeTexture = CubeTexture;\n\texports.CanvasTexture = CanvasTexture;\n\texports.DepthTexture = DepthTexture;\n\texports.TextureIdCount = TextureIdCount;\n\texports.Texture = Texture;\n\texports.MaterialIdCount = MaterialIdCount;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.TextureLoader = TextureLoader;\n\texports.ObjectLoader = ObjectLoader;\n\texports.MaterialLoader = MaterialLoader;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.LoadingManager = LoadingManager;\n\texports.JSONLoader = JSONLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.FontLoader = FontLoader;\n\texports.XHRLoader = XHRLoader;\n\texports.Loader = Loader;\n\texports.Cache = Cache;\n\texports.AudioLoader = AudioLoader;\n\texports.SpotLightShadow = SpotLightShadow;\n\texports.SpotLight = SpotLight;\n\texports.PointLight = PointLight;\n\texports.HemisphereLight = HemisphereLight;\n\texports.DirectionalLightShadow = DirectionalLightShadow;\n\texports.DirectionalLight = DirectionalLight;\n\texports.AmbientLight = AmbientLight;\n\texports.LightShadow = LightShadow;\n\texports.Light = Light;\n\texports.StereoCamera = StereoCamera;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.CubeCamera = CubeCamera;\n\texports.Camera = Camera;\n\texports.AudioListener = AudioListener;\n\texports.PositionalAudio = PositionalAudio;\n\texports.getAudioContext = getAudioContext;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.Audio = Audio;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.PropertyMixer = PropertyMixer;\n\texports.PropertyBinding = PropertyBinding;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.AnimationUtils = AnimationUtils;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationClip = AnimationClip;\n\texports.Uniform = Uniform;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.BufferGeometry = BufferGeometry;\n\texports.GeometryIdCount = GeometryIdCount;\n\texports.Geometry = Geometry;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.BufferAttribute = BufferAttribute;\n\texports.Face3 = Face3;\n\texports.Object3DIdCount = Object3DIdCount;\n\texports.Object3D = Object3D;\n\texports.Raycaster = Raycaster;\n\texports.Layers = Layers;\n\texports.EventDispatcher = EventDispatcher;\n\texports.Clock = Clock;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.Interpolant = Interpolant;\n\texports.Triangle = Triangle;\n\texports.Spline = Spline;\n\texports.Math = _Math;\n\texports.Spherical = Spherical;\n\texports.Plane = Plane;\n\texports.Frustum = Frustum;\n\texports.Sphere = Sphere;\n\texports.Ray = Ray;\n\texports.Matrix4 = Matrix4;\n\texports.Matrix3 = Matrix3;\n\texports.Box3 = Box3;\n\texports.Box2 = Box2;\n\texports.Line3 = Line3;\n\texports.Euler = Euler;\n\texports.Vector4 = Vector4;\n\texports.Vector3 = Vector3;\n\texports.Vector2 = Vector2;\n\texports.Quaternion = Quaternion;\n\texports.ColorKeywords = ColorKeywords;\n\texports.Color = Color;\n\texports.MorphBlendMesh = MorphBlendMesh;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.VertexNormalsHelper = VertexNormalsHelper;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.PointLightHelper = PointLightHelper;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.GridHelper = GridHelper;\n\texports.FaceNormalsHelper = FaceNormalsHelper;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.CameraHelper = CameraHelper;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.BoxHelper = BoxHelper;\n\texports.ArrowHelper = ArrowHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.SplineCurve3 = SplineCurve3;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.LineCurve3 = LineCurve3;\n\texports.ArcCurve = ArcCurve;\n\texports.EllipseCurve = EllipseCurve;\n\texports.SplineCurve = SplineCurve;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.LineCurve = LineCurve;\n\texports.Shape = Shape;\n\texports.ShapePath = ShapePath;\n\texports.Path = Path;\n\texports.Font = Font;\n\texports.CurvePath = CurvePath;\n\texports.Curve = Curve;\n\texports.ShapeUtils = ShapeUtils;\n\texports.SceneUtils = SceneUtils;\n\texports.CurveUtils = CurveUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.TubeBufferGeometry = TubeBufferGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusBufferGeometry = TorusBufferGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.SphereBufferGeometry = SphereBufferGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.RingBufferGeometry = RingBufferGeometry;\n\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.LatheBufferGeometry = LatheBufferGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.ConeBufferGeometry = ConeBufferGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\texports.CircleBufferGeometry = CircleBufferGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.BoxBufferGeometry = BoxBufferGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.PointsMaterial = PointsMaterial;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.Material = Material;\n\texports.REVISION = REVISION;\n\texports.MOUSE = MOUSE;\n\texports.CullFaceNone = CullFaceNone;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.FrontSide = FrontSide;\n\texports.BackSide = BackSide;\n\texports.DoubleSide = DoubleSide;\n\texports.FlatShading = FlatShading;\n\texports.SmoothShading = SmoothShading;\n\texports.NoColors = NoColors;\n\texports.FaceColors = FaceColors;\n\texports.VertexColors = VertexColors;\n\texports.NoBlending = NoBlending;\n\texports.NormalBlending = NormalBlending;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.CustomBlending = CustomBlending;\n\texports.BlendingMode = BlendingMode;\n\texports.AddEquation = AddEquation;\n\texports.SubtractEquation = SubtractEquation;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.MinEquation = MinEquation;\n\texports.MaxEquation = MaxEquation;\n\texports.ZeroFactor = ZeroFactor;\n\texports.OneFactor = OneFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.NeverDepth = NeverDepth;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.EqualDepth = EqualDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterDepth = GreaterDepth;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.MixOperation = MixOperation;\n\texports.AddOperation = AddOperation;\n\texports.NoToneMapping = NoToneMapping;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.UVMapping = UVMapping;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.TextureMapping = TextureMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.TextureWrapping = TextureWrapping;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.TextureFilter = TextureFilter;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.ByteType = ByteType;\n\texports.ShortType = ShortType;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.IntType = IntType;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.FloatType = FloatType;\n\texports.HalfFloatType = HalfFloatType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.AlphaFormat = AlphaFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBAFormat = RGBAFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.RGBEFormat = RGBEFormat;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LoopPingPong = LoopPingPong;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.LinearEncoding = LinearEncoding;\n\texports.sRGBEncoding = sRGBEncoding;\n\texports.GammaEncoding = GammaEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.CubeGeometry = BoxGeometry;\n\texports.Face4 = Face4;\n\texports.LineStrip = LineStrip;\n\texports.LinePieces = LinePieces;\n\texports.MeshFaceMaterial = MultiMaterial;\n\texports.PointCloud = PointCloud;\n\texports.Particle = Sprite;\n\texports.ParticleSystem = ParticleSystem;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Vertex = Vertex;\n\texports.EdgesHelper = EdgesHelper;\n\texports.WireframeHelper = WireframeHelper;\n\texports.GeometryUtils = GeometryUtils;\n\texports.ImageUtils = ImageUtils;\n\texports.Projector = Projector;\n\texports.CanvasRenderer = CanvasRenderer;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n\tObject.defineProperty( exports, 'AudioContext', {\n\t\tget: function () {\n\t\t\treturn exports.getAudioContext();\n\t\t}\n\t});\n\n})));\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(11),\n  /* template */\n  __webpack_require__(33),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_your_tasteful_component__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_your_tasteful_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_your_tasteful_component__);\n/* eslint-disable */\n\n// your-tasteful-component is an alias to the path of your component\n// for example: vue build component.vue\n// then `your-tasteful-component` is `component.vue`\n\n\nnew __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */]({\n  el: '#app',\n  render: function render(h) {\n    return h(__WEBPACK_IMPORTED_MODULE_1_your_tasteful_component___default.a);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcdnVlLWNsaVxcbGliXFxkZWZhdWx0LWVudHJ5LmVzNiJdLCJuYW1lcyI6WyJWdWUiLCJBcHAiLCJlbCIsInJlbmRlciIsImgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsT0FBT0EsR0FBUCxNQUFnQixLQUFoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IseUJBQWhCOztBQUVBLElBQUlELEdBQUosQ0FBUTtBQUNORSxNQUFJLE1BREU7QUFFTkMsVUFBUTtBQUFBLFdBQUtDLEVBQUVILEdBQUYsQ0FBTDtBQUFBO0FBRkYsQ0FBUiIsImZpbGUiOiJkZWZhdWx0LWVudHJ5LmVzNiIsInNvdXJjZVJvb3QiOiJHOi9kZXYvcmFpbmJvd3NwYWNlIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xuLy8geW91ci10YXN0ZWZ1bC1jb21wb25lbnQgaXMgYW4gYWxpYXMgdG8gdGhlIHBhdGggb2YgeW91ciBjb21wb25lbnRcbi8vIGZvciBleGFtcGxlOiB2dWUgYnVpbGQgY29tcG9uZW50LnZ1ZVxuLy8gdGhlbiBgeW91ci10YXN0ZWZ1bC1jb21wb25lbnRgIGlzIGBjb21wb25lbnQudnVlYFxuaW1wb3J0IEFwcCBmcm9tICd5b3VyLXRhc3RlZnVsLWNvbXBvbmVudCdcblxubmV3IFZ1ZSh7XG4gIGVsOiAnI2FwcCcsXG4gIHJlbmRlcjogaCA9PiBoKEFwcClcbn0pXG4iXX0=\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__viewport_vue__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__viewport_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__viewport_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__settings__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__settings___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__settings__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__viewport_js__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\nvar dataCanvas = document.createElement('canvas');\ndataCanvas.className = 'dataCanvas';\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tcomponents: {\n\t\tViewport: __WEBPACK_IMPORTED_MODULE_2__viewport_vue___default.a,\n\t\tSettings: __WEBPACK_IMPORTED_MODULE_3__settings___default.a\n\t},\n\tdata: function data() {\n\t\treturn {\n\t\t\tshowSidebar: true,\n\t\t\tsettings: __WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */],\n\t\t\tdataCanvas: dataCanvas\n\t\t};\n\t},\n\tmounted: function mounted() {\n\t\tdocument.addEventListener('keydown', this.keyHandler);\n\t\tif (/Mac OS X 10/.test(navigator.userAgent)) {\n\t\t\tdocument.body.parentNode.className += ' disableElasticScrolling';\n\t\t}\n\t},\n\tbeforeDestroy: function beforeDestroy() {\n\t\tdocument.removeEventListener('keydown', this.keyHandler);\n\t},\n\tmethods: {\n\t\tkeyHandler: function keyHandler(keyboardEvent) {\n\t\t\tvar key = '' + keyboardEvent.code + '-' + (0 + keyboardEvent.ctrlKey);\n\t\t\tvar cameraPosition = __WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */].cameraPositionKeymap[key];\n\t\t\tif (cameraPosition) {\n\t\t\t\tif (keyboardEvent.ctrlKey) {\n\t\t\t\t\tkeyboardEvent.preventDefault();\n\t\t\t\t}\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */].cameraPosition = cameraPosition.toLocaleLowerCase();\n\t\t\t}\n\t\t\tif (key === 'Numpad5-0') {\n\t\t\t\tvar mode = __WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */].cameraMode;\n\t\t\t\tvar list = __WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */].cameraModeList;\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_1__state__[\"a\" /* default */].cameraMode = mode === list[0] ? list[1] : list[0];\n\t\t\t}\n\t\t},\n\t\tsettingsToggle: function settingsToggle() {\n\t\t\tthis.showSidebar = !this.showSidebar;\n\t\t\twindow.scrollTo(0, 0);\n\t\t\trequestAnimationFrame(__WEBPACK_IMPORTED_MODULE_4__viewport_js__[\"a\" /* resizeWindowEventHandler */]);\n\t\t}\n\t}\n});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tprops: {\n\t\tcontent: HTMLElement\n\t},\n\tmounted: function mounted() {\n\t\t//what am I doing with my life\n\t\tthis.$el.appendChild(this.content);\n\t}\n});\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixin_input__ = __webpack_require__(2);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tmixins: [__WEBPACK_IMPORTED_MODULE_0__mixin_input__[\"b\" /* buttonMixin */]]\n});\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixin_input__ = __webpack_require__(2);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tprops: {\n\t\tvalue: Boolean\n\t},\n\tmixins: [__WEBPACK_IMPORTED_MODULE_0__mixin_input__[\"a\" /* default */]]\n});\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixin_input__ = __webpack_require__(2);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tmixins: [__WEBPACK_IMPORTED_MODULE_0__mixin_input__[\"a\" /* default */]],\n\tprops: {\n\t\tlist: Array\n\t}\n});\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__input_button__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__input_button___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__input_button__);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tmixins: [__WEBPACK_IMPORTED_MODULE_1__input_button___default.a],\n\tcomputed: {\n\t\tdisplayLabel: function displayLabel() {\n\t\t\tvar check = this.active() ? 'fa-check-square-o' : 'fa-square-o ';\n\t\t\treturn '<i class=\"fa ' + check + '\" aria-hidden=\"true\"></i> ' + this.label;\n\t\t}\n\t},\n\tmethods: {\n\t\tactive: function active() {\n\t\t\treturn __WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */][this.destinationAddress];\n\t\t},\n\t\tclick: function click() {\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */][this.destinationAddress] = !__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */][this.destinationAddress];\n\t\t}\n\t}\n});\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__existing_dom_node__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__existing_dom_node___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__existing_dom_node__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__input_button__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__input_button___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__input_button__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__input_check__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__input_check___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__input_check__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__input_select__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__input_select___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__input_select__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__input_toggle__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__input_toggle___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__input_toggle__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tcomponents: {\n\t\tExistingDomNode: __WEBPACK_IMPORTED_MODULE_1__existing_dom_node___default.a,\n\t\tInputButton: __WEBPACK_IMPORTED_MODULE_2__input_button___default.a,\n\t\tInputCheck: __WEBPACK_IMPORTED_MODULE_3__input_check___default.a,\n\t\tInputSelect: __WEBPACK_IMPORTED_MODULE_4__input_select___default.a,\n\t\tInputToggle: __WEBPACK_IMPORTED_MODULE_5__input_toggle___default.a\n\t},\n\tprops: {\n\t\tsettings: Object,\n\t\tdataCanvas: HTMLCanvasElement\n\t},\n\tmethods: {\n\t\tclearAllImages: function clearAllImages() {\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].imageList = [];\n\t\t},\n\t\tuploadImage: function uploadImage(changeEvent) {\n\t\t\tvar fileList = Array.prototype.slice.call(changeEvent.target.files);\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].scaleImages = this.isMobile();\n\t\t\tfileList.forEach(function (file) {\n\t\t\t\twindow.viewport.vue.readFile(file);\n\t\t\t});\n\t\t},\n\t\tisMobile: function isMobile() {\n\t\t\tvar result = navigator.userAgent.match(/(Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone)/i);\n\t\t\treturn result !== null;\n\t\t}\n\t}\n});\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__state__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewport__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vertifier__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__viewport_js__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tprops: {\n\t\tdataCanvas: HTMLCanvasElement\n\t},\n\tdata: function data() {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tclickable: false\n\t\t};\n\t},\n\tmounted: function mounted() {\n\t\tvar t = this;\n\t\tthis.viewport = new __WEBPACK_IMPORTED_MODULE_1__viewport__[\"b\" /* default */](this.$el, this, this.dataCanvas);\n\t\tvar handleAsFile = function handleAsFile(data) {\n\t\t\tt.readFile(data.getAsFile());\n\t\t};\n\t\tvar searchForImage = function searchForImage(data) {\n\t\t\tdata.getAsString(function (raw) {\n\t\t\t\tvar value = ' ' + raw.replace(/\\n/g, ' ') + ' ';\n\t\t\t\tvar imageTagRegexExec = /.*(\\<img.*?\\>)/i.exec(value);\n\t\t\t\tvar img = imageTagRegexExec && imageTagRegexExec[1] ? imageTagRegexExec[1] : null;\n\t\t\t\tvar srcExec = img ? /src=\"(.*?)\"/i.exec(img) : null;\n\t\t\t\tvar altExec = img ? /alt=\"(.*?)\"/i.exec(img) : null;\n\t\t\t\tvar src = srcExec ? srcExec[1] : null;\n\t\t\t\tvar alt = altExec ? altExec[1] : null;\n\t\t\t\tif (src) {\n\t\t\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].imageList.push({\n\t\t\t\t\t\ttext: alt || src.split('/').pop(),\n\t\t\t\t\t\tvalue: src\n\t\t\t\t\t});\n\t\t\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].image = src;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tvar supportedTypeMap = {\n\t\t\t\"image/png\": handleAsFile,\n\t\t\t\"image/jpeg\": handleAsFile,\n\t\t\t\"image/gif\": handleAsFile,\n\t\t\t\"image/bmp\": handleAsFile,\n\t\t\t\"image/svg+xml\": handleAsFile,\n\t\t\t\"text/html\": searchForImage\n\t\t};\n\t\tthis.handleDrag = function (event) {\n\t\t\tevent.preventDefault();\n\t\t\tconsole.log(event.type);\n\t\t\tif (event.type === 'drop') {\n\t\t\t\tvar itemList = Array.prototype.slice.call(event.dataTransfer.items);\n\t\t\t\tvar anySuitableHandler = false;\n\t\t\t\tvar handleType = function handleType(item) {\n\t\t\t\t\tif (supportedTypeMap.hasOwnProperty(item.type)) {\n\t\t\t\t\t\tvar handler = supportedTypeMap[item.type];\n\t\t\t\t\t\thandler(item);\n\t\t\t\t\t\tanySuitableHandler = true;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\titemList.forEach(handleType);\n\t\t\t\tif (!anySuitableHandler) {\n\t\t\t\t\talert('Sorry, was not able to load that image - still working out all the bugs. Try an image from another source?');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.$el.addEventListener('wheel', this.handleWheel);\n\t\tthis.$el.addEventListener('dragover', this.handleDrag);\n\t\tthis.$el.addEventListener('dragenter', this.handleDrag);\n\t\tthis.$el.addEventListener('drop', this.handleDrag);\n\t},\n\tbeforeMount: function beforeMount() {\n\t\tdocument.addEventListener('resize', __WEBPACK_IMPORTED_MODULE_3__viewport_js__[\"a\" /* resizeWindowEventHandler */]);\n\t\twindow.addEventListener('resize', __WEBPACK_IMPORTED_MODULE_3__viewport_js__[\"a\" /* resizeWindowEventHandler */]);\n\t},\n\tbeforeDestroy: function beforeDestroy() {\n\t\tdocument.removeEventListener('resize', __WEBPACK_IMPORTED_MODULE_3__viewport_js__[\"a\" /* resizeWindowEventHandler */]);\n\t\twindow.removeEventListener('resize', __WEBPACK_IMPORTED_MODULE_3__viewport_js__[\"a\" /* resizeWindowEventHandler */]);\n\t\tthis.$el.removeEventListener('wheel', this.handleWheel);\n\t\tthis.$el.removeEventListener('dragover', this.handleDrag);\n\t\tthis.$el.removeEventListener('dragenter', this.handleDrag);\n\t\tthis.$el.removeEventListener('drop', this.handleDrag);\n\t},\n\tmethods: {\n\t\thandleWheel: function handleWheel(event) {\n\t\t\tthis.viewport.scroll(event.deltaX * 0.001 + event.deltaY * 0.01);\n\t\t},\n\t\treadFile: function readFile(file) {\n\t\t\tvar name = file.name;\n\t\t\tvar nameUnique = ['draggedUp', file.name, file.type, file.size, file.lastModified].join(':');\n\t\t\tvar imageAlreadyLoaded = __WEBPACK_IMPORTED_MODULE_2__vertifier__[\"a\" /* default */].loadedImageMap[nameUnique];\n\t\t\tif (imageAlreadyLoaded) {\n\t\t\t\tconsole.log('file.alreadyLoaded', name);\n\t\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].image = nameUnique;\n\t\t\t} else {\n\t\t\t\tvar reader = new FileReader();\n\t\t\t\treader.onloadend = function (upload) {\n\t\t\t\t\tconsole.log('file.loaded', name);\n\t\t\t\t\tvar image = new Image();\n\t\t\t\t\timage.onload = function () {\n\t\t\t\t\t\tconsole.log('img.loaded', name);\n\t\t\t\t\t\t__WEBPACK_IMPORTED_MODULE_2__vertifier__[\"a\" /* default */].loadedImageMap[nameUnique] = image;\n\t\t\t\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].imageList.push({\n\t\t\t\t\t\t\ttext: name,\n\t\t\t\t\t\t\tvalue: nameUnique\n\t\t\t\t\t\t});\n\t\t\t\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].image = nameUnique;\n\t\t\t\t\t};\n\t\t\t\t\timage.src = upload.target.result;\n\t\t\t\t};\n\t\t\t\treader.readAsDataURL(file);\n\t\t\t}\n\t\t},\n\t\tstart: function start(event) {\n\t\t\tvar x = event.clientX;\n\t\t\tvar y = event.clientY;\n\t\t\tevent.preventDefault();\n\t\t\tif (!this.viewport.dragging) {\n\t\t\t\tif (event.targetTouches) {\n\t\t\t\t\tx = event.targetTouches[0].clientX;\n\t\t\t\t\ty = event.targetTouches[0].clientY;\n\t\t\t\t}\n\t\t\t\tthis.viewport.dragStart(x, y);\n\t\t\t}\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].autoRotateY = false;\n\t\t\t__WEBPACK_IMPORTED_MODULE_0__state__[\"a\" /* default */].autoRotateX = false;\n\t\t},\n\t\tstop: function stop(event) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.viewport.dragStop();\n\t\t},\n\t\tmove: function move(event) {\n\t\t\tif (this.viewport.dragging) {\n\t\t\t\tvar x = event.clientX;\n\t\t\t\tvar y = event.clientY;\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif (event.targetTouches) {\n\t\t\t\t\tx = event.targetTouches[0].clientX;\n\t\t\t\t\ty = event.targetTouches[0].clientY;\n\t\t\t\t}\n\t\t\t\tthis.viewport.dragMove(x, y);\n\t\t\t}\n\t\t}\n\t}\n});\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(18)\n__webpack_require__(17)\n__webpack_require__(19)\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(9),\n  /* template */\n  __webpack_require__(32),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(10),\n  /* template */\n  __webpack_require__(31),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(12),\n  /* template */\n  __webpack_require__(28),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(13),\n  /* template */\n  __webpack_require__(27),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(14),\n  /* template */\n  null,\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(15),\n  /* template */\n  __webpack_require__(30),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(16),\n  /* template */\n  __webpack_require__(29),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"form-group\"\n  }, [_c('label', {\n    attrs: {\n      \"for\": _vm.id\n    }\n  }, [_vm._v(_vm._s(_vm.label))]), _vm._v(\" \"), _c('select', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.internalValue),\n      expression: \"internalValue\"\n    }],\n    staticClass: \"form-control\",\n    attrs: {\n      \"id\": _vm.id\n    },\n    on: {\n      \"change\": [function($event) {\n        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {\n          return o.selected\n        }).map(function(o) {\n          var val = \"_value\" in o ? o._value : o.value;\n          return val\n        });\n        _vm.internalValue = $event.target.multiple ? $$selectedVal : $$selectedVal[0]\n      }, _vm.change]\n    }\n  }, _vm._l((_vm.list), function(option) {\n    return _c('option', {\n      domProps: {\n        \"value\": option.value || option\n      }\n    }, [_vm._v(_vm._s(option.text || option))])\n  }))])\n},staticRenderFns: []}\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"form-check\"\n  }, [_c('label', {\n    staticClass: \"form-check-label\"\n  }, [_c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.internalValue),\n      expression: \"internalValue\"\n    }],\n    staticClass: \"form-check-input\",\n    attrs: {\n      \"type\": \"checkbox\",\n      \"id\": _vm.id\n    },\n    domProps: {\n      \"checked\": Array.isArray(_vm.internalValue) ? _vm._i(_vm.internalValue, null) > -1 : (_vm.internalValue)\n    },\n    on: {\n      \"change\": _vm.change,\n      \"__c\": function($event) {\n        var $$a = _vm.internalValue,\n          $$el = $event.target,\n          $$c = $$el.checked ? (true) : (false);\n        if (Array.isArray($$a)) {\n          var $$v = null,\n            $$i = _vm._i($$a, $$v);\n          if ($$el.checked) {\n            $$i < 0 && (_vm.internalValue = $$a.concat([$$v]))\n          } else {\n            $$i > -1 && (_vm.internalValue = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))\n          }\n        } else {\n          _vm.internalValue = $$c\n        }\n      }\n    }\n  }), _vm._v(\"\\n\\t\\t\" + _vm._s(_vm.label) + \"\\n\\t\")])])\n},staticRenderFns: []}\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('canvas', {\n    staticClass: \"viewport\",\n    class: {\n      clickable: _vm.clickable\n    },\n    attrs: {\n      \"width\": _vm.width,\n      \"height\": _vm.height\n    },\n    on: {\n      \"mousedown\": _vm.start,\n      \"mousemove\": _vm.move,\n      \"mouseup\": _vm.stop,\n      \"mouseout\": _vm.stop,\n      \"touchstart\": _vm.start,\n      \"touchmove\": _vm.move,\n      \"touchend\": _vm.stop\n    }\n  })\n},staticRenderFns: []}\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"card settings\"\n  }, [_c('div', {\n    staticClass: \"card-header\"\n  }, [_vm._v(\"Settings\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"card-body\"\n  }, [_c('existingDomNode', {\n    staticClass: \"dataCanvasHolder\",\n    attrs: {\n      \"content\": _vm.dataCanvas\n    }\n  }), _vm._v(\" \"), _c('form', {\n    attrs: {\n      \"encType\": \"multipart/form-data\"\n    }\n  }, [_c('div', {\n    staticClass: \"form-group no-gutters\"\n  }, [_c('input-select', {\n    attrs: {\n      \"label\": \"Image\",\n      \"list\": _vm.settings.imageList,\n      \"value\": _vm.settings.image,\n      \"destinationAddress\": \"image\"\n    }\n  }), _vm._v(\" \"), _c('button', {\n    staticClass: \"btn btn-primary col-12\",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": _vm.clearAllImages\n    }\n  }, [_vm._v(\"Clear all\")]), _vm._v(\" \"), _c('label', {\n    staticClass: \"btn btn-primary col-12\",\n    attrs: {\n      \"for\": \"uploadImage\"\n    }\n  }, [_vm._v(\"Upload Image\")]), _vm._v(\" \"), _c('input', {\n    staticStyle: {\n      \"display\": \"none\"\n    },\n    attrs: {\n      \"type\": \"file\",\n      \"id\": \"uploadImage\"\n    },\n    on: {\n      \"change\": _vm.uploadImage\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters\"\n  }, [_c('input-select', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Display Method\",\n      \"list\": _vm.settings.displayMethodList,\n      \"value\": _vm.settings.displayMethod,\n      \"destinationAddress\": \"displayMethod\"\n    }\n  }), _vm._v(\" \"), _c('input-toggle', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Show Bounds\",\n      \"destinationAddress\": \"showBounds\"\n    }\n  })], 1), _vm._v(\" \"), _c('hr'), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters\"\n  }, [_c('input-select', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Camera Mode\",\n      \"list\": _vm.settings.cameraModeList,\n      \"value\": _vm.settings.cameraMode,\n      \"destinationAddress\": \"cameraMode\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters col-12\"\n  }, [_c('label', [_vm._v(\"Automatic Rotation\")]), _vm._v(\" \"), _c('div', {\n    attrs: {\n      \"role\": \"group\"\n    }\n  }, [_c('input-toggle', {\n    staticClass: \"col-6\",\n    attrs: {\n      \"label\": \"SpinY\",\n      \"destinationAddress\": \"autoRotateY\"\n    }\n  }), _c('input-toggle', {\n    staticClass: \"col-6\",\n    attrs: {\n      \"label\": \"SpinX\",\n      \"destinationAddress\": \"autoRotateX\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters col-12\"\n  }, [_c('label', [_vm._v(\"Camera Positions\")]), _vm._v(\" \"), _c('div', {\n    attrs: {\n      \"role\": \"group\"\n    }\n  }, _vm._l((_vm.settings.cameraPositionList), function(item) {\n    return _c('input-button', {\n      staticClass: \"col-6 col-lg-3\",\n      attrs: {\n        \"label\": item,\n        \"destinationAddress\": \"cameraPosition\"\n      }\n    })\n  }))]), _vm._v(\" \"), _c('input-select', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Background Color\",\n      \"value\": _vm.settings.backgroundColor,\n      \"list\": _vm.settings.backgroundColorList,\n      \"destinationAddress\": \"backgroundColor\"\n    }\n  })], 1)]), _vm._v(\" \"), _vm._m(0)], 1)])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('h5', [_vm._v(\"RainbowSpace:\"), _c('br'), _vm._v(\"Color Gamut Visualizer\")]), _vm._v(\" \"), _c('p', [_vm._v(\"A project by \"), _c('a', {\n    attrs: {\n      \"href\": \"http://nuclearpixel.com/about/\"\n    }\n  }, [_vm._v(\"Admiral Potato\")]), _vm._v(\".\"), _c('br'), _c('a', {\n    attrs: {\n      \"href\": \"https://github.com/AdmiralPotato/rainbowspace\"\n    }\n  }, [_vm._v(\"Check out the project on GitHub\")]), _vm._v(\" if you have questions, comments, feedback or issues.\")])])\n}]}\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div')\n},staticRenderFns: []}\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"h-100 container-fluid\"\n  }, [_c('div', {\n    staticClass: \"h-100 row\"\n  }, [_c('div', {\n    staticClass: \"h-100 col-12 main\",\n    class: {\n      'col-sm-8 col-xl-9': _vm.showSidebar\n    },\n    style: ({\n      'backgroundColor': 'hsl(0, 0%, ' + _vm.settings.backgroundColor + '%)'\n    })\n  }, [_c('viewport', {\n    attrs: {\n      \"dataCanvas\": _vm.dataCanvas\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    class: {\n      'sidebar h-100 col-12 col-sm-4 col-xl-3': _vm.showSidebar\n    }\n  }, [_c('div', {\n    staticClass: \"settingsToggle\"\n  }, [_c('a', {\n    staticClass: \"icon fa\",\n    class: _vm.showSidebar ? 'fa-times' : 'fa-sliders',\n    on: {\n      \"click\": _vm.settingsToggle\n    }\n  })]), _vm._v(\" \"), (_vm.showSidebar) ? _c('settings', {\n    attrs: {\n      \"settings\": _vm.settings,\n      \"dataCanvas\": _vm.dataCanvas\n    }\n  }) : _vm._e()], 1)])])\n},staticRenderFns: []}\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('button', {\n    staticClass: \"btn\",\n    class: _vm.classObject,\n    attrs: {\n      \"type\": \"button\"\n    },\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.displayLabel)\n    },\n    on: {\n      \"click\": _vm.click\n    }\n  })\n},staticRenderFns: []}\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(8);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// client.ddf2dad5.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 35);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0491c5246d2f421ccacf","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 0\n// module chunks = 0","export default {\n\tautoRotateY: true,\n\tautoRotateX: false,\n\tscaleImages: false,\n\tshowBounds: true,\n\timage: 'http://i.imgur.com/T2lAyjx.png',\n\timageList: [\n\t\t{text: 'RainbowSpace rendered logo', value: 'http://i.imgur.com/SXJ6pGK.png'},\n\t\t{text: 'RainbowSpace painted logo', value: 'http://i.imgur.com/T2lAyjx.png'},\n\t\t{text: 'Triangle - Cyan, Magenta, Yellow', value: 'http://i.imgur.com/7zOi9i3.png'},\n\t\t{text: 'Triangle - Red, Yellow, Blue', value: 'http://i.imgur.com/EUe7UYD.png'},\n\t\t{text: 'Ghost & Candy Corn', value: 'http://i.imgur.com/sdEo3fXl.jpg'},\n\t\t{text: 'Crusader Arts \"Red Room\" Tribute', value: 'http://i.imgur.com/IllmOBYl.jpg'},\n\t\t{text: 'Hexagonal Hard Candy Revisited - Cyan', value: 'http://i.imgur.com/ioYgktml.jpg'},\n\t\t{text: 'Hexagonal Hard Candy Revisited - Purple', value: 'http://i.imgur.com/bvlb8Jhl.jpg'},\n\t\t{text: 'Chocolate Hearts', value: 'http://i.imgur.com/PI9rY1Nl.jpg'},\n\t\t{text: 'Hella Hearts - 4 of 4', value: 'http://i.imgur.com/03Iaigtl.jpg'},\n\t\t{text: 'Aperture Eyes', value: 'http://i.imgur.com/un151Ttl.jpg'},\n\t\t{text: 'Warm Wooden Toy', value: 'http://i.imgur.com/4mUs55cl.jpg'},\n\t\t{text: 'Recursive Trefoil Knot', value: 'http://i.imgur.com/3kasZkCl.jpg'},\n\t\t{text: 'Some Cool Color Chart', value: 'http://i.imgur.com/Mv7BbPWl.jpg'},\n\t\t{text: 'Another Cool Color Chart', value: 'https://c1.staticflickr.com/5/4149/5077374515_c740c2f199_b.jpg'},\n\t\t{text: 'Yet Another Cool Color Chart', value: 'https://c1.staticflickr.com/7/6080/6109196872_61ea600625_z.jpg'},\n\t\t{text: 'aCool Color Chart', value: 'https://c2.staticflickr.com/6/5059/5500526444_baf6909eef_z.jpg'},\n\t\t{text: 'bCool Color Chart', value: 'https://c2.staticflickr.com/2/1563/26702317155_e3c3a9dd71_z.jpg'},\n\t\t{text: 'cCool Color Chart', value: 'https://c2.staticflickr.com/4/3065/2924345262_24dc9d632a_z.jpg?zz=1'},\n\t\t{text: 'DemonPuppy', value: 'https://crossorigin.me/https://github.com/AdmiralPotato/npos3d/raw/master/tests/pn3_files/demonpuppy.png'},\n\t\t{text: 'InterSphere', value: 'https://crossorigin.me/http://nuclearpixel.com/js/npos3d/tests/img/intersphere.png'},\n\t\t{text: 'hsl?', value: 'https://crossorigin.me/http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/01/hsl-color-wheel.png'},\n\t],\n\tdisplayMethod: 'hslSphere',\n\tdisplayMethodList: ['rgbCube', 'hslSphere', 'hslCones', 'hslCylinder', 'hslCube', 'hsvSphere', 'hsvCone', 'hsvCylinder', 'hsvCube'],\n\tcameraMode: 'perspective',\n\tcameraModeList: ['perspective', 'orthographic'],\n\tcameraPosition: 'free',\n\tcameraPositionList: ['Top', 'Front', 'Right', 'WCorner', 'Bottom', 'Back', 'Left', 'BCorner'],\n\tcameraPositionKeymap: {\n\t\t'Numpad7-0': 'Top',\n\t\t'Numpad1-0': 'Front',\n\t\t'Numpad3-0': 'Right',\n\t\t'Numpad0-0': 'WCorner',\n\t\t'Numpad7-1': 'Bottom',\n\t\t'Numpad1-1': 'Back',\n\t\t'Numpad3-1': 'Left',\n\t\t'Numpad0-1': 'BCorner'\n\t},\n\tbackgroundColor: '20',\n\tbackgroundColorList: ['0', '20', '40', '50', '60', '80', '100'],\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/state.js","import Vue from 'vue';\nimport state from './state';\n\nexport default {\n\tdata: function(){\n\t\treturn {\n\t\t\tid: 'inputUnique-' + this._uid,\n\t\t\tinternalValue: this.value\n\t\t}\n\t},\n\tprops: {\n\t\tlabel: String,\n\t\tvalue: String,\n\t\tdestinationAddress: String\n\t},\n\tmethods: {\n\t\tchange: function(){\n\t\t\tVue.set(state, this.destinationAddress, this.internalValue);\n\t\t}\n\t},\n\twatch: {\n\t\tvalue: function (newValue) {\n\t\t\tthis.internalValue = newValue;\n\t\t}\n\t},\n}\n\nexport let buttonMixin = {\n\tdata: function(){\n\t\treturn {\n\t\t\tname: this.label.toLocaleLowerCase()\n\t\t}\n\t},\n\tprops: {\n\t\tlabel: String,\n\t\tdestinationAddress: String\n\t},\n\tcomputed: {\n\t\tclassObject: function () {\n\t\t\tlet active = this.active();\n\t\t\treturn {\n\t\t\t\t'btn-primary': active,\n\t\t\t\t'btn-light': !active,\n\t\t\t}\n\t\t},\n\t\tdisplayLabel: function () {\n\t\t\treturn this.label\n\t\t}\n\t},\n\tmethods: {\n\t\tactive: function () {\n\t\t\treturn state[this.destinationAddress] === this.name;\n\t\t},\n\t\tclick: function () {\n\t\t\tstate[this.destinationAddress] = this.name;\n\t\t}\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixin-input.js","import state from './state';\nimport Vertifier from './vertifier';\nimport * as THREE from 'three';\n\nlet viewportList = [];\nlet Viewport = function(renderCanvas, vueComponentInstance, dataCanvas){\n\tlet p = this;\n\tp.width = 0;\n\tp.height = 0;\n\tp.dragging = false;\n\tp.dragPosLast = new THREE.Vector2();\n\tp.dragDiff = new THREE.Vector2();\n\tp.scene = new THREE.Scene();\n\tp.cameraMap = {\n\t\tperspective: new THREE.PerspectiveCamera(45, 1, 0.1, 1000),\n\t\torthographic: new THREE.OrthographicCamera(0, 0, 0, 0, 0, 1000),\n\t};\n\tp.cameraMap.perspective.position.z = p.cameraMap.orthographic.position.z = 25;\n\tp.orthographicMultiplier = 7;\n\tp.camera = null;\n\tp.cameraPosition = state.cameraPosition;\n\tp.renderer = new THREE.WebGLRenderer({\n\t\tcanvas: renderCanvas,\n\t\tantialias: true,\n\t\talpha: true\n\t});\n\tp.canvas = renderCanvas;\n\tp.vue = vueComponentInstance;\n\n\tp.ambientLight = new THREE.AmbientLight(0xffffff);\n\tp.scene.add(p.ambientLight);\n\n\tlet radialSegments = 24;\n\tlet openEnds = false;\n\tp.boundingGeometry = {\n\t\tCone: new THREE.ConeGeometry(0.5, -1, radialSegments, 0, openEnds),\n\t\tCones: new THREE.SphereGeometry(0.5, radialSegments, 2),\n\t\tCube: new THREE.BoxGeometry(1, 1, 1),\n\t\tCylinder: new THREE.CylinderGeometry(0.5, 0.5, 1, radialSegments, 1, openEnds),\n\t\tSphere: new THREE.SphereGeometry(0.5, radialSegments, radialSegments / 2)\n\t};\n\tp.boundsMaterial = new THREE.MeshBasicMaterial();\n\tp.boundsMaterial.wireframe = true;\n\tp.boundsMaterial.opacity = 0.2;\n\tp.boundsMaterial.color.setHSL(0,0,0.5);\n\tp.boundsMaterial.transparent = true;\n\tp.bounds = new THREE.Mesh(undefined, p.boundsMaterial);\n\tp.bounds.scale.setScalar(1.05);\n\tp.origin = new THREE.Object3D();\n\tp.origin.scale.setScalar(10);\n\tp.origin.rotation.x = Math.PI / 6;\n\tp.origin.add(p.bounds);\n\tp.scene.add(p.origin);\n\n\tp.vertifier = new Vertifier({\n\t\timageUrl: state.image,\n\t\tcallback: function(){\n\t\t\t//not quite sure why this doesn't work unless I add it after the image load\n\t\t\tp.origin.remove(p.vertifier.particleSystem);\n\t\t\tp.origin.add(p.vertifier.particleSystem);\n\t\t},\n\t\tdataCanvas: dataCanvas\n\t});\n\n\tp.grid = new THREE.GridHelper( 200, 20 );\n\tp.grid.position.y = -50;\n\tp.grid.material.opacity = 0.5;\n\tp.grid.material.transparent = true;\n\tp.grid.material.wireframeLinewidth = 20;\n\tp.scene.add( p.grid );\n\n\tp.sizeWindow();\n\tviewportList.push(p);\n\twindow.viewport = p;\n};\n\nViewport.prototype = {\n\tcameraPositionMap: {\n\t\ttop:     [       Math.PI / 2,                0, 0 ],\n\t\tfront:   [                 0,                0, 0 ],\n\t\tright:   [                 0,     -Math.PI / 2, 0 ],\n\t\twcorner: [  Math.PI / 5.1043,     -Math.PI / 4, 0 ],\n\t\tbottom:  [      -Math.PI / 2,                0, 0 ],\n\t\tback:    [                 0,         -Math.PI, 0 ],\n\t\tleft:    [                 0,      Math.PI / 2, 0 ],\n\t\tbcorner: [ -Math.PI / 5.1043,  3 * Math.PI / 4, 0 ]\n\t},\n\tsizeWindow: function () {\n\t\tlet p = this;\n\t\tlet ratio = window.devicePixelRatio || 1;\n\t\tp.width = p.canvas.clientWidth * ratio;\n\t\tp.height = p.canvas.clientHeight * ratio;\n\t\tp.vue.width = p.width;\n\t\tp.vue.height = p.height;\n\n\t\tp.cameraMap.perspective.aspect = p.width / p.height;\n\t\tp.cameraMap.perspective.updateProjectionMatrix();\n\t\tp.updateOrthographicCameraScale();\n\t\t//p.renderer.setPixelRatio(ratio);\n\t\tp.renderer.setViewport(0, 0, p.width, p.height);\n\t},\n\tupdateOrthographicCameraScale: function(){\n\t\tlet p = this;\n\t\tlet orthographicScale = p.orthographicMultiplier / Math.min(p.width, p.height);\n\t\tlet oWidth = p.width * orthographicScale;\n\t\tlet oHeight = p.height * orthographicScale;\n\t\tp.cameraMap.orthographic.right  =  oWidth;\n\t\tp.cameraMap.orthographic.left   = -oWidth;\n\t\tp.cameraMap.orthographic.top    =  oHeight;\n\t\tp.cameraMap.orthographic.bottom = -oHeight;\n\t\tp.cameraMap.orthographic.updateProjectionMatrix();\n\t},\n\trender: function (time) {\n\t\tlet p = this;\n\t\tif(state.autoRotateY) {p.origin.rotation.y += 0.005;}\n\t\tif(state.autoRotateX) {p.origin.rotation.x += 0.005;}\n\t\tif(state.cameraPosition !== 'free' && state.cameraPosition !== p.cameraPosition){\n\t\t\tstate.autoRotateY = false;\n\t\t\tstate.autoRotateX = false;\n\t\t\tp.cameraPosition = state.cameraPosition;\n\t\t\tp.origin.rotation.fromArray(p.cameraPositionMap[p.cameraPosition]);\n\t\t}\n\t\tif(p.dragging){\n\t\t\tp.origin.rotation.x += p.dragDiff.y * -0.01;\n\t\t\tp.origin.rotation.y += p.dragDiff.x * -0.01;\n\t\t\tp.dragDiff.set(0, 0);\n\t\t}\n\n\t\tp.camera = p.cameraMap[state.cameraMode];\n\t\tif(p.vertifier.imageUrl !== state.image){\n\t\t\tp.vertifier.loadImage(state.image);\n\t\t}\n\t\tif(p.vertifier.mapMethodName !== state.displayMethod){\n\t\t\tlet geomName = state.displayMethod.slice(3);\n\t\t\tlet boundingGeom = p.boundingGeometry[geomName];\n\t\t\tif(boundingGeom){\n\t\t\t\tp.bounds.geometry = boundingGeom;\n\t\t\t}\n\t\t\tp.vertifier.mapColorsToVerts(state.displayMethod);\n\t\t}\n\t\tp.bounds.visible = state.showBounds;\n\t\tp.renderer.render(p.scene, p.camera);\n\t},\n\tdragStart: function(x, y){\n\t\tlet p = this;\n\t\tp.dragging = true;\n\t\tp.dragPosLast.set(x, y);\n\t\tp.cameraPosition = state.cameraPosition = 'free';\n\t},\n\tdragMove: function(x, y){\n\t\tlet p = this;\n\t\tlet current = new THREE.Vector2(x, y);\n\t\tp.dragDiff = p.dragPosLast.clone().sub(current);\n\t\tp.dragPosLast.set(x, y);\n\t},\n\tdragStop: function(){\n\t\tlet p = this;\n\t\tp.dragging = false;\n\t\tp.dragDiff.set(0, 0);\n\t},\n\tscroll: function(num){\n\t\tthis.cameraMap.perspective.position.z = Math.max(\n\t\t\tthis.cameraMap.perspective.position.z + num,\n\t\t\t-1.5\n\t\t);\n\t\tthis.orthographicMultiplier = Math.max(\n\t\t\tthis.orthographicMultiplier + num * 0.25,\n\t\t\t0.025\n\t\t);\n\t\tthis.updateOrthographicCameraScale();\n\t}\n};\n\nexport let resizeWindowEventHandler = function () {\n\tviewportList.forEach(function (item) {\n\t\titem.sizeWindow();\n\t});\n};\nlet renderAllViews = function (time) {\n\t\tviewportList.forEach(function (item) {\n\t\t\titem.render(time);\n\t\t});\n\t};\n\nlet go = true,\n\tstart = function(){\n\t\tgo = true;\n\t\trequestAnimationFrame(render);\n\t},\n\tstop = function(){\n\t\tgo = false;\n\t};\n\nlet render = function (time){\n\tif(go){\n\t\trequestAnimationFrame(render);\n\t}\n\trenderAllViews(time);\n};\n\nstart();\n\nexport default Viewport;\n\n\n\n// WEBPACK FOOTER //\n// ./src/viewport.js","/*!\n * Vue.js v2.4.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(val);\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\n\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this) : parentVal\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn.call(this, parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (parentVal, childVal) {\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeInject(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode, deep) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  if (deep && vnode.children) {\n    cloned.children = cloneVNodes(vnode.children);\n  }\n  return cloned\n}\n\nfunction cloneVNodes (vnodes, deep) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i], deep);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  var plain = !(passive || once$$1 || capture);\n  return {\n    name: name,\n    plain: plain,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\n// #6552\nfunction prioritizePlainEvents (a, b) {\n  return a.plain ? -1 : b.plain ? 1 : 0\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  var toAdd = [];\n  var hasModifier = false;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!event.plain) { hasModifier = true; }\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      event.handler = cur;\n      toAdd.push(event);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  if (toAdd.length) {\n    if (hasModifier) { toAdd.sort(prioritizePlainEvents); }\n    for (var i = 0; i < toAdd.length; i++) {\n      var event$1 = toAdd[i];\n      add(event$1.name, event$1.handler, event$1.once, event$1.capture, event$1.passive);\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (comp.__esModule && comp.default) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$off(event[i], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    if (fn) {\n      // specific handler\n      var cb;\n      var i$1 = cbs.length;\n      while (i$1--) {\n        cb = cbs[i$1];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i$1, 1);\n          break\n        }\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction checkOptionType (vm, name) {\n  var option = vm.$options[name];\n  if (!isPlainObject(option)) {\n    warn(\n      (\"component option \\\"\" + name + \"\\\" should be an object.\"),\n      vm\n    );\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : userDef;\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n        ? Reflect.ownKeys(inject).filter(function (key) {\n          /* istanbul ignore next */\n          return Object.getOwnPropertyDescriptor(inject, key).enumerable\n        })\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (process.env.NODE_ENV !== 'production' && !source) {\n        warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || emptyObject,\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    warn(\n      'Avoid using non-primitive value as key, ' +\n      'use string/number value instead.',\n      context\n    );\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(ours, existing) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // if the parent didn't update, the slot nodes will be the ones from\n      // last render. They need to be cloned to ensure \"freshness\" for this render.\n      for (var key in vm.$slots) {\n        var slot = vm.$slots[key];\n        if (slot._rendered) {\n          vm.$slots[key] = cloneVNodes(slot, true /* deep */);\n        }\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n  Vue.prototype._g = bindObjectListeners;\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp, Array];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.4.4';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\n\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.elm = elm;\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed\n              ) {\n                bailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed\n              ) {\n                bailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\n\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\n\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar str;\nvar index$1;\n\n/*  */\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number) {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$options._renderChildren;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n    config.productionTip !== false &&\n    inBrowser && typeof console !== 'undefined'\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\nexport default Vue$3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.runtime.esm.js\n// module id = 4\n// module chunks = 0","import state from './state';\nimport * as THREE from 'three';\n\nlet Vertifier = function (args) {\n\tlet t = this;\n\tt.imageUrl = args.imageUrl || console.break('MISSING IMAGE URL');\n\tt.callback = args.callback || console.break('MISSING CALLBACK');\n\tt.dataCanvas = args.dataCanvas || document.createElement('canvas');\n\tt.mapMethodName = args.mapMethodName || 'rgbCube';\n\n\tt.loader = new THREE.TextureLoader();\n\tt.vertexGeom = new THREE.Geometry();\n\tt.vertexMaterial = new THREE.PointsMaterial({\n\t\tsize: 5 * window.devicePixelRatio,\n\t\tsizeAttenuation: false,\n\t\tvertexColors: THREE.VertexColors\n\t});\n\tt.particleSystem = new THREE.Points(\n\t\tt.vertexGeom,\n\t\tt.vertexMaterial\n\t);\n\tt.loadImage();\n};\n\nVertifier.loadedImageMap = {};\nVertifier.loadedGeomMap = {};\n\nVertifier.prototype = {\n\tcrossOriginProxy: 'http://crossorigin.me/',\n\tloadImage: function(imageUrl, tryWithCrossOrigin){\n\t\tlet t = this;\n\t\tlet imageKey = t.imageUrl = imageUrl || t.imageUrl; //TODO: brain better later. force lexical capturing now.\n\t\tlet origin = tryWithCrossOrigin ? t.crossOriginProxy : '';\n\t\tlet image = Vertifier.loadedImageMap[imageKey];\n\t\tlet geometry = Vertifier.loadedGeomMap[imageKey];\n\t\tif(image && geometry){\n\t\t\tconsole.log('Vertifier.loadImage: using already loaded ' + imageKey);\n\t\t\tt.swapGeometry(geometry);\n\t\t} else if (image && !geometry) {\n\t\t\tgeometry = Vertifier.loadedGeomMap[imageKey] = t.makeGeometryFromImage(image);\n\t\t\tt.swapGeometry(geometry);\n\t\t} else {\n\t\t\tt.loader.load(\n\t\t\t\torigin + imageKey,\n\t\t\t\tfunction (texture) {\n\t\t\t\t\tconsole.log('Vertifier.loadImage: finished loading ' + imageKey);\n\t\t\t\t\timage = Vertifier.loadedImageMap[imageKey] = texture.image;\n\t\t\t\t\tgeometry = Vertifier.loadedGeomMap[imageKey] = t.makeGeometryFromImage(image);\n\t\t\t\t\tt.swapGeometry(geometry);\n\t\t\t\t},\n\t\t\t\tt.loadProgress,\n\t\t\t\tfunction(xhr){\n\t\t\t\t\tif(!tryWithCrossOrigin){\n\t\t\t\t\t\tt.loadImage(imageUrl, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.loadFailure(xhr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t},\n\timageSourceToCanvas: function (source, canvas, x, y){\n\t\tlet width = x || source.width;\n\t\tlet height = y || source.height;\n\t\tlet canvasContext = canvas.getContext('2d');\n\t\tcanvasContext.imageSmoothingEnabled = true;\n\t\tif(state.scaleImages){\n\t\t\tlet shrank = this.calculateAspectRatioFit(width, height, 256, 256);\n\t\t\twidth = shrank.width;\n\t\t\theight = shrank.height;\n\t\t\tstate.scaleImages = false;\n\t\t}\n\t\tcanvas.width = 0;\n\t\tcanvas.height = 0;\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\tcanvasContext.drawImage(source, 0, 0, width, height);\n\t\treturn canvasContext;\n\t},\n\tcalculateAspectRatioFit: function(srcWidth, srcHeight, maxWidth, maxHeight) {\n\t\tlet ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);\n\t\treturn { width: srcWidth*ratio, height: srcHeight*ratio };\n\t},\n\tmakeGeometryFromImage: function (image) {\n\t\tlet t = this;\n\t\tlet width = image.width;\n\t\tlet height = image.height;\n\t\tlet duplicateColorMap = {};\n\t\tlet colors = [];\n\t\tlet color;\n\t\tlet rgbString;\n\t\tlet offset;\n\t\tlet r, g, b, a;\n\t\tlet numPixels = width * height;\n\t\tlet dataCanvas = document.createElement('canvas');\n\t\tlet context = t.imageSourceToCanvas(image, dataCanvas, width, height);\n\t\tlet data = context.getImageData(0, 0, width, height).data;\n\t\tlet vertexGeom = new THREE.Geometry();\n\t\tfor (let i = 0; i < numPixels; i++) {\n\t\t\toffset = i * 4;\n\t\t\tr = data[offset];\n\t\t\tg = data[offset + 1];\n\t\t\tb = data[offset + 2];\n\t\t\ta = data[offset + 3];\n\t\t\trgbString = 'rgba(' + r + ',' + g + ',' + b + ')';\n\t\t\tif (!duplicateColorMap[rgbString] && a > 192) {\n\t\t\t\tcolor = new THREE.Color(rgbString);\n\t\t\t\tcolors.push(color);\n\t\t\t}\n\t\t\tduplicateColorMap[rgbString] = true;\n\t\t}\n\t\tvertexGeom.colors = colors;\n\t\tvertexGeom.colorsNeedUpdate = true;\n\t\tvertexGeom.dataCanvas = dataCanvas;\n\t\treturn vertexGeom;\n\t},\n\tswapGeometry(vertexGeom){\n\t\tlet t = this;\n\t\tt.vertexGeom = vertexGeom;\n\t\tt.imageSourceToCanvas(t.vertexGeom.dataCanvas, t.dataCanvas);\n\t\tif(t.vertexGeom.lastMapping !== t.mapMethodName){\n\t\t\tt.mapColorsToVerts();\n\t\t}\n\t\tt.particleSystem.geometry = t.vertexGeom = vertexGeom;\n\t\tt.callback(t);\n\t},\n\tloadProgress: function (xhr) {\n\t\tconsole.log((xhr.loaded / xhr.total * 100) + '% loaded');\n\t},\n\tloadFailure: function (xhr) {\n\t\tconsole.log('An error happened', xhr);\n\t\talert('Sorry, was not able to load that image - still working out all the bugs. Try an image from another source?');\n\t},\n\tmapColorsToVerts: function (mapMethodName) {\n\t\tlet t = this;\n\t\tt.mapMethodName = mapMethodName || t.mapMethodName;\n\t\tt.vertexGeom.vertices = t.vertexGeom.colors.map(t.mapNormalizedRGBTo[t.mapMethodName]);\n\t\tt.vertexGeom.verticesNeedUpdate = true;\n\t\tt.vertexGeom.lastMapping = mapMethodName;\n\t},\n\tmapNormalizedRGBTo: {\n\t\trgbCube: function (color) {\n\t\t\treturn new THREE.Vector3(\n\t\t\t\tcolor.r - 0.5,\n\t\t\t\tcolor.g - 0.5,\n\t\t\t\tcolor.b - 0.5\n\t\t\t);\n\t\t},\n\t\thslCylinder: function (color) {\n\t\t\tlet hsl = color.getHSL();\n\t\t\tlet angle = -hsl.h * Math.PI * 2;\n\t\t\tlet radius = hsl.s * 0.5;\n\t\t\tlet x = Math.cos(angle) * radius;\n\t\t\tlet y = hsl.l - 0.5;\n\t\t\tlet z = Math.sin(angle) * radius;\n\t\t\treturn new THREE.Vector3(x, y, z);\n\t\t},\n\t\thsvCylinder: function (color) {\n\t\t\tlet hsv = hslToHsv(color.getHSL());\n\t\t\tlet angle = -hsv.h * Math.PI * 2;\n\t\t\tlet radius = hsv.s * 0.5;\n\t\t\tlet x = Math.cos(angle) * radius;\n\t\t\tlet y = hsv.v - 0.5;\n\t\t\tlet z = Math.sin(angle) * radius;\n\t\t\treturn new THREE.Vector3(x, y, z);\n\t\t},\n\t\thslCones: function (color) {\n\t\t\tlet hsl = color.getHSL();\n\t\t\tlet angle = -hsl.h * Math.PI * 2;\n\t\t\tlet radius = (1 - (Math.abs(hsl.l - 0.5) * 2)) * hsl.s * 0.5;\n\t\t\tlet x = Math.cos(angle) * radius;\n\t\t\tlet y = hsl.l - 0.5;\n\t\t\tlet z = Math.sin(angle) * radius;\n\t\t\treturn new THREE.Vector3(x, y, z);\n\t\t},\n\t\thsvCone: function (color) {\n\t\t\tlet hsv = hslToHsv(color.getHSL());\n\t\t\tlet angle = -hsv.h * Math.PI * 2;\n\t\t\tlet radius = hsv.v * hsv.s * 0.5;\n\t\t\tlet x = Math.cos(angle) * radius;\n\t\t\tlet y = hsv.v - 0.5;\n\t\t\tlet z = Math.sin(angle) * radius;\n\t\t\treturn new THREE.Vector3(x, y, z);\n\t\t},\n\t\thslSphere: function (color) {\n\t\t\tlet hsl = color.getHSL();\n\t\t\tlet angle = -hsl.h * Math.PI * 2;\n\t\t\tlet lon = hsl.l * Math.PI;\n\t\t\tlet radius = Math.sin(lon) * hsl.s * 0.5;\n\t\t\tlet x = Math.cos(angle) * radius;\n\t\t\tlet y = Math.cos(lon) * -0.5;\n\t\t\tlet z = Math.sin(angle) * radius;\n\t\t\treturn new THREE.Vector3(x, y, z);\n\t\t},\n\t\thsvSphere: function (color) {\n\t\t\tlet hsv = hslToHsv(color.getHSL());\n\t\t\tlet angle = -hsv.h * Math.PI * 2;\n\t\t\tlet lon = hsv.v * Math.PI;\n\t\t\tlet radius = Math.sin(lon) * hsv.s * 0.5;\n\t\t\tlet x = Math.cos(angle) * radius;\n\t\t\tlet y = Math.cos(lon) * -0.5;\n\t\t\tlet z = Math.sin(angle) * radius;\n\t\t\treturn new THREE.Vector3(x, y, z);\n\t\t},\n\t\thslCube: function (color) {\n\t\t\tlet hsl = color.getHSL();\n\t\t\treturn new THREE.Vector3(\n\t\t\t\thsl.h - 0.5,\n\t\t\t\thsl.s - 0.5,\n\t\t\t\thsl.l - 0.5\n\t\t\t);\n\t\t},\n\t\thsvCube: function (color) {\n\t\t\tlet hsv = hslToHsv(color.getHSL());\n\t\t\treturn new THREE.Vector3(\n\t\t\t\thsv.h - 0.5,\n\t\t\t\thsv.s - 0.5,\n\t\t\t\thsv.v - 0.5\n\t\t\t);\n\t\t},\n\t},\n};\n\nlet hslToHsv = function(hsl) {\n\tlet h = hsl.h;\n\tlet s = hsl.s;\n\tlet l = hsl.l;\n\ts *= l < .5 ? l : 1 - l;\n\treturn {\n\t\th: h,\n\t\ts: 2 * s / (l + s),\n\t\tv: l + s\n\t}\n};\n\nexport default Vertifier;\n\n\n\n// WEBPACK FOOTER //\n// ./src/vertifier.js","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.THREE = global.THREE || {})));\n}(this, (function (exports) { 'use strict';\n\n\t// Polyfills\n\n\tif ( Number.EPSILON === undefined ) {\n\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n\t}\n\n\t//\n\n\tif ( Math.sign === undefined ) {\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\t\tMath.sign = function ( x ) {\n\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t\t};\n\n\t}\n\n\tif ( Function.prototype.name === undefined ) {\n\n\t\t// Missing in IE9-11.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tif ( Object.assign === undefined ) {\n\n\t\t// Missing in IE.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t\t( function () {\n\n\t\t\tObject.assign = function ( target ) {\n\n\t\t\t\t'use strict';\n\n\t\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t\t}\n\n\t\t\t\tvar output = Object( target );\n\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t};\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\n\tfunction EventDispatcher() {}\n\n\tObject.assign( EventDispatcher.prototype, {\n\n\t\taddEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\t\tlisteners[ type ] = [];\n\n\t\t\t}\n\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\t\tlisteners[ type ].push( listener );\n\n\t\t\t}\n\n\t\t},\n\n\t\thasEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return false;\n\n\t\t\tvar listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEventListener: function ( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispatchEvent: function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar array = [], i = 0;\n\t\t\t\tvar length = listenerArray.length;\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tvar REVISION = '82';\n\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\tvar CullFaceNone = 0;\n\tvar CullFaceBack = 1;\n\tvar CullFaceFront = 2;\n\tvar CullFaceFrontBack = 3;\n\tvar FrontFaceDirectionCW = 0;\n\tvar FrontFaceDirectionCCW = 1;\n\tvar BasicShadowMap = 0;\n\tvar PCFShadowMap = 1;\n\tvar PCFSoftShadowMap = 2;\n\tvar FrontSide = 0;\n\tvar BackSide = 1;\n\tvar DoubleSide = 2;\n\tvar FlatShading = 1;\n\tvar SmoothShading = 2;\n\tvar NoColors = 0;\n\tvar FaceColors = 1;\n\tvar VertexColors = 2;\n\tvar NoBlending = 0;\n\tvar NormalBlending = 1;\n\tvar AdditiveBlending = 2;\n\tvar SubtractiveBlending = 3;\n\tvar MultiplyBlending = 4;\n\tvar CustomBlending = 5;\n\tvar BlendingMode = {\n\t\tNoBlending: NoBlending,\n\t\tNormalBlending: NormalBlending,\n\t\tAdditiveBlending: AdditiveBlending,\n\t\tSubtractiveBlending: SubtractiveBlending,\n\t\tMultiplyBlending: MultiplyBlending,\n\t\tCustomBlending: CustomBlending\n\t};\n\tvar AddEquation = 100;\n\tvar SubtractEquation = 101;\n\tvar ReverseSubtractEquation = 102;\n\tvar MinEquation = 103;\n\tvar MaxEquation = 104;\n\tvar ZeroFactor = 200;\n\tvar OneFactor = 201;\n\tvar SrcColorFactor = 202;\n\tvar OneMinusSrcColorFactor = 203;\n\tvar SrcAlphaFactor = 204;\n\tvar OneMinusSrcAlphaFactor = 205;\n\tvar DstAlphaFactor = 206;\n\tvar OneMinusDstAlphaFactor = 207;\n\tvar DstColorFactor = 208;\n\tvar OneMinusDstColorFactor = 209;\n\tvar SrcAlphaSaturateFactor = 210;\n\tvar NeverDepth = 0;\n\tvar AlwaysDepth = 1;\n\tvar LessDepth = 2;\n\tvar LessEqualDepth = 3;\n\tvar EqualDepth = 4;\n\tvar GreaterEqualDepth = 5;\n\tvar GreaterDepth = 6;\n\tvar NotEqualDepth = 7;\n\tvar MultiplyOperation = 0;\n\tvar MixOperation = 1;\n\tvar AddOperation = 2;\n\tvar NoToneMapping = 0;\n\tvar LinearToneMapping = 1;\n\tvar ReinhardToneMapping = 2;\n\tvar Uncharted2ToneMapping = 3;\n\tvar CineonToneMapping = 4;\n\tvar UVMapping = 300;\n\tvar CubeReflectionMapping = 301;\n\tvar CubeRefractionMapping = 302;\n\tvar EquirectangularReflectionMapping = 303;\n\tvar EquirectangularRefractionMapping = 304;\n\tvar SphericalReflectionMapping = 305;\n\tvar CubeUVReflectionMapping = 306;\n\tvar CubeUVRefractionMapping = 307;\n\tvar TextureMapping = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tSphericalReflectionMapping: SphericalReflectionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tvar RepeatWrapping = 1000;\n\tvar ClampToEdgeWrapping = 1001;\n\tvar MirroredRepeatWrapping = 1002;\n\tvar TextureWrapping = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tvar NearestFilter = 1003;\n\tvar NearestMipMapNearestFilter = 1004;\n\tvar NearestMipMapLinearFilter = 1005;\n\tvar LinearFilter = 1006;\n\tvar LinearMipMapNearestFilter = 1007;\n\tvar LinearMipMapLinearFilter = 1008;\n\tvar TextureFilter = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\t\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\t\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n\t};\n\tvar UnsignedByteType = 1009;\n\tvar ByteType = 1010;\n\tvar ShortType = 1011;\n\tvar UnsignedShortType = 1012;\n\tvar IntType = 1013;\n\tvar UnsignedIntType = 1014;\n\tvar FloatType = 1015;\n\tvar HalfFloatType = 1016;\n\tvar UnsignedShort4444Type = 1017;\n\tvar UnsignedShort5551Type = 1018;\n\tvar UnsignedShort565Type = 1019;\n\tvar UnsignedInt248Type = 1020;\n\tvar AlphaFormat = 1021;\n\tvar RGBFormat = 1022;\n\tvar RGBAFormat = 1023;\n\tvar LuminanceFormat = 1024;\n\tvar LuminanceAlphaFormat = 1025;\n\tvar RGBEFormat = RGBAFormat;\n\tvar DepthFormat = 1026;\n\tvar DepthStencilFormat = 1027;\n\tvar RGB_S3TC_DXT1_Format = 2001;\n\tvar RGBA_S3TC_DXT1_Format = 2002;\n\tvar RGBA_S3TC_DXT3_Format = 2003;\n\tvar RGBA_S3TC_DXT5_Format = 2004;\n\tvar RGB_PVRTC_4BPPV1_Format = 2100;\n\tvar RGB_PVRTC_2BPPV1_Format = 2101;\n\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\n\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\n\tvar RGB_ETC1_Format = 2151;\n\tvar LoopOnce = 2200;\n\tvar LoopRepeat = 2201;\n\tvar LoopPingPong = 2202;\n\tvar InterpolateDiscrete = 2300;\n\tvar InterpolateLinear = 2301;\n\tvar InterpolateSmooth = 2302;\n\tvar ZeroCurvatureEnding = 2400;\n\tvar ZeroSlopeEnding = 2401;\n\tvar WrapAroundEnding = 2402;\n\tvar TrianglesDrawMode = 0;\n\tvar TriangleStripDrawMode = 1;\n\tvar TriangleFanDrawMode = 2;\n\tvar LinearEncoding = 3000;\n\tvar sRGBEncoding = 3001;\n\tvar GammaEncoding = 3007;\n\tvar RGBEEncoding = 3002;\n\tvar LogLuvEncoding = 3003;\n\tvar RGBM7Encoding = 3004;\n\tvar RGBM16Encoding = 3005;\n\tvar RGBDEncoding = 3006;\n\tvar BasicDepthPacking = 3200;\n\tvar RGBADepthPacking = 3201;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar _Math = {\n\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\n\t\tgenerateUUID: function () {\n\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\tvar uuid = new Array( 36 );\n\t\t\tvar rnd = 0, r;\n\n\t\t\treturn function generateUUID() {\n\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn uuid.join( '' );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclamp: function ( value, min, max ) {\n\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t\t},\n\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\teuclideanModulo: function ( n, m ) {\n\n\t\t\treturn ( ( n % m ) + m ) % m;\n\n\t\t},\n\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t\t},\n\n\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\tlerp: function ( x, y, t ) {\n\n\t\t\treturn ( 1 - t ) * x + t * y;\n\n\t\t},\n\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\tsmoothstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * ( 3 - 2 * x );\n\n\t\t},\n\n\t\tsmootherstep: function ( x, min, max ) {\n\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\n\t\t\tx = ( x - min ) / ( max - min );\n\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t\t},\n\n\t\trandom16: function () {\n\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\n\t\t},\n\n\t\t// Random integer from <low, high> interval\n\n\t\trandInt: function ( low, high ) {\n\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t\t},\n\n\t\t// Random float from <low, high> interval\n\n\t\trandFloat: function ( low, high ) {\n\n\t\t\treturn low + Math.random() * ( high - low );\n\n\t\t},\n\n\t\t// Random float from <-range/2, range/2> interval\n\n\t\trandFloatSpread: function ( range ) {\n\n\t\t\treturn range * ( 0.5 - Math.random() );\n\n\t\t},\n\n\t\tdegToRad: function ( degrees ) {\n\n\t\t\treturn degrees * _Math.DEG2RAD;\n\n\t\t},\n\n\t\tradToDeg: function ( radians ) {\n\n\t\t\treturn radians * _Math.RAD2DEG;\n\n\t\t},\n\n\t\tisPowerOfTwo: function ( value ) {\n\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t\t},\n\n\t\tnearestPowerOfTwo: function ( value ) {\n\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t\t},\n\n\t\tnextPowerOfTwo: function ( value ) {\n\n\t\t\tvalue --;\n\t\t\tvalue |= value >> 1;\n\t\t\tvalue |= value >> 2;\n\t\t\tvalue |= value >> 4;\n\t\t\tvalue |= value >> 8;\n\t\t\tvalue |= value >> 16;\n\t\t\tvalue ++;\n\n\t\t\treturn value;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tfunction Vector2( x, y ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\n\t}\n\n\tVector2.prototype = {\n\n\t\tconstructor: Vector2,\n\n\t\tisVector2: true,\n\n\t\tget width() {\n\n\t\t\treturn this.x;\n\n\t\t},\n\n\t\tset width( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t},\n\n\t\tget height() {\n\n\t\t\treturn this.y;\n\n\t\t},\n\n\t\tset height( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t},\n\n\t\t//\n\n\t\tset: function ( x, y ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector2();\n\t\t\t\t\tmax = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t\t},\n\n\t\tlengthManhattan: function() {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tangle: function () {\n\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\t\treturn angle;\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateAround: function ( center, angle ) {\n\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\n\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\tObject.defineProperty( this, 'id', { value: TextureIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.sourceFile = '';\n\n\t\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\t\tthis.format = format !== undefined ? format : RGBAFormat;\n\t\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding :  LinearEncoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\n\tTexture.prototype = {\n\n\t\tconstructor: Texture,\n\n\t\tisTexture: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\t\tthis.mapping = source.mapping;\n\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\n\t\t\tthis.anisotropy = source.anisotropy;\n\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tfunction getDataURL( image ) {\n\n\t\t\t\tvar canvas;\n\n\t\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\t\tcanvas = image;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\n\t\t\t\tmapping: this.mapping,\n\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\n\t\t\t\tflipY: this.flipY\n\t\t\t};\n\n\t\t\tif ( this.image !== undefined ) {\n\n\t\t\t\t// TODO: Move to THREE.Image\n\n\t\t\t\tvar image = this.image;\n\n\t\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t\t}\n\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\n\t\t\t}\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t},\n\n\t\ttransformUv: function ( uv ) {\n\n\t\t\tif ( this.mapping !== UVMapping )  return;\n\n\t\t\tuv.multiply( this.repeat );\n\t\t\tuv.add( this.offset );\n\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.flipY ) {\n\n\t\t\t\tuv.y = 1 - uv.y;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tObject.assign( Texture.prototype, EventDispatcher.prototype );\n\n\tvar count = 0;\n\tfunction TextureIdCount() { return count++; }\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector4( x, y, z, w ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tVector4.prototype = {\n\n\t\tconstructor: Vector4,\n\n\t\tisVector4: true,\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( w ) {\n\n\t\t\tthis.w = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t\t// q is assumed to be normalized\n\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\t\tif ( s < 0.0001 ) {\n\n\t\t\t\t this.x = 1;\n\t\t\t\t this.y = 0;\n\t\t\t\t this.z = 0;\n\n\t\t\t} else {\n\n\t\t\t\t this.x = q.x / s;\n\t\t\t\t this.y = q.y / s;\n\t\t\t\t this.z = q.z / s;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\t\tte = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t\t}\n\n\t\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\t\tangle = Math.PI;\n\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.set( x, y, z, angle );\n\n\t\t\t\treturn this; // return 180 deg rotation\n\n\t\t\t}\n\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\tmax = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tfunction WebGLRenderTarget( width, height, options ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\toptions = options || {};\n\n\t\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\n\t\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t}\n\n\tObject.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\n\t\tisWebGLRenderTarget: true,\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\n\t\t\tthis.viewport.copy( source.viewport );\n\n\t\t\tthis.texture = source.texture.clone();\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\n\tfunction WebGLRenderTargetCube( width, height, options ) {\n\n\t\tWebGLRenderTarget.call( this, width, height, options );\n\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\n\t}\n\n\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\n\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Quaternion( x, y, z, w ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\n\t}\n\n\tQuaternion.prototype = {\n\n\t\tconstructor: Quaternion,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget w () {\n\n\t\t\treturn this._w;\n\n\t\t},\n\n\t\tset w ( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, w ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t\t},\n\n\t\tcopy: function ( quaternion ) {\n\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromEuler: function ( euler, update ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\t\tvar order = euler.order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t\t}\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\n\t\t\tif ( trace > 0 ) {\n\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t\t} else if ( m22 > m33 ) {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t\t} else {\n\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromUnitVectors: function () {\n\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\tvar v1, r;\n\n\t\t\tvar EPS = 0.000001;\n\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\t\tif ( r < EPS ) {\n\n\t\t\t\t\tr = 0;\n\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t\t}\n\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\n\t\t\t\treturn this.normalize();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tinverse: function () {\n\n\t\t\treturn this.conjugate().normalize();\n\n\t\t},\n\n\t\tconjugate: function () {\n\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tvar l = this.length();\n\n\t\t\tif ( l === 0 ) {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\n\t\t\t} else {\n\n\t\t\t\tl = 1 / l;\n\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\n\t\t\t}\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( q, p ) {\n\n\t\t\tif ( p !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions( this, q );\n\n\t\t},\n\n\t\tpremultiply: function ( q ) {\n\n\t\t\treturn this.multiplyQuaternions( q, this );\n\n\t\t},\n\n\t\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tslerp: function ( qb, t ) {\n\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copy( qb );\n\n\t\t\t}\n\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( quaternion ) {\n\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\tObject.assign( Quaternion, {\n\n\t\tslerp: function( qa, qb, qm, t ) {\n\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t\t},\n\n\t\tslerpFlat: function(\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\t\tvar s = 1 - t,\n\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t\t}\n\n\t\t\t\tvar tDir = t * dir;\n\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Vector3( x, y, z ) {\n\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\n\t}\n\n\tVector3.prototype = {\n\n\t\tconstructor: Vector3,\n\n\t\tisVector3: true,\n\n\t\tset: function ( x, y, z ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetX: function ( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponent: function ( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetComponent: function ( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t\t},\n\n\t\tcopy: function ( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScaledVector: function ( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubScalar: function ( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsubVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( scalar ) {\n\n\t\t\tif ( isFinite( scalar ) ) {\n\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\n\t\t\t} else {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyVectors: function ( a, b ) {\n\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyEuler: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyEuler( euler ) {\n\n\t\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyAxisAngle: function () {\n\n\t\t\tvar quaternion;\n\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\t\tif ( quaternion === undefined ) quaternion = new Quaternion();\n\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix3: function ( m ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyProjection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 projection matrix\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyQuaternion: function ( q ) {\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t\t// calculate quat * vector\n\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t\t// calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function project( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tunproject: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function unproject( camera ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttransformDirection: function ( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\t\treturn this.normalize();\n\n\t\t},\n\n\t\tdivide: function ( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdivideScalar: function ( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t},\n\n\t\tmin: function ( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmax: function ( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclamp: function ( min, max ) {\n\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclampScalar: function () {\n\n\t\t\tvar min, max;\n\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\t\tif ( min === undefined ) {\n\n\t\t\t\t\tmin = new Vector3();\n\t\t\t\t\tmax = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\t\treturn this.clamp( min, max );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclampLength: function ( min, max ) {\n\n\t\t\tvar length = this.length();\n\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t\t},\n\n\t\tfloor: function () {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tceil: function () {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tround: function () {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\troundToZero: function () {\n\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdot: function ( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t\t},\n\n\t\tlengthSq: function () {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t\t},\n\n\t\tlengthManhattan: function () {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\treturn this.divideScalar( this.length() );\n\n\t\t},\n\n\t\tsetLength: function ( length ) {\n\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\n\t\t},\n\n\t\tlerp: function ( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t\t},\n\n\t\tcross: function ( v, w ) {\n\n\t\t\tif ( w !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\n\t\t\t}\n\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\tthis.z = x * v.y - y * v.x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossVectors: function ( a, b ) {\n\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tprojectOnVector: function ( vector ) {\n\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t\t},\n\n\t\tprojectOnPlane: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\t\treturn this.sub( v1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\treflect: function () {\n\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\n\t\t\tvar v1;\n\n\t\t\treturn function reflect( normal ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tangleTo: function ( v ) {\n\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t\t},\n\n\t\tdistanceTo: function ( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t},\n\n\t\tdistanceToSquared: function ( v ) {\n\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t\t},\n\n\t\tdistanceToManhattan: function ( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t\t},\n\n\t\tsetFromSpherical: function( s ) {\n\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixPosition: function ( m ) {\n\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t\t},\n\n\t\tsetFromMatrixScale: function ( m ) {\n\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\t\tif ( typeof m === 'number' ) {\n\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\tvar temp = m;\n\t\t\t\tm = index;\n\t\t\t\tindex = temp;\n\n\t\t\t}\n\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t\t},\n\n\t\tequals: function ( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tindex = index * attribute.itemSize + offset;\n\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Matrix4() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix4.prototype = {\n\n\t\tconstructor: Matrix4,\n\n\t\tisMatrix4: true,\n\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new Matrix4().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tthis.elements.set( m.elements );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyPosition: function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0,       0,       0,       1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\textractRotation: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function extractRotation( m ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeRotationFromEuler: function ( euler ) {\n\n\t\t\tif ( (euler && euler.isEuler) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t\t}\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlookAt: function () {\n\n\t\t\tvar x, y, z;\n\n\t\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\t\tif ( x === undefined ) {\n\n\t\t\t\t\tx = new Vector3();\n\t\t\t\t\ty = new Vector3();\n\t\t\t\t\tz = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z = 1;\n\n\t\t\t\t}\n\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\ty.crossVectors( z, x );\n\n\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiply: function ( m, n ) {\n\n\t\t\tif ( n !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t},\n\n\t\tpremultiply: function ( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t},\n\n\t\tmultiplyMatrices: function ( a, b ) {\n\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyToArray: function ( a, b, r ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tthis.multiplyMatrices( a, b );\n\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\n\t\t\t);\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetPosition: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function getPosition() {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetPosition: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tscale: function ( v ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetMaxScaleOnAxis: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t\t},\n\n\t\tmakeTranslation: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationX: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0,  0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s,  c, 0,\n\t\t\t\t0, 0,  0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationY: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationZ: function ( theta ) {\n\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts,  c, 0, 0,\n\t\t\t\t0,  0, 1, 0,\n\t\t\t\t0,  0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\n\t\t\tthis.set(\n\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\t return this;\n\n\t\t},\n\n\t\tmakeScale: function ( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompose: function ( position, quaternion, scale ) {\n\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdecompose: function () {\n\n\t\t\tvar vector, matrix;\n\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\tmatrix = new Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\tvar te = this.elements;\n\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) {\n\n\t\t\t\t\tsx = - sx;\n\n\t\t\t\t}\n\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\n\t\t\t\t// scale the rotation part\n\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\t\tvar ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );\n\t\t\tvar ymin = - ymax;\n\t\t\tvar xmin = ymin * aspect;\n\t\t\tvar xmax = ymax * aspect;\n\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t\t},\n\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( matrix ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tCubeTexture.prototype = Object.create( Texture.prototype );\n\tCubeTexture.prototype.constructor = CubeTexture;\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\t\tget: function () {\n\n\t\t\treturn this.image;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.image = value;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\n\tvar emptyTexture = new Texture();\n\tvar emptyCubeTexture = new CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tfunction UniformContainer() {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tvar arrayCacheF32 = [];\n\tvar arrayCacheI32 = [];\n\n\t// Flattening for arrays of vectors and matrices\n\n\tfunction flatten( array, nBlocks, blockSize ) {\n\n\t\tvar firstElem = array[ 0 ];\n\n\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t// unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tvar n = nBlocks * blockSize,\n\t\t\tr = arrayCacheF32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Float32Array( n );\n\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t}\n\n\t\tif ( nBlocks !== 0 ) {\n\n\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n\t// Texture unit allocation\n\n\tfunction allocTexUnits( renderer, n ) {\n\n\t\tvar r = arrayCacheI32[ n ];\n\n\t\tif ( r === undefined ) {\n\n\t\t\tr = new Int32Array( n );\n\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\treturn r;\n\n\t}\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t// Single scalar\n\n\tfunction setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n\tfunction setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\n\t// Single float vector (from flat array or THREE.VectorN)\n\n\tfunction setValue2fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t}\n\n\tfunction setValue3fv( gl, v ) {\n\n\t\tif ( v.x !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\telse if ( v.r !== undefined )\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\telse\n\t\t\tgl.uniform3fv( this.addr, v );\n\n\t}\n\n\tfunction setValue4fv( gl, v ) {\n\n\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t}\n\n\t// Single matrix (from flat array or MatrixN)\n\n\tfunction setValue2fm( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue3fm( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t}\n\n\tfunction setValue4fm( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t}\n\n\t// Single texture (2D / Cube)\n\n\tfunction setValueT1( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t}\n\n\tfunction setValueT6( gl, v, renderer ) {\n\n\t\tvar unit = renderer.allocTextureUnit();\n\t\tgl.uniform1i( this.addr, unit );\n\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t}\n\n\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\tfunction setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n\tfunction setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n\tfunction setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\n\t// Helper to pick the right setter for the singular case\n\n\tfunction getSingularSetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// Array of scalars\n\n\tfunction setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n\tfunction setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\n\t// Array of vectors (flat or from THREE classes)\n\n\tfunction setValueV2a( gl, v ) {\n\n\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t}\n\n\tfunction setValueV3a( gl, v ) {\n\n\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t}\n\n\tfunction setValueV4a( gl, v ) {\n\n\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t}\n\n\t// Array of matrices (flat or from THREE clases)\n\n\tfunction setValueM2a( gl, v ) {\n\n\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t}\n\n\tfunction setValueM3a( gl, v ) {\n\n\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t}\n\n\tfunction setValueM4a( gl, v ) {\n\n\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t}\n\n\t// Array of textures (2D / Cube)\n\n\tfunction setValueT1a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\tfunction setValueT6a( gl, v, renderer ) {\n\n\t\tvar n = v.length,\n\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t}\n\n\t}\n\n\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\tfunction getPureArraySetter( type ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t}\n\n\t}\n\n\t// --- Uniform Classes ---\n\n\tfunction SingleUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n\tfunction StructuredUniform( id ) {\n\n\t\tthis.id = id;\n\n\t\tUniformContainer.call( this ); // mix-in\n\n\t}\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n\t// extracts\n\t// \t- the identifier (member name or array index)\n\t//  - followed by an optional right bracket (found when array index)\n\t//  - followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform( container, uniformObject ) {\n\n\t\tcontainer.seq.push( uniformObject );\n\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t}\n\n\tfunction parseUniform( activeInfo, addr, container ) {\n\n\t\tvar path = activeInfo.name,\n\t\t\tpathLength = path.length;\n\n\t\t// reset RegExp object, because of the early exit of a previous run\n\t\tRePathPart.lastIndex = 0;\n\n\t\tfor (; ;) {\n\n\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\tid = match[ 1 ],\n\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\tif ( subscript === undefined ||\n\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\tvar map = container.map,\n\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Root Container\n\n\tfunction WebGLUniforms( gl, program, renderer ) {\n\n\t\tUniformContainer.call( this );\n\n\t\tthis.renderer = renderer;\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\tpath = info.name,\n\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\t/**\n\t * Uniform Utilities\n\t */\n\n\tvar UniformsUtils = {\n\n\t\tmerge: function ( uniforms ) {\n\n\t\t\tvar merged = {};\n\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn merged;\n\n\t\t},\n\n\t\tclone: function ( uniforms_src ) {\n\n\t\t\tvar uniforms_dst = {};\n\n\t\t\tfor ( var u in uniforms_src ) {\n\n\t\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\n\t\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n\t\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n\t\t\t\t\t\tparameter_src.isTexture ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uniforms_dst;\n\n\t\t}\n\n\t};\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\n\tvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n\tvar bsdfs = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n\tvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\n\tvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n\tvar defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n\tvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\\t\\t\\tdirectLight.color = pointLight.color;\\n\\t\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\t#include <normal_flip>\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\t#include <normal_flip>\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n\tvar lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t \\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\t\\t\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n\tvar logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n\tvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n\tvar normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n\tvar project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n\tvar tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n\tvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n\tvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\n\tvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n\tvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n\tvar distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n\tvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight;\\n\\treflectedLight.directDiffuse = vec3( 0.0 );\\n\\treflectedLight.directSpecular = vec3( 0.0 );\\n\\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n}\\n\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar normal_frag = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n\tvar normal_vert = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvNormal = normalize( normalMatrix * normal );\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n\tvar shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n\tvar ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars: lights_pars,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_template: lights_template,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_flip: normal_flip,\n\t\tnormal_fragment: normal_fragment,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Color( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\n\t\t}\n\n\t\treturn this.setRGB( r, g, b );\n\n\t}\n\n\tColor.prototype = {\n\n\t\tconstructor: Color,\n\n\t\tisColor: true,\n\n\t\tr: 1, g: 1, b: 1,\n\n\t\tset: function ( value ) {\n\n\t\t\tif ( (value && value.isColor) ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetScalar: function ( scalar ) {\n\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHex: function ( hex ) {\n\n\t\t\thex = Math.floor( hex );\n\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetRGB: function ( r, g, b ) {\n\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetHSL: function () {\n\n\t\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\t\t\tif ( s === 0 ) {\n\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetStyle: function ( style ) {\n\n\t\t\tfunction handleAlpha( string ) {\n\n\t\t\t\tif ( string === undefined ) return;\n\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar m;\n\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t\t// rgb / hsl\n\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t\t// hex color\n\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\n\t\t\t\tif ( size === 3 ) {\n\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( style && style.length > 0 ) {\n\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t\t},\n\n\t\tcopy: function ( color ) {\n\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertGammaToLinear: function () {\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconvertLinearToGamma: function () {\n\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetHex: function () {\n\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t\t},\n\n\t\tgetHexString: function () {\n\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t\t},\n\n\t\tgetHSL: function ( optionalTarget ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\t\tif ( min === max ) {\n\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\n\t\t\t} else {\n\n\t\t\t\tvar delta = max - min;\n\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\t\tswitch ( max ) {\n\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\n\t\t\t}\n\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\n\t\t\treturn hsl;\n\n\t\t},\n\n\t\tgetStyle: function () {\n\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t\t},\n\n\t\toffsetHSL: function ( h, s, l ) {\n\n\t\t\tvar hsl = this.getHSL();\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( color ) {\n\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddColors: function ( color1, color2 ) {\n\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddScalar: function ( s ) {\n\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsub: function( color ) {\n\n\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiply: function ( color ) {\n\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tlerp: function ( color, alpha ) {\n\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( c ) {\n\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\treturn this.getHex();\n\n\t\t}\n\n\t};\n\n\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tvar UniformsLib = {\n\n\t\tcommon: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\n\t\t\tspecularMap: { value: null },\n\t\t\talphaMap: { value: null },\n\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\treflectivity: { value: 1.0 },\n\t\t\trefractionRatio: { value: 0.98 }\n\n\t\t},\n\n\t\taomap: {\n\n\t\t\taoMap: { value: null },\n\t\t\taoMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\tlightmap: {\n\n\t\t\tlightMap: { value: null },\n\t\t\tlightMapIntensity: { value: 1 }\n\n\t\t},\n\n\t\temissivemap: {\n\n\t\t\temissiveMap: { value: null }\n\n\t\t},\n\n\t\tbumpmap: {\n\n\t\t\tbumpMap: { value: null },\n\t\t\tbumpScale: { value: 1 }\n\n\t\t},\n\n\t\tnormalmap: {\n\n\t\t\tnormalMap: { value: null },\n\t\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t\t},\n\n\t\tdisplacementmap: {\n\n\t\t\tdisplacementMap: { value: null },\n\t\t\tdisplacementScale: { value: 1 },\n\t\t\tdisplacementBias: { value: 0 }\n\n\t\t},\n\n\t\troughnessmap: {\n\n\t\t\troughnessMap: { value: null }\n\n\t\t},\n\n\t\tmetalnessmap: {\n\n\t\t\tmetalnessMap: { value: null }\n\n\t\t},\n\n\t\tfog: {\n\n\t\t\tfogDensity: { value: 0.00025 },\n\t\t\tfogNear: { value: 1 },\n\t\t\tfogFar: { value: 2000 },\n\t\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t\t},\n\n\t\tlights: {\n\n\t\t\tambientLightColor: { value: [] },\n\n\t\t\tdirectionalLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tcolor: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tdirectionalShadowMap: { value: [] },\n\t\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\t\tspotLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdirection: {},\n\t\t\t\tdistance: {},\n\t\t\t\tconeCos: {},\n\t\t\t\tpenumbraCos: {},\n\t\t\t\tdecay: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tspotShadowMap: { value: [] },\n\t\t\tspotShadowMatrix: { value: [] },\n\n\t\t\tpointLights: { value: [], properties: {\n\t\t\t\tcolor: {},\n\t\t\t\tposition: {},\n\t\t\t\tdecay: {},\n\t\t\t\tdistance: {},\n\n\t\t\t\tshadow: {},\n\t\t\t\tshadowBias: {},\n\t\t\t\tshadowRadius: {},\n\t\t\t\tshadowMapSize: {}\n\t\t\t} },\n\n\t\t\tpointShadowMap: { value: [] },\n\t\t\tpointShadowMatrix: { value: [] },\n\n\t\t\themisphereLights: { value: [], properties: {\n\t\t\t\tdirection: {},\n\t\t\t\tskyColor: {},\n\t\t\t\tgroundColor: {}\n\t\t\t} }\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\t\topacity: { value: 1.0 },\n\t\t\tsize: { value: 1.0 },\n\t\t\tscale: { value: 1.0 },\n\t\t\tmap: { value: null },\n\t\t\toffsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\n\tvar ShaderLib = {\n\n\t\tbasic: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t\t},\n\n\t\tlambert: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t\t},\n\n\t\tphong: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\tspecular : { value: new Color( 0x111111 ) },\n\t\t\t\t\tshininess: { value: 30 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t\t},\n\n\t\tstandard: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.aomap,\n\t\t\t\tUniformsLib.lightmap,\n\t\t\t\tUniformsLib.emissivemap,\n\t\t\t\tUniformsLib.bumpmap,\n\t\t\t\tUniformsLib.normalmap,\n\t\t\t\tUniformsLib.displacementmap,\n\t\t\t\tUniformsLib.roughnessmap,\n\t\t\t\tUniformsLib.metalnessmap,\n\t\t\t\tUniformsLib.fog,\n\t\t\t\tUniformsLib.lights,\n\n\t\t\t\t{\n\t\t\t\t\temissive : { value: new Color( 0x000000 ) },\n\t\t\t\t\troughness: { value: 0.5 },\n\t\t\t\t\tmetalness: { value: 0 },\n\t\t\t\t\tenvMapIntensity : { value: 1 }, // temporary\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t\t},\n\n\t\tpoints: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.points,\n\t\t\t\tUniformsLib.fog\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\n\t\t},\n\n\t\tdashed: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.fog,\n\n\t\t\t\t{\n\t\t\t\t\tscale    : { value: 1 },\n\t\t\t\t\tdashSize : { value: 1 },\n\t\t\t\t\ttotalSize: { value: 2 }\n\t\t\t\t}\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t\t},\n\n\t\tdepth: {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\t\tUniformsLib.common,\n\t\t\t\tUniformsLib.displacementmap\n\n\t\t\t] ),\n\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t\t},\n\n\t\tnormal: {\n\n\t\t\tuniforms: {\n\n\t\t\t\topacity : { value: 1.0 }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tcube: {\n\n\t\t\tuniforms: {\n\t\t\t\ttCube: { value: null },\n\t\t\t\ttFlip: { value: - 1 },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\n\t\tequirect: {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t\ttFlip: { value: - 1 }\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t\t},\n\n\t\tdistanceRGBA: {\n\n\t\t\tuniforms: {\n\n\t\t\t\tlightPos: { value: new Vector3() }\n\n\t\t\t},\n\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t\t}\n\n\t};\n\n\tShaderLib.physical = {\n\n\t\tuniforms: UniformsUtils.merge( [\n\n\t\t\tShaderLib.standard.uniforms,\n\n\t\t\t{\n\t\t\t\tclearCoat: { value: 0 },\n\t\t\t\tclearCoatRoughness: { value: 0 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Box2( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n\t}\n\n\tBox2.prototype = {\n\n\t\tconstructor: Box2,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector2();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlarePlugin( renderer, flares ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar shader, program, attributes, uniforms;\n\n\t\tvar tempTexture, occlusionTexture;\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t- 1,  1,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\t// buffers\n\n\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\telementBuffer    = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\t// textures\n\n\t\t\ttempTexture      = gl.createTexture();\n\t\t\tocclusionTexture = gl.createTexture();\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\t\tshader = {\n\n\t\t\t\tvertexShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" ),\n\n\t\t\t\tfragmentShader: [\n\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\t// pink square\n\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t\t// restore\n\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t\t// flare\n\n\t\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\"\n\n\t\t\t\t].join( \"\\n\" )\n\n\t\t\t};\n\n\t\t\tprogram = createProgram( shader );\n\n\t\t\tattributes = {\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t};\n\n\t\t}\n\n\t\t/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\n\t\tthis.render = function ( scene, camera, viewport ) {\n\n\t\t\tif ( flares.length === 0 ) return;\n\n\t\t\tvar tempPosition = new Vector3();\n\n\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\t\tvar size = 16 / viewport.w,\n\t\t\t\tscale = new Vector2( size * invAspect, size );\n\n\t\t\tvar screenPosition = new Vector3( 1, 1, 0 ),\n\t\t\t\tscreenPositionPixels = new Vector2( 1, 1 );\n\n\t\t\tvar validArea = new Box2();\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t// setup gl and common used attribs/uniforms\n\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.setDepthWrite( false );\n\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t\t// calc object screen position\n\n\t\t\t\tvar flare = flares[ i ];\n\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t\t// setup arrays for gl programs\n\n\t\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t\t// screen cull\n\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// render pink quad\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t\t// restore graphics\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t\t// update object positions\n\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render flares\n\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\tstate.setDepthWrite( true );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram( shader ) {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t\tgl.compileShader( fragmentShader );\n\t\t\tgl.compileShader( vertexShader );\n\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\tgl.attachShader( program, vertexShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpritePlugin( renderer, sprites ) {\n\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\n\t\tvar texture;\n\n\t\t// decompose matrixWorld\n\n\t\tvar spritePosition = new Vector3();\n\t\tvar spriteRotation = new Quaternion();\n\t\tvar spriteScale = new Vector3();\n\n\t\tfunction init() {\n\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t] );\n\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\n\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t\tprogram = createProgram();\n\n\t\t\tattributes = {\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\t\ttexture = new Texture( canvas );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( sprites.length === 0 ) return;\n\n\t\t\t// setup gl\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tinit();\n\n\t\t\t}\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\n\t\t\tif ( fog ) {\n\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\t\tif ( (fog && fog.isFog) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\n\t\t\t\t} else if ( (fog && fog.isFogExp2) ) {\n\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\n\t\t\t}\n\n\n\t\t\t// update positions and sort\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t\t}\n\n\t\t\tsprites.sort( painterSortStable );\n\n\t\t\t// render all sprites\n\n\t\t\tvar scale = [];\n\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\n\t\t\t\tif ( material.visible === false ) continue;\n\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\t\tvar fogType = 0;\n\n\t\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\t\tfogType = sceneFogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t// restore gl\n\n\t\t\tstate.enable( gl.CULL_FACE );\n\n\t\t\trenderer.resetGLState();\n\n\t\t};\n\n\t\tfunction createProgram() {\n\n\t\t\tvar program = gl.createProgram();\n\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t\t'}',\n\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ) );\n\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\n\t\t\tgl.linkProgram( program );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn b.id - a.id;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Material() {\n\n\t\tObject.defineProperty( this, 'id', { value: MaterialIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\t\tthis.visible = true;\n\n\t\tthis._needsUpdate = true;\n\n\t}\n\n\tMaterial.prototype = {\n\n\t\tconstructor: Material,\n\n\t\tisMaterial: true,\n\n\t\tget needsUpdate() {\n\n\t\t\treturn this._needsUpdate;\n\n\t\t},\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.update();\n\t\t\tthis._needsUpdate = value;\n\n\t\t},\n\n\t\tsetValues: function ( values ) {\n\n\t\t\tif ( values === undefined ) return;\n\n\t\t\tfor ( var key in values ) {\n\n\t\t\t\tvar newValue = values[ key ];\n\n\t\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( (currentValue && currentValue.isColor) ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar isRoot = meta === undefined;\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( (this.color && this.color.isColor) ) data.color = this.color.getHex();\n\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\t\tif ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();\n\t\t\tif ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\t\tif ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.bumpMap && this.bumpMap.isTexture) ) {\n\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t\t}\n\t\t\tif ( (this.normalMap && this.normalMap.isTexture) ) {\n\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t\t}\n\t\t\tif ( (this.displacementMap && this.displacementMap.isTexture) ) {\n\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t\t}\n\t\t\tif ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\t\tif ( (this.envMap && this.envMap.isTexture) ) {\n\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t\t}\n\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.shading !== SmoothShading ) data.shading = this.shading;\n\t\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\t\tdata.skinning = this.skinning;\n\t\t\tdata.morphTargets = this.morphTargets;\n\n\t\t\t// TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t\tif ( isRoot ) {\n\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.shading = source.shading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\n\t\t\tthis.colorWrite = source.colorWrite;\n\n\t\t\tthis.precision = source.precision;\n\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\t\tthis.alphaTest = source.alphaTest;\n\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\t\tthis.overdraw = source.overdraw;\n\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\n\t\t\tif ( srcPlanes !== null ) {\n\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t};\n\n\tObject.assign( Material.prototype, EventDispatcher.prototype );\n\n\tvar count$1 = 0;\n\tfunction MaterialIdCount() { return count$1++; }\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction ShaderMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype = Object.create( Material.prototype );\n\tShaderMaterial.prototype.constructor = ShaderMaterial;\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tShaderMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = UniformsUtils.clone( source.uniforms );\n\n\t\tthis.defines = source.defines;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.skinning = source.skinning;\n\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\tthis.extensions = source.extensions;\n\n\t\treturn this;\n\n\t};\n\n\tShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshDepthMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\n\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\tMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction Box3( min, max ) {\n\n\t\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n\t}\n\n\tBox3.prototype = {\n\n\t\tconstructor: Box3,\n\n\t\tisBox3: true,\n\n\t\tset: function ( min, max ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromArray: function ( array ) {\n\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t\t}\n\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\t},\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCenterAndSize: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromObject: function () {\n\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function setFromObject( object ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\t\tthis.makeEmpty();\n\n\t\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\t\tvar array, offset, stride;\n\n\t\t\t\t\t\t\t\tif ( (attribute && attribute.isInterleavedBufferAttribute) ) {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\tstride = 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\n\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( box ) {\n\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tgetSize: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\n\t\t},\n\n\t\texpandByPoint: function ( point ) {\n\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByVector: function ( vector ) {\n\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\texpandByScalar: function ( scalar ) {\n\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tcontainsBox: function ( box ) {\n\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\t// using 6 splitting planes to rule out intersections.\n\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsSphere: ( function () {\n\n\t\t\tvar closestPoint;\n\n\t\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new Vector3();\n\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\t\tvar min, max;\n\n\t\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t\t} else {\n\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t\t}\n\n\t\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t\t} else {\n\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t\t}\n\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t\t},\n\n\t\tdistanceToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceToPoint( point ) {\n\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetBoundingSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Sphere();\n\n\t\t\t\tthis.getCenter( result.center );\n\n\t\t\t\tresult.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersect: function ( box ) {\n\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunion: function ( box ) {\n\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar points = [\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3(),\n\t\t\t\tnew Vector3()\n\t\t\t];\n\n\t\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\t\tthis.setFromPoints( points );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( box ) {\n\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Sphere( center, radius ) {\n\n\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n\t}\n\n\tSphere.prototype = {\n\n\t\tconstructor: Sphere,\n\n\t\tset: function ( center, radius ) {\n\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPoints: function () {\n\n\t\t\tvar box = new Box3();\n\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\t\tvar center = this.center;\n\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t\t}\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( sphere ) {\n\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tempty: function () {\n\n\t\t\treturn ( this.radius <= 0 );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsSphere( this );\n\n\t\t},\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t// the center of the sphere to the plane.\n\t\t\t//\n\t\t\t// distance = q * n - d\n\t\t\t//\n\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t// then there is no intersection.\n\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t\t},\n\n\t\tclampPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.copy( point );\n\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\t\tvar box = optionalTarget || new Box3();\n\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\n\t\t\treturn box;\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.center.add( offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( sphere ) {\n\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\n\tfunction Matrix3() {\n\n\t\tthis.elements = new Float32Array( [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t] );\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tMatrix3.prototype = {\n\n\t\tconstructor: Matrix3,\n\n\t\tisMatrix3: true,\n\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tidentity: function () {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\n\t\t},\n\n\t\tcopy: function ( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix4: function( m ) {\n\n\t\t\tvar me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tapplyToVector3Array: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\tv1.toArray( array, j );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyToBuffer: function () {\n\n\t\t\tvar v1;\n\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\t\tbuffer.setXYZ( j, v1.x, v1.y, v1.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmultiplyScalar: function ( s ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdeterminant: function () {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t\t},\n\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\t\tif ( (matrix && matrix.isMatrix4) ) {\n\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t\t}\n\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\tif ( det === 0 ) {\n\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\t\tthrow new Error( msg );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( msg );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.identity();\n\t\t\t}\n\n\t\t\tvar detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttranspose: function () {\n\n\t\t\tvar tmp, m = this.elements;\n\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\t\treturn this.toArray( array, offset );\n\n\t\t},\n\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t\t},\n\n\t\ttransposeIntoArray: function ( r ) {\n\n\t\t\tvar m = this.elements;\n\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromArray: function ( array, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tfor( var i = 0; i < 9; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Plane( normal, constant ) {\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tPlane.prototype = {\n\n\t\tconstructor: Plane,\n\n\t\tset: function ( normal, constant ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetComponents: function ( x, y, z, w ) {\n\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromCoplanarPoints: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( plane ) {\n\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnegate: function () {\n\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\n\t\t},\n\n\t\tdistanceToSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t\t},\n\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t\t},\n\n\t\torthoPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t\t},\n\n\t\tintersectLine: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tvar direction = line.delta( v1 );\n\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsLine: function ( line ) {\n\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t\t},\n\n\t\tintersectsBox: function ( box ) {\n\n\t\t\treturn box.intersectsPlane( this );\n\n\t\t},\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn sphere.intersectsPlane( this );\n\n\t\t},\n\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t\t},\n\n\t\tapplyMatrix4: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar m1 = new Matrix3();\n\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t\t// transform normal based on theory here:\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function ( offset ) {\n\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( plane ) {\n\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tthis.planes = [\n\n\t\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t\t];\n\n\t}\n\n\tFrustum.prototype = {\n\n\t\tconstructor: Frustum,\n\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( frustum ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromMatrix: function ( m ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tintersectsObject: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsObject( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSprite: function () {\n\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectsBox: function () {\n\n\t\t\tvar p1 = new Vector3(),\n\t\t\t\tp2 = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\tvar planes = this.planes;\n\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t}(),\n\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\n\t\tvar _gl = _renderer.context,\n\t\t_state = _renderer.state,\n\t\t_frustum = new Frustum(),\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_lightShadows = _lights.shadows,\n\n\t\t_shadowMapSize = new Vector2(),\n\t\t_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\n\t\t_lookTarget = new Vector3(),\n\t\t_lightPositionWorld = new Vector3(),\n\n\t\t_renderList = [],\n\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t_materialCache = {};\n\n\t\tvar cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tvar cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t\tvar cube2DViewPorts = [\n\t\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\t\tnew Vector4(), new Vector4(), new Vector4()\n\t\t];\n\n\t\t// init\n\n\t\tvar depthMaterialTemplate = new MeshDepthMaterial();\n\t\tdepthMaterialTemplate.depthPacking = RGBADepthPacking;\n\t\tdepthMaterialTemplate.clipping = true;\n\n\t\tvar distanceShader = ShaderLib[ \"distanceRGBA\" ];\n\t\tvar distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t\tvar distanceMaterial = new ShaderMaterial( {\n\t\t\t\tdefines: {\n\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t},\n\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning,\n\t\t\t\tclipping: true\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tthis.enabled = false;\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.renderReverseSided = true;\n\t\tthis.renderSingleSided = true;\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.setDepthTest( true );\n\t\t\t_state.setScissorTest( false );\n\n\t\t\t// render depth map\n\n\t\t\tvar faceCount, isPointLight;\n\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\t\tif ( (light && light.isPointLight) ) {\n\n\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\tisPointLight = true;\n\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\tisPointLight = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( (shadow && shadow.isSpotLightShadow) ) {\n\n\t\t\t\t\tshadow.update( light );\n\n\t\t\t\t}\n\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t\t// compute shadow matrix\n\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t\t_renderList.length = 0;\n\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t\t// render shadow map\n\t\t\t\t\t// render regular objects\n\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( (material && material.isMultiMaterial) ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Restore GL state.\n\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t};\n\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tvar result = null;\n\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t\t}\n\n\t\t\tif ( ! customMaterial ) {\n\n\t\t\t\tvar useMorphing = false;\n\n\t\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\t\tvar variantIndex = 0;\n\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t\t} else {\n\n\t\t\t\tresult = customMaterial;\n\n\t\t\t}\n\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tvar side = material.side;\n\n\t\t\tif ( scope.renderSingleSided && side == DoubleSide ) {\n\n\t\t\t\tside = FrontSide;\n\n\t\t\t}\n\n\t\t\tif ( scope.renderReverseSided ) {\n\n\t\t\t\tif ( side === FrontSide ) side = BackSide;\n\t\t\t\telse if ( side === BackSide ) side = FrontSide;\n\n\t\t\t}\n\n\t\t\tresult.side = side;\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Ray( origin, direction ) {\n\n\t\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n\t}\n\n\tRay.prototype = {\n\n\t\tconstructor: Ray,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( ray ) {\n\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t\t},\n\n\t\tlookAt: function ( v ) {\n\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trecast: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function recast( t ) {\n\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn result.copy( this.origin );\n\n\t\t\t}\n\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t},\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t\t},\n\n\t\tdistanceSqToPoint: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t\t// point behind the ray\n\n\t\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t\t}\n\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\t\treturn v1.distanceToSquared( point );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceSqToSegment: function () {\n\n\t\t\tvar segCenter = new Vector3();\n\t\t\tvar segDir = new Vector3();\n\t\t\tvar diff = new Vector3();\n\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\t\tif ( det > 0 ) {\n\n\t\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\n\t\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t\t}\n\n\t\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t\t}\n\n\t\t\t\treturn sqrDist;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectSphere: function () {\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tintersectsSphere: function ( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t\t},\n\n\t\tdistanceToPlane: function ( plane ) {\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t\t// Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t :  null;\n\n\t\t},\n\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\t\tvar t = this.distanceToPlane( plane );\n\n\t\t\tif ( t === null ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn this.at( t, optionalTarget );\n\n\t\t},\n\n\n\n\t\tintersectsPlane: function ( plane ) {\n\n\t\t\t// check if the ray lies on the plane first\n\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\t\tif ( distToPoint === 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tintersectBox: function ( box, optionalTarget ) {\n\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\t\tvar origin = this.origin;\n\n\t\t\tif ( invdirx >= 0 ) {\n\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t\t} else {\n\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t\t}\n\n\t\t\tif ( invdiry >= 0 ) {\n\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t\t} else {\n\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\t\tif ( invdirz >= 0 ) {\n\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t\t} else {\n\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t\t//return point closest to the ray (positive side)\n\n\t\t\tif ( tmax < 0 ) return null;\n\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t\t},\n\n\t\tintersectsBox: ( function () {\n\n\t\t\tvar v = new Vector3();\n\n\t\t\treturn function intersectsBox( box ) {\n\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tintersectTriangle: function () {\n\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new Vector3();\n\t\t\tvar edge1 = new Vector3();\n\t\t\tvar edge2 = new Vector3();\n\t\t\tvar normal = new Vector3();\n\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\n\t\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\n\t\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tapplyMatrix4: function ( matrix4 ) {\n\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.sub( this.origin );\n\t\t\tthis.direction.normalize();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( ray ) {\n\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Euler( x, y, z, order ) {\n\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || Euler.DefaultOrder;\n\n\t}\n\n\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\n\tEuler.DefaultOrder = 'XYZ';\n\n\tEuler.prototype = {\n\n\t\tconstructor: Euler,\n\n\t\tisEuler: true,\n\n\t\tget x () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset x ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget y () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset y ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget z () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset z ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tget order () {\n\n\t\t\treturn this._order;\n\n\t\t},\n\n\t\tset order ( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t},\n\n\t\tset: function ( x, y, z, order ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t\t},\n\n\t\tcopy: function ( euler ) {\n\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\t\tvar clamp = _Math.clamp;\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\torder = order || this._order;\n\n\t\t\tif ( order === 'XYZ' ) {\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'YZX' ) {\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( order === 'XZY' ) {\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t\t}\n\n\t\t\tthis._order = order;\n\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromQuaternion: function () {\n\n\t\t\tvar matrix;\n\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\t\tif ( matrix === undefined ) matrix = new Matrix4();\n\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tsetFromVector3: function ( v, order ) {\n\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t\t},\n\n\t\treorder: function () {\n\n\t\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t\tvar q = new Quaternion();\n\n\t\t\treturn function reorder( newOrder ) {\n\n\t\t\t\tq.setFromEuler( this );\n\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( euler ) {\n\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t\t},\n\n\t\tfromArray: function ( array ) {\n\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\t\tthis.onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoArray: function ( array, offset ) {\n\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\ttoVector3: function ( optionalResult ) {\n\n\t\t\tif ( optionalResult ) {\n\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t\t} else {\n\n\t\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t\t}\n\n\t\t},\n\n\t\tonChange: function ( callback ) {\n\n\t\t\tthis.onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tonChangeCallback: function () {}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Layers() {\n\n\t\tthis.mask = 1;\n\n\t}\n\n\tLayers.prototype = {\n\n\t\tconstructor: Layers,\n\n\t\tset: function ( channel ) {\n\n\t\t\tthis.mask = 1 << channel;\n\n\t\t},\n\n\t\tenable: function ( channel ) {\n\n\t\t\tthis.mask |= 1 << channel;\n\n\t\t},\n\n\t\ttoggle: function ( channel ) {\n\n\t\t\tthis.mask ^= 1 << channel;\n\n\t\t},\n\n\t\tdisable: function ( channel ) {\n\n\t\t\tthis.mask &= ~ ( 1 << channel );\n\n\t\t},\n\n\t\ttest: function ( layers ) {\n\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\n\tfunction Object3D() {\n\n\t\tObject.defineProperty( this, 'id', { value: Object3DIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\tvar position = new Vector3();\n\t\tvar rotation = new Euler();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.userData = {};\n\n\t\tthis.onBeforeRender = function(){}; \n\t\tthis.onAfterRender = function(){};\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\n\tObject.assign( Object3D.prototype, EventDispatcher.prototype, {\n\n\t\tisObject3D: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t\t},\n\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t\t},\n\n\t\tsetRotationFromEuler: function ( euler ) {\n\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t\t},\n\n\t\tsetRotationFromMatrix: function ( m ) {\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t\t},\n\n\t\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t\t// assumes q is normalized\n\n\t\t\tthis.quaternion.copy( q );\n\n\t\t},\n\n\t\trotateOnAxis: function () {\n\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar q1 = new Quaternion();\n\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateOnAxis: function () {\n\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateX: function () {\n\n\t\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\t\treturn function translateX( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateY: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\t\treturn function translateY( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslateZ: function () {\n\n\t\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\t\treturn function translateZ( distance ) {\n\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlocalToWorld: function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t\t},\n\n\t\tworldToLocal: function () {\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function worldToLocal( vector ) {\n\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\t\tvar m1 = new Matrix4();\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tadd: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object === this ) {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( (object && object.isObject3D) ) {\n\n\t\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\t\tobject.parent.remove( object );\n\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\t\tthis.children.push( object );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tremove: function ( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar index = this.children.indexOf( object );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tobject.parent = null;\n\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetObjectById: function ( id ) {\n\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\n\t\t},\n\n\t\tgetObjectByName: function ( name ) {\n\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\n\t\t},\n\n\t\tgetObjectByProperty: function ( name, value ) {\n\n\t\t\tif ( this[ name ] === value ) return this;\n\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\t\tif ( object !== undefined ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t},\n\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t\t},\n\n\t\tgetWorldQuaternion: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar scale = new Vector3();\n\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Quaternion();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldRotation: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Euler();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldScale: function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tgetWorldDirection: function () {\n\n\t\t\tvar quaternion = new Quaternion();\n\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\traycast: function () {},\n\n\t\ttraverse: function ( callback ) {\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverse( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseVisible: function ( callback ) {\n\n\t\t\tif ( this.visible === false ) return;\n\n\t\t\tcallback( this );\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttraverseAncestors: function ( callback ) {\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tcallback( parent );\n\n\t\t\t\tparent.traverseAncestors( callback );\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrix: function () {\n\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t\t},\n\n\t\tupdateMatrixWorld: function ( force ) {\n\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\tforce = true;\n\n\t\t\t}\n\n\t\t\t// update children\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\t// meta is '' when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\t\tvar output = {};\n\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// standard Object3D serialization\n\n\t\t\tvar object = {};\n\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\n\t\t\tobject.matrix = this.matrix.toArray();\n\n\t\t\t//\n\n\t\t\tif ( this.geometry !== undefined ) {\n\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.material !== undefined ) {\n\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = this.material.uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.children.length > 0 ) {\n\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t\t}\n\n\t\t\toutput.object = object;\n\n\t\t\treturn output;\n\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function ( recursive ) {\n\n\t\t\treturn new this.constructor().copy( this, recursive );\n\n\t\t},\n\n\t\tcopy: function ( source, recursive ) {\n\n\t\t\tif ( recursive === undefined ) recursive = true;\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.up.copy( source.up );\n\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\tthis.visible = source.visible;\n\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\tvar count$2 = 0;\n\tfunction Object3DIdCount() { return count$2++; }\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Line3( start, end ) {\n\n\t\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n\t}\n\n\tLine3.prototype = {\n\n\t\tconstructor: Line3,\n\n\t\tset: function ( start, end ) {\n\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( line ) {\n\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetCenter: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t\t},\n\n\t\tdelta: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\n\t\t},\n\n\t\tdistanceSq: function () {\n\n\t\t\treturn this.start.distanceToSquared( this.end );\n\n\t\t},\n\n\t\tdistance: function () {\n\n\t\t\treturn this.start.distanceTo( this.end );\n\n\t\t},\n\n\t\tat: function ( t, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tclosestPointToPointParameter: function () {\n\n\t\t\tvar startP = new Vector3();\n\t\t\tvar startEnd = new Vector3();\n\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\t\tif ( clampToLine ) {\n\n\t\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t\treturn t;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t\t},\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tequals: function ( line ) {\n\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Triangle( a, b, c ) {\n\n\t\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n\t}\n\n\tTriangle.normal = function () {\n\n\t\tvar v0 = new Vector3();\n\n\t\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tresult.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\tresult.cross( v0 );\n\n\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t\t}\n\n\t\t\treturn result.set( 0, 0, 0 );\n\n\t\t};\n\n\t}();\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tTriangle.barycoordFromPoint = function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t\t}\n\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn result.set( 1 - u - v, v, u );\n\n\t\t};\n\n\t}();\n\n\tTriangle.containsPoint = function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t\t};\n\n\t}();\n\n\tTriangle.prototype = {\n\n\t\tconstructor: Triangle,\n\n\t\tset: function ( a, b, c ) {\n\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( triangle ) {\n\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tarea: function () {\n\n\t\t\tvar v0 = new Vector3();\n\t\t\tvar v1 = new Vector3();\n\n\t\t\treturn function area() {\n\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tmidpoint: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t\t},\n\n\t\tnormal: function ( optionalTarget ) {\n\n\t\t\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tplane: function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Plane();\n\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t\t},\n\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\t\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t\t},\n\n\t\tclosestPointToPoint: function () {\n\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\t\tif ( plane === undefined ) {\n\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tedgeList = [ new Line3(), new Line3(), new Line3() ];\n\t\t\t\t\tprojectedPoint = new Vector3();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar result = optionalTarget || new Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\n\t\t\t\t// project the point onto the plane of the triangle\n\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t\t// check if the projection lies within the triangle\n\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t\t// if so, this is the closest point\n\n\t\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tequals: function ( triangle ) {\n\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = (normal && normal.isVector3) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = (color && color.isColor) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\t}\n\n\tFace3.prototype = {\n\n\t\tconstructor: Face3,\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\n\t\t\tthis.materialIndex = source.materialIndex;\n\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\n\tfunction MeshBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\n\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferAttribute( array, itemSize, normalized ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized === true;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tBufferAttribute.prototype = {\n\n\t\tconstructor: BufferAttribute,\n\n\t\tisBufferAttribute: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyArray: function ( array ) {\n\n\t\t\tthis.array.set( array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyColorsArray: function ( colors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\tvar color = colors[ i ];\n\n\t\t\t\tif ( color === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new Color();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyIndicesArray: function ( indices ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tvar index = indices[ i ];\n\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector2sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector2();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector3sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyVector4sArray: function ( vectors ) {\n\n\t\t\tvar array = this.array, offset = 0;\n\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tvar vector = vectors[ i ];\n\n\t\t\t\tif ( vector === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new Vector4();\n\n\t\t\t\t}\n\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize ];\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex *= this.itemSize;\n\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Int8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n\t}\n\n\tfunction Int16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int16Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint16Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint16Array( array ), itemSize );\n\n\t}\n\n\tfunction Int32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Int32Array( array ), itemSize );\n\n\t}\n\n\tfunction Uint32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Uint32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float32Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float32Array( array ), itemSize );\n\n\t}\n\n\tfunction Float64Attribute( array, itemSize ) {\n\n\t\treturn new BufferAttribute( new Float64Array( array ), itemSize );\n\n\t}\n\n\t// Deprecated\n\n\tfunction DynamicBufferAttribute( array, itemSize ) {\n\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\n\tfunction Geometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\tthis.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( Geometry.prototype, EventDispatcher.prototype, {\n\n\t\tisGeometry: true,\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tfromBufferGeometry: function ( geometry ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\t\tscope.faces.push( face );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tnormalize: function () {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\t\tvar matrix = new Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\tthis.applyMatrix( matrix );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tvar face = this.faces[ f ];\n\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tface.normal.copy( cb );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t\tvertices = new Array( this.vertices.length );\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ] = new Vector3();\n\n\t\t\t}\n\n\t\t\tif ( areaWeighted ) {\n\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\t\tvertices[ v ].normalize();\n\n\t\t\t}\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeFlatVertexNormals: function () {\n\n\t\t\tvar f, fl, face;\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.faces.length > 0 ) {\n\n\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeMorphNormals: function () {\n\n\t\t\tvar i, il, f, fl, face;\n\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\t\tvar tmpGeo = new Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\t// create on first access\n\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t\t// set vertices to morph target\n\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t\t// compute morph normals\n\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t\t// store morph normals\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restore original normals\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeTangents: function () {\n\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t\t},\n\n\t\tcomputeLineDistances: function () {\n\n\t\t\tvar d = 0;\n\t\t\tvar vertices = this.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tif ( i > 0 ) {\n\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t\t},\n\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\t\tif ( (geometry && geometry.isGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\t\tif ( matrix !== undefined ) {\n\n\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t}\n\n\t\t\t// vertices\n\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\t\tvertices1.push( vertexCopy );\n\n\t\t\t}\n\n\t\t\t// colors\n\n\t\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t\t}\n\n\t\t\t// faces\n\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\t\tfaces1.push( faceCopy );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\t\tif ( uv === undefined ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tuvs1.push( uvCopy );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmergeMesh: function ( mesh ) {\n\n\t\t\tif ( (mesh && mesh.isMesh) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t\t},\n\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\n\t\tmergeVertices: function () {\n\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = this.faces[ i ];\n\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t\tvar dupIndex = - 1;\n\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Use unique set of vertices\n\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\n\t\t},\n\n\t\tsortFacesByMaterialIndex: function () {\n\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\n\t\t\t// tag faces\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tfaces[ i ]._id = i;\n\n\t\t\t}\n\n\t\t\t// sort faces\n\n\t\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t}\n\n\t\t\tfaces.sort( materialIndexSort );\n\n\t\t\t// sort uvs\n\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\t\tvar newUvs1, newUvs2;\n\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tvar id = faces[ i ]._id;\n\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t\t}\n\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard Geometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\t\tvar faceType = 0;\n\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\n\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t\t}\n\n\t\t\tfunction getNormalIndex( normal ) {\n\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getColorIndex( color ) {\n\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tfunction getUvIndex( uv ) {\n\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t\t}\n\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tdata.data = {};\n\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new Geometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\t\tthis.colors = [];\n\n\t\t\tvar vertices = source.vertices;\n\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar colors = source.colors;\n\n\t\t\tfor ( var i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tvar faces = source.faces;\n\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tvar count$3 = 0;\n\tfunction GeometryIdCount() { return count$3++; }\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'DirectGeometry';\n\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tObject.assign( DirectGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tcomputeBoundingBox: Geometry.prototype.computeBoundingBox,\n\t\tcomputeBoundingSphere: Geometry.prototype.computeBoundingSphere,\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t\t},\n\n\t\tcomputeGroups: function ( geometry ) {\n\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex;\n\n\t\t\tvar faces = geometry.faces;\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// materials\n\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( group !== undefined ) {\n\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\n\t\t\t}\n\n\t\t\tthis.groups = groups;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t\t// morphs\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\t\tvar morphTargetsPosition;\n\n\t\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\t\tmorphTargetsPosition = [];\n\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t\t}\n\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\t\tvar morphTargetsNormal;\n\n\t\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\t\tmorphTargetsNormal = [];\n\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t\t//\n\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar normal = face.normal;\n\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = face.color;\n\n\t\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// morphs\n\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t\t}\n\n\t\t\t\t// skins\n\n\t\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.computeGroups( geometry );\n\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometry() {\n\n\t\tObject.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t}\n\n\tObject.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\n\t\tisBufferGeometry: true,\n\n\t\tgetIndex: function () {\n\n\t\t\treturn this.index;\n\n\t\t},\n\n\t\tsetIndex: function ( index ) {\n\n\t\t\tthis.index = index;\n\n\t\t},\n\n\t\taddAttribute: function ( name, attribute ) {\n\n\t\t\tif ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\t\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( name === 'index' ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.attributes[ name ] = attribute;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetAttribute: function ( name ) {\n\n\t\t\treturn this.attributes[ name ];\n\n\t\t},\n\n\t\tremoveAttribute: function ( name ) {\n\n\t\t\tdelete this.attributes[ name ];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddGroup: function ( start, count, materialIndex ) {\n\n\t\t\tthis.groups.push( {\n\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t\t} );\n\n\t\t},\n\n\t\tclearGroups: function () {\n\n\t\t\tthis.groups = [];\n\n\t\t},\n\n\t\tsetDrawRange: function ( start, count ) {\n\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\n\t\t},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tvar normal = this.attributes.normal;\n\n\t\t\tif ( normal !== undefined ) {\n\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\tnormal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\trotateX: function () {\n\n\t\t\t// rotate geometry around world x-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateX( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationX( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateY: function () {\n\n\t\t\t// rotate geometry around world y-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateY( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationY( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trotateZ: function () {\n\n\t\t\t// rotate geometry around world z-axis\n\n\t\t\tvar m1;\n\n\t\t\treturn function rotateZ( angle ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeRotationZ( angle );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttranslate: function () {\n\n\t\t\t// translate geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function translate( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tscale: function () {\n\n\t\t\t// scale geometry\n\n\t\t\tvar m1;\n\n\t\t\treturn function scale( x, y, z ) {\n\n\t\t\t\tif ( m1 === undefined ) m1 = new Matrix4();\n\n\t\t\t\tm1.makeScale( x, y, z );\n\n\t\t\t\tthis.applyMatrix( m1 );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tlookAt: function () {\n\n\t\t\tvar obj;\n\n\t\t\treturn function lookAt( vector ) {\n\n\t\t\t\tif ( obj === undefined ) obj = new Object3D();\n\n\t\t\t\tobj.lookAt( vector );\n\n\t\t\t\tobj.updateMatrix();\n\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcenter: function () {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tvar offset = this.boundingBox.getCenter().negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn offset;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isPoints) || (object && object.isLine) ) {\n\n\t\t\t\tvar positions = new Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\t\tvar lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( (object && object.isMesh) ) {\n\n\t\t\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateFromObject: function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( (object && object.isMesh) ) {\n\n\t\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\t\tdirect = undefined;\n\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( direct === undefined ) {\n\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t\tgeometry = direct;\n\n\t\t\t}\n\n\t\t\tvar attribute;\n\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.normal;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\t\tattribute = this.attributes.color;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.uv;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromGeometry: function ( geometry ) {\n\n\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t\t},\n\n\t\tfromDirectGeometry: function ( geometry ) {\n\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t\t}\n\n\t\t\t// groups\n\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\t// morphs\n\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\t\tvar attribute = new Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t\t}\n\n\t\t\t// skinning\n\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\t\tvar skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\t\tvar skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position.array;\n\n\t\t\tif ( positions !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t\t} else {\n\n\t\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t\t}\n\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t},\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tvar box = new Box3();\n\t\t\tvar vector = new Vector3();\n\n\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t\t}\n\n\t\t\t\tvar positions = this.attributes.position;\n\n\t\t\t\tif ( positions ) {\n\n\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcomputeFaceNormals: function () {\n\n\t\t\t// backwards compatibility\n\n\t\t},\n\n\t\tcomputeVertexNormals: function () {\n\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( attributes.position ) {\n\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset existing normals to zero\n\n\t\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\tvar vA, vB, vC,\n\n\t\t\t\tpA = new Vector3(),\n\t\t\t\tpB = new Vector3(),\n\t\t\t\tpC = new Vector3(),\n\n\t\t\t\tcb = new Vector3(),\n\t\t\t\tab = new Vector3();\n\n\t\t\t\t// indexed elements\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\n\t\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmerge: function ( geometry, offset ) {\n\n\t\t\tif ( (geometry && geometry.isBufferGeometry) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tnormalizeNormals: function () {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\n\t\t\tvar x, y, z, n;\n\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoNonIndexed: function () {\n\n\t\t\tif ( this.index === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tvar geometry2 = new BufferGeometry();\n\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry2;\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\t\tif ( this.parameters !== undefined ) {\n\n\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tdata.data = { attributes: {} };\n\n\t\t\tvar index = this.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar attributes = this.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar groups = this.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = this.boundingSphere;\n\n\t\t\tif ( boundingSphere !== null ) {\n\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\t/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\n\t\t\treturn new BufferGeometry().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tvar index = source.index;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.setIndex( index.clone() );\n\n\t\t\t}\n\n\t\t\tvar attributes = source.attributes;\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t\t}\n\n\t\t\tvar groups = source.groups;\n\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t} );\n\n\tBufferGeometry.MaxIndex = 65535;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\n\tfunction Mesh( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t\tthis.drawMode = TrianglesDrawMode;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Mesh,\n\n\t\tisMesh: true,\n\n\t\tsetDrawMode: function ( value ) {\n\n\t\t\tthis.drawMode = value;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.drawMode = source.drawMode;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tupdateMorphTargets: function () {\n\n\t\t\tvar morphTargets = this.geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\tvar vA = new Vector3();\n\t\t\tvar vB = new Vector3();\n\t\t\tvar vC = new Vector3();\n\n\t\t\tvar tempA = new Vector3();\n\t\t\tvar tempB = new Vector3();\n\t\t\tvar tempC = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tvar barycoord = new Vector3();\n\n\t\t\tvar intersectionPoint = new Vector3();\n\t\t\tvar intersectionPointWorld = new Vector3();\n\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\t\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\t\treturn uv1.clone();\n\n\t\t\t}\n\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\t\tvar intersect;\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersect === null ) return null;\n\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t\t}\n\n\t\t\t\treturn intersection;\n\n\t\t\t}\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\tif ( material === undefined ) return;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\t// Check boundingBox before continuing\n\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t\t}\n\n\t\t\t\tvar uvs, intersection;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isFaceMaterial = (material && material.isMultiMaterial);\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tvar scope = this;\n\n\t\t// segments\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\tvar numberOfVertices = 0;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// build each side of the box geometry\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount( w, h, d ) {\n\n\t\t\tvar vertices = 0;\n\n\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\t\treturn vertices;\n\n\t\t}\n\n\t\tfunction calculateIndexCount( w, h, d ) {\n\n\t\t\tvar index = 0;\n\n\t\t\t// calculate the amount of squares for each side\n\t\t\tindex += w * h * 2; // xy\n\t\t\tindex += w * d * 2; // xz\n\t\t\tindex += d * h * 2; // zy\n\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t\t}\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t\t// uvs\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PlaneBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\t\tvar offset = 0;\n\t\tvar offset2 = 0;\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segment_height - height_half;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\t\tvertices[ offset ] = x;\n\t\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\toffset += 3;\n\t\t\t\toffset2 += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\toffset = 0;\n\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices[ offset ] = a;\n\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\t\toffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction Camera() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\t\tthis.projectionMatrix = new Matrix4();\n\n\t}\n\n\tCamera.prototype = Object.create( Object3D.prototype );\n\tCamera.prototype.constructor = Camera;\n\n\tCamera.prototype.isCamera = true;\n\n\tCamera.prototype.getWorldDirection = function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.lookAt = function () {\n\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}();\n\n\tCamera.prototype.clone = function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t};\n\n\tCamera.prototype.copy = function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\n\tfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: PerspectiveCamera,\n\n\t\tisPerspectiveCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\n\t\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t\t},\n\n\t\tgetEffectiveFOV: function () {\n\n\t\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t\t},\n\n\t\tgetFilmWidth: function () {\n\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t\t},\n\n\t\tgetFilmHeight: function () {\n\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t\t},\n\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\n\t\t\tif ( view !== null ) {\n\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\n\t\t\t}\n\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\n\t\t\tdata.object.aspect = this.aspect;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\n\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\t\tCamera.call( this );\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\t\tconstructor: OrthographicCamera,\n\n\t\tisOrthographicCamera: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tCamera.prototype.copy.call( this, source );\n\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tclearViewOffset: function() {\n\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\n\t\t},\n\n\t\tupdateProjectionMatrix: function () {\n\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\n\t\t\tif ( this.view !== null ) {\n\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tvar type, size;\n\n\t\tfunction setIndex( index ) {\n\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t\tsize = 4;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\tsize = 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawElements( mode, count, type, start * size );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry, start, count ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tsetMode: setMode,\n\t\t\tsetIndex: setIndex,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\n\n\t\tvar mode;\n\n\t\tfunction setMode( value ) {\n\n\t\t\tmode = value;\n\n\t\t}\n\n\t\tfunction render( start, count ) {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n\t\t}\n\n\t\tfunction renderInstances( geometry ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar position = geometry.attributes.position;\n\n\t\t\tvar count = 0;\n\n\t\t\tif ( (position && position.isInterleavedBufferAttribute) ) {\n\n\t\t\t\tcount = position.data.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t} else {\n\n\t\t\t\tcount = position.count;\n\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t\t}\n\n\t\t\tinfoRender.calls ++;\n\t\t\tinfoRender.vertices += count * geometry.maxInstancedCount;\n\n\t\t\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t\t}\n\n\t\treturn {\n\t\t\tsetMode: setMode,\n\t\t\trender: render,\n\t\t\trenderInstances: renderInstances\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLLights() {\n\n\t\tvar lights = {};\n\n\t\treturn {\n\n\t\t\tget: function ( light ) {\n\n\t\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\t\treturn lights[ light.id ];\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms;\n\n\t\t\t\tswitch ( light.type ) {\n\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\t\treturn uniforms;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\tfunction WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EquirectangularReflectionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material.isRawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\t\t\t\tcustomDefines,\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\t\t\t'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( ! material.isShaderMaterial ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLPrograms( renderer, capabilities ) {\n\n\t\tvar programs = [];\n\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points'\n\t\t};\n\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n\t\t];\n\n\n\t\tfunction allocateBones( object ) {\n\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\t\treturn 1024;\n\n\t\t\t} else {\n\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\t\tif ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\t\tvar encoding;\n\n\t\t\tif ( ! map ) {\n\n\t\t\t\tencoding = LinearEncoding;\n\n\t\t\t} else if ( (map && map.isTexture) ) {\n\n\t\t\t\tencoding = map.encoding;\n\n\t\t\t} else if ( (map && map.isWebGLRenderTarget) ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\n\t\t\t}\n\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\t\tencoding = GammaEncoding;\n\n\t\t\t}\n\n\t\t\treturn encoding;\n\n\t\t}\n\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tvar maxBones = allocateBones( object );\n\t\t\tvar precision = renderer.getPrecision();\n\n\t\t\tif ( material.precision !== null ) {\n\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\t\tvar parameters = {\n\n\t\t\t\tshaderID: shaderID,\n\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\t\tcombine: material.combine,\n\n\t\t\t\tvertexColors: material.vertexColors,\n\n\t\t\t\tfog: !! fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: (fog && fog.isFogExp2),\n\n\t\t\t\tflatShading: material.shading === FlatShading,\n\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\t\tskinning: material.skinning,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t\t};\n\n\t\t\treturn parameters;\n\n\t\t};\n\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\t\tvar array = [];\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tarray.push( parameters.shaderID );\n\n\t\t\t} else {\n\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\n\t\t\t}\n\n\t\t\tif ( material.defines !== undefined ) {\n\n\t\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t\t}\n\n\t\t\treturn array.join();\n\n\t\t};\n\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\t\tvar program;\n\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\t\tvar programInfo = programs[ p ];\n\n\t\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\tprogram = new WebGLProgram( renderer, code, material, parameters );\n\t\t\t\tprograms.push( program );\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t};\n\n\t\tthis.releaseProgram = function( program ) {\n\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLGeometries( gl, properties, info ) {\n\n\t\tvar geometries = {};\n\n\t\tfunction onGeometryDispose( event ) {\n\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t\t}\n\n\t\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\t\tdelete geometries[ geometry.id ];\n\n\t\t\t// TODO\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe ) {\n\n\t\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( geometry );\n\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t\t}\n\n\t\t\tproperties.delete( buffergeometry );\n\n\t\t\t//\n\n\t\t\tinfo.memory.geometries --;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction deleteAttribute( attribute ) {\n\n\t\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\t\tif ( buffer !== undefined ) {\n\n\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction deleteAttributes( attributes ) {\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tproperties.delete( attribute.data );\n\n\t\t\t} else {\n\n\t\t\t\tproperties.delete( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\t\t\treturn geometries[ geometry.id ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t\tvar buffergeometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tbuffergeometry = geometry;\n\n\t\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t\t\t}\n\n\t\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\t\t\tinfo.memory.geometries ++;\n\n\t\t\t\treturn buffergeometry;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLObjects( gl, properties, info ) {\n\n\t\tvar geometries = new WebGLGeometries( gl, properties, info );\n\n\t\t//\n\n\t\tfunction update( object ) {\n\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\t\tvar geometry = geometries.get( object );\n\n\t\t\tif ( object.geometry.isGeometry ) {\n\n\t\t\t\tgeometry.updateFromObject( object );\n\n\t\t\t}\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var name in morphAttributes ) {\n\n\t\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\t\tvar data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\t\tvar attributeProperties = properties.get( data );\n\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\t\tif ( data.dynamic === false ) {\n\n\t\t\t\tgl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\n\t\t\t} else if ( data.updateRange.count === - 1 ) {\n\n\t\t\t\t// Not using update ranges\n\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t\t}\n\n\t\t\tattributeProperties.version = data.version;\n\n\t\t}\n\n\t\tfunction getAttributeBuffer( attribute ) {\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t\t}\n\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t\t}\n\n\t\tfunction getWireframeAttribute( geometry ) {\n\n\t\t\tvar property = properties.get( geometry );\n\n\t\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\t\treturn property.wireframe;\n\n\t\t\t}\n\n\t\t\tvar indices = [];\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar position = attributes.position;\n\n\t\t\t// console.time( 'wireframe' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar edges = {};\n\t\t\t\tvar array = index.array;\n\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar array = attributes.position.array;\n\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// console.timeEnd( 'wireframe' );\n\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar attribute = new BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t\tproperty.wireframe = attribute;\n\n\t\t\treturn attribute;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tgetAttributeBuffer: getAttributeBuffer,\n\t\t\tgetWireframeAttribute: getWireframeAttribute,\n\n\t\t\tupdate: update\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\t\tvar _infoMemory = info.memory;\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t\t//\n\n\t\tfunction clampToMaxSize( image, maxSize ) {\n\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t\t}\n\n\t\tfunction makePowerOfTwo( image ) {\n\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = _Math.nearestPowerOfTwo( image.width );\n\t\t\t\tcanvas.height = _Math.nearestPowerOfTwo( image.height );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\t\treturn canvas;\n\n\t\t\t}\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// Fallback filters for non-power-of-2 textures\n\n\t\tfunction filterFallback( f ) {\n\n\t\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\t\treturn _gl.NEAREST;\n\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction onTextureDispose( event ) {\n\n\t\t\tvar texture = event.target;\n\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\t\tdeallocateTexture( texture );\n\n\t\t\t_infoMemory.textures --;\n\n\n\t\t}\n\n\t\tfunction onRenderTargetDispose( event ) {\n\n\t\t\tvar renderTarget = event.target;\n\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t\t_infoMemory.textures --;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction deallocateTexture( texture ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t\t} else {\n\n\t\t\t\t// 2D texture\n\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\t// remove all webgl properties\n\t\t\tproperties.delete( texture );\n\n\t\t}\n\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\tif ( ! renderTarget ) return;\n\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t\t}\n\n\t\t\tif ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t\t}\n\n\t\t\tproperties.delete( renderTarget.texture );\n\t\t\tproperties.delete( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\n\n\t\tfunction setTexture2D( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tvar image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureCube( texture, slot ) {\n\n\t\t\tvar textureProperties = properties.get( texture );\n\n\t\t\tif ( texture.image.length === 6 ) {\n\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\t\tvar isCompressed = (texture && texture.isCompressedTexture);\n\t\t\t\t\tvar isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);\n\n\t\t\t\t\tvar cubeImage = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t\t}\n\n\t\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension ) {\n\n\t\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t}\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\t\timage = makePowerOfTwo( image );\n\n\t\t\t}\n\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( (texture && texture.isDepthTexture) ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\t}\n\n\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\t\tinternalFormat = _gl.DEPTH_STENCIL;\n\n\t\t\t\t}\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t} else if ( (texture && texture.isDataTexture) ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( (texture && texture.isCompressedTexture) ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\t// Render targets\n\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t} else {\n\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t}\n\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {\n\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t\t}\n\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('Unknown depthTexture format')\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\n\t\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t\tvar isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t\t// Setup framebuffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t\t// Setup color buffer\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t// Setup depth and stencil buffers\n\n\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\t\tvar texture = renderTarget.texture;\n\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\ttexture.minFilter !== NearestFilter &&\n\t\t\t\t\ttexture.minFilter !== LinearFilter ) {\n\n\t\t\t\tvar target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n\t}\n\n\t/**\n\t * @author fordacious / fordacious.github.io\n\t */\n\n\tfunction WebGLProperties() {\n\n\t\tvar properties = {};\n\n\t\treturn {\n\n\t\t\tget: function ( object ) {\n\n\t\t\t\tvar uuid = object.uuid;\n\t\t\t\tvar map = properties[ uuid ];\n\n\t\t\t\tif ( map === undefined ) {\n\n\t\t\t\t\tmap = {};\n\t\t\t\t\tproperties[ uuid ] = map;\n\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\n\t\t\t},\n\n\t\t\tdelete: function ( object ) {\n\n\t\t\t\tdelete properties[ object.uuid ];\n\n\t\t\t},\n\n\t\t\tclear: function () {\n\n\t\t\t\tproperties = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLState( gl, extensions, paramThreeToGL ) {\n\n\t\tfunction ColorBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar color = new Vector4();\n\t\t\tvar currentColorMask = null;\n\t\t\tvar currentColorClear = new Vector4();\n\n\t\t\treturn {\n\n\t\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( r, g, b, a ) {\n\n\t\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set( 0, 0, 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentDepthMask = null;\n\t\t\tvar currentDepthFunc = null;\n\t\t\tvar currentDepthClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\n\t\t\tvar locked = false;\n\n\t\t\tvar currentStencilMask = null;\n\t\t\tvar currentStencilFunc = null;\n\t\t\tvar currentStencilRef = null;\n\t\t\tvar currentStencilFuncMask = null;\n\t\t\tvar currentStencilFail  = null;\n\t\t\tvar currentStencilZFail = null;\n\t\t\tvar currentStencilZPass = null;\n\t\t\tvar currentStencilClear = null;\n\n\t\t\treturn {\n\n\t\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\t\tlocked = lock;\n\n\t\t\t\t},\n\n\t\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\treset: function () {\n\n\t\t\t\t\tlocked = false;\n\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tvar colorBuffer = new ColorBuffer();\n\t\tvar depthBuffer = new DepthBuffer();\n\t\tvar stencilBuffer = new StencilBuffer();\n\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\t\tvar capabilities = {};\n\n\t\tvar compressedTextureFormats = null;\n\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\n\t\tvar currentLineWidth = null;\n\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\n\t\tvar currentScissorTest = null;\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\n\t\tvar currentScissor = new Vector4();\n\t\tvar currentViewport = new Vector4();\n\n\t\tfunction createTexture( type, target, count ) {\n\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t\t//\n\n\t\tfunction init() {\n\n\t\t\tclearColor( 0, 0, 0, 1 );\n\t\t\tclearDepth( 1 );\n\t\t\tclearStencil( 0 );\n\n\t\t\tenable( gl.DEPTH_TEST );\n\t\t\tsetDepthFunc( LessEqualDepth );\n\n\t\t\tsetFlipSided( false );\n\t\t\tsetCullFace( CullFaceBack );\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tenable( gl.BLEND );\n\t\t\tsetBlending( NormalBlending );\n\n\t\t}\n\n\t\tfunction initAttributes() {\n\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tnewAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttribute( attribute ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\n\t\t\tnewAttributes[ attribute ] = 1;\n\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t\t}\n\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction enable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction disable( id ) {\n\n\t\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getCompressedTextureFormats() {\n\n\t\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\t\tcompressedTextureFormats = [];\n\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn compressedTextureFormats;\n\n\t\t}\n\n\t\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\t\tif ( blending !== NoBlending ) {\n\n\t\t\t\tenable( gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.BLEND );\n\n\t\t\t}\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( blending === AdditiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === SubtractiveBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( blending === MultiplyBlending ) {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blending === CustomBlending ) {\n\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t\t}\n\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction setColorWrite( colorWrite ) {\n\n\t\t\tcolorBuffer.setMask( colorWrite );\n\n\t\t}\n\n\t\tfunction setDepthTest( depthTest ) {\n\n\t\t\tdepthBuffer.setTest( depthTest );\n\n\t\t}\n\n\t\tfunction setDepthWrite( depthWrite ) {\n\n\t\t\tdepthBuffer.setMask( depthWrite );\n\n\t\t}\n\n\t\tfunction setDepthFunc( depthFunc ) {\n\n\t\t\tdepthBuffer.setFunc( depthFunc );\n\n\t\t}\n\n\t\tfunction setStencilTest( stencilTest ) {\n\n\t\t\tstencilBuffer.setTest( stencilTest );\n\n\t\t}\n\n\t\tfunction setStencilWrite( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( stencilWrite );\n\n\t\t}\n\n\t\tfunction setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\tstencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t}\n\n\t\tfunction setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\tstencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction setFlipSided( flipSided ) {\n\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\t\tif ( flipSided ) {\n\n\t\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setCullFace( cullFace ) {\n\n\t\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\t\tenable( gl.CULL_FACE );\n\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\n\t\t}\n\n\t\tfunction setLineWidth( width ) {\n\n\t\t\tif ( width !== currentLineWidth ) {\n\n\t\t\t\tgl.lineWidth( width );\n\n\t\t\t\tcurrentLineWidth = width;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\t\tif ( polygonOffset ) {\n\n\t\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getScissorTest() {\n\n\t\t\treturn currentScissorTest;\n\n\t\t}\n\n\t\tfunction setScissorTest( scissorTest ) {\n\n\t\t\tcurrentScissorTest = scissorTest;\n\n\t\t\tif ( scissorTest ) {\n\n\t\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t\t} else {\n\n\t\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// texture\n\n\t\tfunction activeTexture( webglSlot ) {\n\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\tactiveTexture();\n\n\t\t\t}\n\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\t\tif ( boundTexture === undefined ) {\n\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t\t}\n\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction texImage2D() {\n\n\t\t\ttry {\n\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.error( error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Deprecate\n\n\t\tfunction clearColor( r, g, b, a ) {\n\n\t\t\tcolorBuffer.setClear( r, g, b, a );\n\n\t\t}\n\n\t\tfunction clearDepth( depth ) {\n\n\t\t\tdepthBuffer.setClear( depth );\n\n\t\t}\n\n\t\tfunction clearStencil( stencil ) {\n\n\t\t\tstencilBuffer.setClear( stencil );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction scissor( scissor ) {\n\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction viewport( viewport ) {\n\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction reset() {\n\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcapabilities = {};\n\n\t\t\tcompressedTextureFormats = null;\n\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\n\t\t\tcurrentBlending = null;\n\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\n\t\t\tinit: init,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\t\tsetBlending: setBlending,\n\n\t\t\tsetColorWrite: setColorWrite,\n\t\t\tsetDepthTest: setDepthTest,\n\t\t\tsetDepthWrite: setDepthWrite,\n\t\t\tsetDepthFunc: setDepthFunc,\n\t\t\tsetStencilTest: setStencilTest,\n\t\t\tsetStencilWrite: setStencilWrite,\n\t\t\tsetStencilFunc: setStencilFunc,\n\t\t\tsetStencilOp: setStencilOp,\n\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\t\tgetScissorTest: getScissorTest,\n\t\t\tsetScissorTest: setScissorTest,\n\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\n\t\t\tclearColor: clearColor,\n\t\t\tclearDepth: clearDepth,\n\t\t\tclearStencil: clearStencil,\n\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\n\t\t\treset: reset\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\t\tvar maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t\t} else {\n\n\t\t\t\tmaxAnisotropy = 0;\n\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\n\t\t}\n\n\t\tfunction getMaxPrecision( precision ) {\n\n\t\t\tif ( precision === 'highp' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'highp';\n\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\n\t\t\t}\n\n\t\t\tif ( precision === 'mediump' ) {\n\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\t\treturn 'mediump';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\n\t\t}\n\n\t\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tvar maxPrecision = getMaxPrecision( precision );\n\n\t\tif ( maxPrecision !== precision ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\t\tprecision = maxPrecision;\n\n\t\t}\n\n\t\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\t\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\t\tvar vertexTextures = maxVertexTextures > 0;\n\t\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\t\treturn {\n\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WebGLExtensions( gl ) {\n\n\t\tvar extensions = {};\n\n\t\treturn {\n\n\t\t\tget: function ( name ) {\n\n\t\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\t\treturn extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tvar extension;\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t\t}\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\textensions[ name ] = extension;\n\n\t\t\t\treturn extension;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction WebGLClipping() {\n\n\t\tvar scope = this,\n\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\n\t\t\tplane = new Plane(),\n\t\t\tviewNormalMatrix = new Matrix3(),\n\n\t\t\tuniform = { value: null, needsUpdate: false };\n\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\n\t\t\treturn enabled;\n\n\t\t};\n\n\t\tthis.beginShadows = function() {\n\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\n\t\t};\n\n\t\tthis.endShadows = function() {\n\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\n\t\t};\n\n\t\tthis.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t// there's no local clipping\n\n\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t// there's no global clipping\n\n\t\t\t\t\tprojectPlanes( null );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\n\t\t\tif ( uniform.value !== globalState ) {\n\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\n\t\t}\n\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\n\t\t\tif ( nPlanes !== 0 ) {\n\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\t\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\n\tfunction WebGLRenderer( parameters ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\t\tparameters = parameters || {};\n\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\t\tvar lights = [];\n\n\t\tvar opaqueObjects = [];\n\t\tvar opaqueObjectsLastIndex = - 1;\n\t\tvar transparentObjects = [];\n\t\tvar transparentObjectsLastIndex = - 1;\n\n\t\tvar morphInfluences = new Float32Array( 8 );\n\n\t\tvar sprites = [];\n\t\tvar lensFlares = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\n\t\t// physical lights\n\n\t\tthis.physicallyCorrectLights = false;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\n\t\t// morphs\n\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\n\t\t// internal properties\n\n\t\tvar _this = this,\n\n\t\t// internal state cache\n\n\t\t_currentProgram = null,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\t\t_currentGeometryProgram = '',\n\t\t_currentCamera = null,\n\n\t\t_currentScissor = new Vector4(),\n\t\t_currentScissorTest = null,\n\n\t\t_currentViewport = new Vector4(),\n\n\t\t//\n\n\t\t_usedTextureUnits = 0,\n\n\t\t//\n\n\t\t_clearColor = new Color( 0x000000 ),\n\t\t_clearAlpha = 0,\n\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\n\t\t_pixelRatio = 1,\n\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\n\t\t// frustum\n\n\t\t_frustum = new Frustum(),\n\n\t\t// clipping\n\n\t\t_clipping = new WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\n\t\t_sphere = new Sphere(),\n\n\t\t// camera matrices cache\n\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_vector3 = new Vector3(),\n\n\t\t// light arrays cache\n\n\t\t_lights = {\n\n\t\t\thash: '',\n\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: [],\n\n\t\t\tshadows: []\n\n\t\t},\n\n\t\t// info\n\n\t\t_infoRender = {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t};\n\n\t\tthis.info = {\n\n\t\t\trender: _infoRender,\n\t\t\tmemory: {\n\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\n\t\t\t},\n\t\t\tprograms: null\n\n\t\t};\n\n\n\t\t// initialize\n\n\t\tvar _gl;\n\n\t\ttry {\n\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t\t}\n\n\t\tvar extensions = new WebGLExtensions( _gl );\n\n\t\textensions.get( 'WEBGL_depth_texture' );\n\t\textensions.get( 'OES_texture_float' );\n\t\textensions.get( 'OES_texture_float_linear' );\n\t\textensions.get( 'OES_texture_half_float' );\n\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\textensions.get( 'OES_standard_derivatives' );\n\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\tBufferGeometry.MaxIndex = 4294967296;\n\n\t\t}\n\n\t\tvar capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\tvar state = new WebGLState( _gl, extensions, paramThreeToGL );\n\t\tvar properties = new WebGLProperties();\n\t\tvar textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\tvar objects = new WebGLObjects( _gl, properties, this.info );\n\t\tvar programCache = new WebGLPrograms( this, capabilities );\n\t\tvar lightCache = new WebGLLights();\n\n\t\tthis.info.programs = programCache.programs;\n\n\t\tvar bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\tvar indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t\t//\n\n\t\tvar backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tvar backgroundCamera2 = new PerspectiveCamera();\n\t\tvar backgroundPlaneMesh = new Mesh(\n\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t);\n\t\tvar backgroundBoxShader = ShaderLib[ 'cube' ];\n\t\tvar backgroundBoxMesh = new Mesh(\n\t\t\tnew BoxBufferGeometry( 5, 5, 5 ),\n\t\t\tnew ShaderMaterial( {\n\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tfog: false\n\t\t\t} )\n\t\t);\n\n\t\t//\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\tfunction glClearColor( r, g, b, a ) {\n\n\t\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t}\n\n\t\t\tstate.clearColor( r, g, b, a );\n\n\t\t}\n\n\t\tfunction setDefaultGLState() {\n\n\t\t\tstate.init();\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t}\n\n\t\tfunction resetGLState() {\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\n\t\t\tstate.reset();\n\n\t\t}\n\n\t\tsetDefaultGLState();\n\n\t\tthis.context = _gl;\n\t\tthis.capabilities = capabilities;\n\t\tthis.extensions = extensions;\n\t\tthis.properties = properties;\n\t\tthis.state = state;\n\n\t\t// shadow map\n\n\t\tvar shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\n\t\tthis.shadowMap = shadowMap;\n\n\n\t\t// Plugins\n\n\t\tvar spritePlugin = new SpritePlugin( this, sprites );\n\t\tvar lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t\t};\n\n\t\tthis.getMaxAnisotropy = function () {\n\n\t\t\treturn capabilities.getMaxAnisotropy();\n\n\t\t};\n\n\t\tthis.getPrecision = function () {\n\n\t\t\treturn capabilities.precision;\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t\t};\n\n\t\tthis.getSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\n\t\t\tif ( updateStyle !== false ) {\n\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function () {\n\n\t\t\treturn _clearColor;\n\n\t\t};\n\n\t\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t\t_clearColor.set( color );\n\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn _clearAlpha;\n\n\t\t};\n\n\t\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t\t_clearAlpha = alpha;\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t};\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\tvar bits = 0;\n\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\n\t\t};\n\n\t\t// Reset\n\n\t\tthis.resetGLState = resetGLState;\n\n\t\tthis.dispose = function() {\n\n\t\t\ttransparentObjects = [];\n\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\topaqueObjects = [];\n\t\t\topaqueObjectsLastIndex = -1;\n\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tresetGLState();\n\t\t\tsetDefaultGLState();\n\n\t\t\tproperties.clear();\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tvar material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\tproperties.delete( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReference( material ) {\n\n\t\t\tvar programInfo = properties.get( material ).program;\n\n\t\t\tmaterial.program = undefined;\n\n\t\t\tif ( programInfo !== undefined ) {\n\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar buffers = properties.get( object );\n\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( object.hasPositions ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasNormals ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\t\tif ( ! material.isMeshPhongMaterial &&\n\t\t\t\t     ! material.isMeshStandardMaterial &&\n\t\t\t\t       material.shading === FlatShading ) {\n\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( object.hasColors && material.vertexColors !== NoColors ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\t\tobject.count = 0;\n\n\t\t};\n\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\t\tsetMaterial( material );\n\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\tvar updateBuffers = false;\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t// morph targets\n\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\t\tvar activeInfluences = [];\n\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t\t}\n\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\n\t\t\t\t\tmorphInfluences[ i ] = 0.0;\n\n\t\t\t\t}\n\n\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\t\tvar rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\tvar renderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( index );\n\n\t\t\t} else {\n\n\t\t\t\trenderer = bufferRenderer;\n\n\t\t\t}\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar dataCount = 0;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdataCount = index.count;\n\n\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\tdataCount = position.count;\n\n\t\t\t}\n\n\t\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t\tif ( drawCount === 0 ) return;\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t}\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\t\tif ( extension === null ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\t\tstate.initAttributes();\n\n\t\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t\tvar programAttributes = program.getAttributes();\n\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor ( var name in programAttributes ) {\n\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"Unsupported data buffer format: Float64Array\" );\n\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.disableUnusedAttributes();\n\n\t\t}\n\n\t\t// Sorting\n\n\t\tfunction absNumericalSort( a, b ) {\n\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t\t}\n\n\t\tfunction painterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\n\t\t\t\treturn a.material.program.id - b.material.program.id;\n\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\t\treturn a.material.id - b.material.id;\n\n\t\t\t} else if ( a.z !== b.z ) {\n\n\t\t\t\treturn a.z - b.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction reversePainterSortStable( a, b ) {\n\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t\t} if ( a.z !== b.z ) {\n\n\t\t\t\treturn b.z - a.z;\n\n\t\t\t} else {\n\n\t\t\t\treturn a.id - b.id;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// reset caching for this frame\n\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\tlights.length = 0;\n\n\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\ttransparentObjectsLastIndex = - 1;\n\n\t\t\tsprites.length = 0;\n\t\t\tlensFlares.length = 0;\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\t\tprojectObject( scene, camera );\n\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\t\tsetupShadows( lights );\n\n\t\t\tshadowMap.render( scene, camera );\n\n\t\t\tsetupLights( lights, camera );\n\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t\t//\n\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\trenderTarget = null;\n\n\t\t\t}\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t\t//\n\n\t\t\tvar background = scene.background;\n\n\t\t\tif ( background === null ) {\n\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t\t} else if ( background && background.isColor ) {\n\n\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\t\t\tforceClear = true;\n\n\t\t\t}\n\n\t\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t\t}\n\n\t\t\tif ( background && background.isCubeTexture ) {\n\n\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\t\tobjects.update( backgroundBoxMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t\t} else if ( background && background.isTexture ) {\n\n\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\t\tobjects.update( backgroundPlaneMesh );\n\n\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.overrideMaterial ) {\n\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\t\trenderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\t\trenderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t\t} else {\n\n\t\t\t\t// opaque pass (front-to-back order)\n\n\t\t\t\tstate.setBlending( NoBlending );\n\t\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\t\t// transparent pass (back-to-front order)\n\n\t\t\t\trenderObjects( transparentObjects, scene, camera );\n\n\t\t\t}\n\n\t\t\t// custom render plugins (post pass)\n\n\t\t\tspritePlugin.render( scene, camera );\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t\t}\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.setDepthTest( true );\n\t\t\tstate.setDepthWrite( true );\n\t\t\tstate.setColorWrite( true );\n\n\t\t\t// _gl.finish();\n\n\t\t};\n\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\t\tvar array, index;\n\n\t\t\t// allocate the next position in the appropriate array\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tarray = transparentObjects;\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t\t} else {\n\n\t\t\t\tarray = opaqueObjects;\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t\t}\n\n\t\t\t// recycle existing render item or grow the array\n\n\t\t\tvar renderItem = array[ index ];\n\n\t\t\tif ( renderItem !== undefined ) {\n\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\trenderItem.group = group;\n\n\t\t\t} else {\n\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\n\t\t\t\t// assert( index === array.length );\n\t\t\t\tarray.push( renderItem );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO Duplicated code (Frustum)\n\n\t\tfunction isObjectViewable( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSpriteViewable( sprite ) {\n\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn isSphereViewable( _sphere );\n\n\t\t}\n\n\t\tfunction isSphereViewable( sphere ) {\n\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\t\tif ( numPlanes === 0 ) return true;\n\n\t\t\tvar planes = _this.clippingPlanes,\n\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\n\t\t\tdo {\n\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t\t} while ( ++ i !== numPlanes );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction projectObject( object, camera ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tvar visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isLight ) {\n\n\t\t\t\t\tlights.push( object );\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isLensFlare ) {\n\n\t\t\t\t\tlensFlares.push( object );\n\n\t\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\t\tif ( material.isMultiMaterial ) {\n\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\t\t\tsetMaterial( material );\n\n\t\t\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t\t\t}\n\n\t\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction initMaterial( material, fog, object ) {\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\n\t\t\tif ( program === undefined ) {\n\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t} else if ( program.code !== code ) {\n\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\n\t\t\t}\n\n\t\t\tif ( programChange ) {\n\n\t\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\n\t\t\t}\n\n\t\t\tvar attributes = program.getAttributes();\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( ! material.isShaderMaterial &&\n\t\t\t     ! material.isRawShaderMaterial ||\n\t\t\t       material.clipping === true ) {\n\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t\t}\n\n\t\t\tmaterialProperties.fog = fog;\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t\t}\n\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\t}\n\n\t\tfunction setMaterial( material ) {\n\n\t\t\tmaterial.side === DoubleSide\n\t\t\t\t? state.disable( _gl.CULL_FACE )\n\t\t\t\t: state.enable( _gl.CULL_FACE );\n\n\t\t\tstate.setFlipSided( material.side === BackSide );\n\n\t\t\tmaterial.transparent === true\n\t\t\t\t? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n\t\t\t\t: state.setBlending( NoBlending );\n\n\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t}\n\n\t\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t\t_usedTextureUnits = 0;\n\n\t\t\tvar materialProperties = properties.get( material );\n\n\t\t\tif ( _clippingEnabled ) {\n\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate === false ) {\n\n\t\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes || \n\t \t\t\t\t  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.needsUpdate ) {\n\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t_currentProgram = program.id;\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.envMap ) {\n\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isShaderMaterial ||\n\t\t\t\t     material.skinning ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t\t}\n\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\n\t\t\tif ( material.skinning ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tif ( material.lights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshBasicMaterial ||\n\t\t\t\t     material.isMeshLambertMaterial ||\n\t\t\t\t     material.isMeshPhongMaterial ||\n\t\t\t\t     material.isMeshStandardMaterial ||\n\t\t\t\t     material.isMeshDepthMaterial ) {\n\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh single material specific uniforms\n\n\t\t\t\tif ( material.isLineBasicMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t\t}\n\n\t\t\t\tWebGLUniforms.upload(\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t\t}\n\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// Uniforms (refresh uniforms objects)\n\n\t\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t\tif ( material.emissive ) {\n\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t}\n\n\t\t\tuniforms.map.value = material.map;\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\tif ( material.aoMap ) {\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\n\t\t\tvar uvScaleMap;\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t} else if ( material.roughnessMap ) {\n\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t\t} else if ( material.metalnessMap ) {\n\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t}\n\n\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t}\n\n\t\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\n\t\t}\n\n\t\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _height * 0.5;\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tvar offset = material.map.offset;\n\t\t\t\tvar repeat = material.map.repeat;\n\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\t\tuniforms.fogColor.value = fog.color;\n\n\t\t\tif ( fog.isFog ) {\n\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif ( material.roughnessMap ) {\n\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.metalnessMap ) {\n\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\t}\n\n\t\t\tif ( material.lightMap ) {\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t}\n\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\t}\n\n\t\t\tif ( material.bumpMap ) {\n\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\t}\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\t}\n\n\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t}\n\n\t\t\tif ( material.envMap ) {\n\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\t// Lighting\n\n\t\tfunction setupShadows( lights ) {\n\n\t\t\tvar lightShadowsLength = 0;\n\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.shadows.length = lightShadowsLength;\n\n\t\t}\n\n\t\tfunction setupLights( lights, camera ) {\n\n\t\t\tvar l, ll, light,\n\t\t\tr = 0, g = 0, b = 0,\n\t\t\tcolor,\n\t\t\tintensity,\n\t\t\tdistance,\n\t\t\tshadowMap,\n\n\t\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\t\tdirectionalLength = 0,\n\t\t\tpointLength = 0,\n\t\t\tspotLength = 0,\n\t\t\themiLength = 0;\n\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\t\tlight = lights[ l ];\n\n\t\t\t\tcolor = light.color;\n\t\t\t\tintensity = light.intensity;\n\t\t\t\tdistance = light.distance;\n\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\n\t\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t_lights.ambient[ 2 ] = b;\n\n\t\t\t_lights.directional.length = directionalLength;\n\t\t\t_lights.spot.length = spotLength;\n\t\t\t_lights.point.length = pointLength;\n\t\t\t_lights.hemi.length = hemiLength;\n\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t\t}\n\n\t\t// GL state setting\n\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\t\tstate.setCullFace( cullFace );\n\t\t\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\n\t\t};\n\n\t\t// Textures\n\n\t\tfunction allocTextureUnit() {\n\n\t\t\tvar textureUnit = _usedTextureUnits;\n\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t\t}\n\n\t\t\t_usedTextureUnits += 1;\n\n\t\t\treturn textureUnit;\n\n\t\t}\n\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTexture = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTexture( texture, slot ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.setTextureCube = ( function() {\n\n\t\t\tvar warned = false;\n\n\t\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture = texture.texture;\n\n\t\t\t\t}\n\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() );\n\n\t\tthis.getCurrentRenderTarget = function() {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t}\n\n\t\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\t\tvar framebuffer;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t\t}\n\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = null;\n\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t\t}\n\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tstate.viewport( _currentViewport );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\t\tif ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tvar restore = false;\n\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t\trestore = true;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\t\tif ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Map three.js constants to WebGL constants\n\n\t\tfunction paramThreeToGL( p ) {\n\n\t\t\tvar extension;\n\n\t\t\tif ( p === RepeatWrapping ) return _gl.REPEAT;\n\t\t\tif ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\t\tif ( p === NearestFilter ) return _gl.NEAREST;\n\t\t\tif ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\t\tif ( p === LinearFilter ) return _gl.LINEAR;\n\t\t\tif ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\t\tif ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\tif ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\t\tif ( p === ByteType ) return _gl.BYTE;\n\t\t\tif ( p === ShortType ) return _gl.SHORT;\n\t\t\tif ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\tif ( p === IntType ) return _gl.INT;\n\t\t\tif ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\tif ( p === FloatType ) return _gl.FLOAT;\n\n\t\t\tif ( p === HalfFloatType ) {\n\n\t\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t\t}\n\n\t\t\tif ( p === AlphaFormat ) return _gl.ALPHA;\n\t\t\tif ( p === RGBFormat ) return _gl.RGB;\n\t\t\tif ( p === RGBAFormat ) return _gl.RGBA;\n\t\t\tif ( p === LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\tif ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\t\tif ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\n\t\t\tif ( p === AddEquation ) return _gl.FUNC_ADD;\n\t\t\tif ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\tif ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\t\tif ( p === ZeroFactor ) return _gl.ZERO;\n\t\t\tif ( p === OneFactor ) return _gl.ONE;\n\t\t\tif ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\tif ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\tif ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\tif ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\t\tif ( p === DstColorFactor ) return _gl.DST_COLOR;\n\t\t\tif ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\t\t p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t}\n\n\t\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction FogExp2 ( color, density ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tFogExp2.prototype.clone = function () {\n\n\t\treturn new FogExp2( this.color.getHex(), this.density );\n\n\t};\n\n\tFogExp2.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Fog ( color, near, far ) {\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tFog.prototype.clone = function () {\n\n\t\treturn new Fog( this.color.getHex(), this.near, this.far );\n\n\t};\n\n\tFog.prototype.toJSON = function ( meta ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Scene () {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\n\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t}\n\n\tScene.prototype = Object.create( Object3D.prototype );\n\n\tScene.prototype.constructor = Scene;\n\n\tScene.prototype.copy = function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t};\n\n\tScene.prototype.toJSON = function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction LensFlare( texture, size, distance, blending, color ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.lensFlares = [];\n\n\t\tthis.positionScreen = new Vector3();\n\t\tthis.customUpdateCallback = undefined;\n\n\t\tif ( texture !== undefined ) {\n\n\t\t\tthis.add( texture, size, distance, blending, color );\n\n\t\t}\n\n\t}\n\n\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LensFlare,\n\n\t\tisLensFlare: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\t\tif ( size === undefined ) size = - 1;\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\tif ( color === undefined ) color = new Color( 0xffffff );\n\t\t\tif ( blending === undefined ) blending = NormalBlending;\n\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\t\tthis.lensFlares.push( {\n\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\tcolor: color,\t\t// color\n\t\t\t\tblending: blending\t// blending\n\t\t\t} );\n\n\t\t},\n\n\t\t/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\n\t\tupdateLensFlares: function () {\n\n\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\tvar flare;\n\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\n\tfunction SpriteMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\t\tthis.map = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tSpriteMaterial.prototype = Object.create( Material.prototype );\n\tSpriteMaterial.prototype.constructor = SpriteMaterial;\n\n\tSpriteMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\n\t\tthis.rotation = source.rotation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Sprite( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Sprite';\n\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t}\n\n\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Sprite,\n\n\t\tisSprite: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\tpoint: this.position,\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LOD() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\n\t}\n\n\n\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: LOD,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\t\tvar levels = source.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\taddLevel: function ( object, distance ) {\n\n\t\t\tif ( distance === undefined ) distance = 0;\n\n\t\t\tdistance = Math.abs( distance );\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\t\tthis.add( object );\n\n\t\t},\n\n\t\tgetObjectForDistance: function ( distance ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t},\n\n\t\traycast: ( function () {\n\n\t\t\tvar matrixPosition = new Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tupdate: function () {\n\n\t\t\tvar v1 = new Vector3();\n\t\t\tvar v2 = new Vector3();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar levels = this.levels;\n\n\t\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.levels = [];\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tvar level = levels[ i ];\n\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.generateMipmaps  = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n\tDataTexture.prototype = Object.create( Texture.prototype );\n\tDataTexture.prototype.constructor = DataTexture;\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Skeleton( bones, boneInverses, useVertexTexture ) {\n\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t\tthis.identityMatrix = new Matrix4();\n\n\t\t// copy the bone array\n\n\t\tbones = bones || [];\n\n\t\tthis.bones = bones.slice( 0 );\n\n\t\t// create a bone texture or an array of floats\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\tsize = _Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\tsize = Math.max( size, 4 );\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t\t}\n\n\t\t// use the supplied bone inverses or calculate the inverses\n\n\t\tif ( boneInverses === undefined ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tObject.assign( Skeleton.prototype, {\n\n\t\tcalculateInverses: function () {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tvar inverse = new Matrix4();\n\n\t\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tvar bone;\n\n\t\t\t// recover the bind-time world matrices\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// compute the local matrices, positions, rotations and scales\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tbone = this.bones[ b ];\n\n\t\t\t\tif ( bone ) {\n\n\t\t\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: ( function () {\n\n\t\t\tvar offsetMatrix = new Matrix4();\n\n\t\t\treturn function update() {\n\n\t\t\t\t// flatten bone matrices to array\n\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\tclone: function () {\n\n\t\t\treturn new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction Bone( skin ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Bone';\n\n\t\tthis.skin = skin;\n\n\t}\n\n\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Bone,\n\n\t\tisBone: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.skin = source.skin;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkinnedMesh( geometry, material, useVertexTexture ) {\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = \"attached\";\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\t// init bones\n\n\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t// convenience) for THREE.SkinnedMesh to do this.\n\n\t\tvar bones = [];\n\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\t\tvar bone, gbone;\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tbone = new Bone( this );\n\t\t\t\tbones.push( bone );\n\n\t\t\t\tbone.name = gbone.name;\n\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t}\n\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.normalizeSkinWeights();\n\n\t\tthis.updateMatrixWorld( true );\n\t\tthis.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n\t}\n\n\n\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\t\tconstructor: SkinnedMesh,\n\n\t\tisSkinnedMesh: true,\n\n\t\tbind: function( skeleton, bindMatrix ) {\n\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif ( bindMatrix === undefined ) {\n\n\t\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t\t},\n\n\t\tpose: function () {\n\n\t\t\tthis.skeleton.pose();\n\n\t\t},\n\n\t\tnormalizeSkinWeights: function () {\n\n\t\t\tif ( (this.geometry && this.geometry.isGeometry) ) {\n\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {\n\n\t\t\t\tvar vec = new Vector4();\n\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t\t}\n\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdateMatrixWorld: function( force ) {\n\n\t\t\tMesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t\t}\n\n\t\t},\n\n\t\tclone: function() {\n\n\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\n\tfunction LineBasicMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineBasicMaterial.prototype = Object.create( Material.prototype );\n\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tLineBasicMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Line( geometry, material, mode ) {\n\n\t\tif ( mode === 1 ) {\n\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new LineSegments( geometry, material );\n\n\t\t}\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Line,\n\n\t\tisLine: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar vStart = new Vector3();\n\t\t\t\tvar vEnd = new Vector3();\n\t\t\t\tvar interSegment = new Vector3();\n\t\t\t\tvar interRay = new Vector3();\n\t\t\t\tvar step = (this && this.isLineSegments) ? 2 : 1;\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( (geometry && geometry.isGeometry) ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LineSegments( geometry, material ) {\n\n\t\tLine.call( this, geometry, material );\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\t\tconstructor: LineSegments,\n\n\t\tisLineSegments: true\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\n\tfunction PointsMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tPointsMaterial.prototype = Object.create( Material.prototype );\n\tPointsMaterial.prototype.constructor = PointsMaterial;\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tPointsMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Points( geometry, material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\t}\n\n\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Points,\n\n\t\tisPoints: true,\n\n\t\traycast: ( function () {\n\n\t\t\tvar inverseMatrix = new Matrix4();\n\t\t\tvar ray = new Ray();\n\t\t\tvar sphere = new Sphere();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t\t//\n\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new Vector3();\n\n\t\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Group() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Group';\n\n\t}\n\n\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Group\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.generateMipmaps = false;\n\n\t\tvar scope = this;\n\n\t\tfunction update() {\n\n\t\t\trequestAnimationFrame( update );\n\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\t\tscope.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdate();\n\n\t}\n\n\tVideoTexture.prototype = Object.create( Texture.prototype );\n\tVideoTexture.prototype.constructor = VideoTexture;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n\tCompressedTexture.prototype = Object.create( Texture.prototype );\n\tCompressedTexture.prototype.constructor = CompressedTexture;\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tCanvasTexture.prototype = Object.create( Texture.prototype );\n\tCanvasTexture.prototype.constructor = CanvasTexture;\n\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t * @author atix / arthursilber.de\n\t */\n\n\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\n\t\t}\n\n\t\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.type = type !== undefined ? type : UnsignedShortType;\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps\t= false;\n\n\t}\n\n\tDepthTexture.prototype = Object.create( Texture.prototype );\n\tDepthTexture.prototype.constructor = DepthTexture;\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction WireframeGeometry( geometry ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tif ( (geometry && geometry.isGeometry) ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar numEdges = 0;\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t} else if ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// Indexed BufferGeometry\n\n\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar numEdges = 0;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\tvar numTris = numEdges / 3;\n\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addAttribute( 'position', new BufferAttribute( coords, 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'ParametricBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// generate vertices and uvs\n\n\t\tvar vertices = [];\n\t\tvar uvs = [];\n\n\t\tvar i, j, p;\n\t\tvar u, v;\n\n\t\tvar sliceCount = slices + 1;\n\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\t\tv = i / stacks;\n\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tu = j / slices;\n\n\t\t\t\tp = func( u, v );\n\t\t\t\tvertices.push( p.x, p.y, p.z );\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tvar indices = [];\n\t\tvar a, b, c, d;\n\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\t\ta = i * sliceCount + j;\n\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t}\n\n\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\n\tfunction ParametricGeometry( func, slices, stacks ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tParametricGeometry.prototype = Object.create( Geometry.prototype );\n\tParametricGeometry.prototype.constructor = ParametricGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tvar vertexBuffer = [];\n\t\tvar uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tappplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );\n\t\tthis.normalizeNormals();\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tvar cols = Math.pow( 2, detail );\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tvar v = [];\n\n\t\t\tvar i, j;\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( i = 0 ; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tvar rows = cols - i;\n\n\t\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( i = 0; i < cols ; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction appplyRadius( radius ) {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tvar stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tvar a = new Vector3();\n\t\t\tvar b = new Vector3();\n\t\t\tvar c = new Vector3();\n\n\t\t\tvar centroid = new Vector3();\n\n\t\t\tvar uvA = new Vector2();\n\t\t\tvar uvB = new Vector2();\n\t\t\tvar uvC = new Vector2();\n\n\t\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tvar azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth  ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] =  uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\t\tvar vertices = [\n\t\t\t1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction TetrahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction OctahedronBufferGeometry( radius,detail ) {\n\n\t\tvar vertices = [\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction OctahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tvar vertices = [\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\n\tfunction IcosahedronGeometry( radius, detail ) {\n\n\t \tGeometry.call( this );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\n\t\tvar vertices = [\n\n\t\t\t// (±1, ±1, ±1)\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t\t// (0, ±1/φ, ±φ)\n\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t\t// (±1/φ, ±φ, 0)\n\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t r, - t,  0,     r,  t,  0,\n\n\t\t\t// (±φ, 0, ±1/φ)\n\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t- t,  0,  r,     t,  0,  r\n\t\t];\n\n\t\tvar indices = [\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t];\n\n\t\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\n\tfunction DodecahedronGeometry( radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t *\n\t */\n\n\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TubeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\ttubularSegments = tubularSegments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\n\t\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar i, j;\n\n\t\t// buffer\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\t\tvar indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', Float32Attribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', Float32Attribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tvar P = path.getPointAt( i / tubularSegments );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tvar N = frames.normals[ i ];\n\t\t\tvar B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tvar sin =   Math.sin( v );\n\t\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t */\n\n\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\t\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = bufferGeometry.tangents;\n\t\tthis.normals = bufferGeometry.normals;\n\t\tthis.binormals = bufferGeometry.binormals;\n\n\t\t// create geometry\n\n\t\tthis.fromBufferGeometry( bufferGeometry );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTubeGeometry.prototype = Object.create( Geometry.prototype );\n\tTubeGeometry.prototype.constructor = TubeGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar i, j, index = 0, indexOffset = 0;\n\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\t\tvar uv = new Vector2();\n\n\t\tvar P1 = new Vector3();\n\t\tvar P2 = new Vector3();\n\n\t\tvar B = new Vector3();\n\t\tvar T = new Vector3();\n\t\tvar N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t */\n\n\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\t\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'TorusBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\n\t\t// helper variables\n\t\tvar center = new Vector3();\n\t\tvar vertex = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t\t// uv\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t\t// update offsets\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offset\n\t\t\t\tindexBufferOffset += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\t\tthis.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\n\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n\t}\n\n\tTorusGeometry.prototype = Object.create( Geometry.prototype );\n\tTorusGeometry.prototype.constructor = TorusGeometry;\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar ShapeUtils = {\n\n\t\t// calculate area of the contour polygon\n\n\t\tarea: function ( contour ) {\n\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\n\t\t},\n\n\t\ttriangulate: ( function () {\n\n\t\t\t/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\t\tvar p;\n\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\tvar cx, cy, px, py;\n\n\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\t\tif ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// takes in an contour array and returns\n\n\t\t\treturn function triangulate( contour, indices ) {\n\n\t\t\t\tvar n = contour.length;\n\n\t\t\t\tif ( n < 3 ) return null;\n\n\t\t\t\tvar result = [],\n\t\t\t\t\tverts = [],\n\t\t\t\t\tvertIndices = [];\n\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\t\tvar u, v, w;\n\n\t\t\t\tif ( ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t\t}\n\n\t\t\t\tvar nv = n;\n\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnv --;\n\n\t\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t} )(),\n\n\t\ttriangulateShape: function ( contour, holes ) {\n\n\t\t\tfunction removeDupEndPts(points) {\n\n\t\t\t\tvar l = points.length;\n\n\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\t\tpoints.pop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tremoveDupEndPts( contour );\n\t\t\tholes.forEach( removeDupEndPts );\n\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\n\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t\t// return real intersection point\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t// both segments are points\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t\t}\n\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t\t// The order of legs is important\n\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t\t// angle != 180 deg.\n\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\tvar hole;\n\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar indepHoles = [];\n\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tindepHoles.push( h );\n\n\t\t\t\t}\n\n\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\t\tcounter --;\n\t\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t\t}\n\n\n\t\t\tvar i, il, f, face,\n\t\t\t\tkey, index,\n\t\t\t\tallPointsMap = {};\n\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t\tvar allpoints = contour.concat();\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t\t}\n\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t\t// prepare all points map\n\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\n\t\t\t\t}\n\n\t\t\t\tallPointsMap[ key ] = i;\n\n\t\t\t}\n\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\t\tvar triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t\t// check all face vertices against all points map\n\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\t\tface = triangles[ i ];\n\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn triangles.concat();\n\n\t\t},\n\n\t\tisClockWise: function ( pts ) {\n\n\t\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t\t},\n\n\t\t// Bezier Curves formulas obtained from\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t\t// Quad Bezier Functions\n\n\t\tb2: ( function () {\n\n\t\t\tfunction b2p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p1( t, p ) {\n\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b2p2( t, p ) {\n\n\t\t\t\treturn t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t\t};\n\n\t\t} )(),\n\n\t\t// Cubic Bezier Functions\n\n\t\tb3: ( function () {\n\n\t\t\tfunction b3p0( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * k * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p1( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * k * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p2( t, p ) {\n\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * t * t * p;\n\n\t\t\t}\n\n\t\t\tfunction b3p3( t, p ) {\n\n\t\t\t\treturn t * t * t * p;\n\n\t\t\t}\n\n\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ExtrudeGeometry( shapes, options ) {\n\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\t\tshapes = [];\n\t\t\treturn;\n\n\t\t}\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\n\t\t//this.computeVertexNormals();\n\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n\t}\n\n\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n\tExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tvar sl = shapes.length;\n\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\n\t\tvar shapesOffset = this.vertices.length;\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn\tnew Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tnew Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos ( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\n\n\t\t}\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\t\td += shapesOffset;\n\n\t\t\tscope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n\t\t\tscope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t\t}\n\n\t};\n\n\tExtrudeGeometry.WorldUVGenerator = {\n\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a.x, a.y ),\n\t\t\t\tnew Vector2( b.x, b.y ),\n\t\t\t\tnew Vector2( c.x, c.y )\n\t\t\t];\n\n\t\t},\n\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\t\tvar d = vertices[ indexD ];\n\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.x, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.x, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.x, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.x, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\treturn [\n\t\t\t\t\tnew Vector2( a.y, 1 - a.z ),\n\t\t\t\t\tnew Vector2( b.y, 1 - b.z ),\n\t\t\t\t\tnew Vector2( c.y, 1 - c.z ),\n\t\t\t\t\tnew Vector2( d.y, 1 - d.z )\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\n\tfunction TextGeometry( text, parameters ) {\n\n\t\tparameters = parameters || {};\n\n\t\tvar font = parameters.font;\n\n\t\tif ( (font && font.isFont) === false ) {\n\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new Geometry();\n\n\t\t}\n\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t\t// translate parameters to ExtrudeGeometry API\n\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t\t// defaults\n\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\t\tExtrudeGeometry.call( this, shapes, parameters );\n\n\t\tthis.type = 'TextGeometry';\n\n\t}\n\n\tTextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n\tTextGeometry.prototype.constructor = TextGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * based on THREE.SphereGeometry\n\t */\n\n\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'SphereBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\t\tvar positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\tvar index = 0, vertices = [], normal = new Vector3();\n\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar verticesRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\t\tvar u = x / widthSegments;\n\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\tverticesRow.push( index );\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvertices.push( verticesRow );\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', positions );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n\t}\n\n\tSphereGeometry.prototype = Object.create( Geometry.prototype );\n\tSphereGeometry.prototype.constructor = SphereGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 20;\n\t\touterRadius = outerRadius || 50;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// some helper variables\n\t\tvar index = 0, indexOffset = 0, segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar j, i;\n\n\t\t// generate vertices, normals and uvs\n\n\t\t// values are generate from the inside of the ring to the outside\n\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex++;\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t}\n\n\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n\t/**\n\t * @author Kaleb Murphy\n\t */\n\n\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n\t}\n\n\tRingGeometry.prototype = Object.create( Geometry.prototype );\n\tRingGeometry.prototype.constructor = RingGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\n\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n\t}\n\n\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\n\tPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t // points - to create a closed torus, one must use a set of points\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t // segments - the number of circumference segments to create\n\t // phiStart - the starting radian\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t //    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'LatheBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\tvar indexCount = segments * points.length * 2 * 3;\n\n\t\t// buffers\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\t\tvar index = 0, indexOffset = 0, base;\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new Vector3();\n\t\tvar uv = new Vector2();\n\t\tvar i, j;\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tbase = j + i * points.length;\n\n\t\t\t\t// indices\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif( phiLength === Math.PI * 2 ) {\n\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new Vector3();\n\t\t\tvar n2 = new Vector3();\n\t\t\tvar n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\tbase = segments * points.length * 3;\n\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t} // next row\n\n\t\t}\n\n\t}\n\n\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\n\t// points - to create a closed torus, one must use a set of points\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t// segments - the number of circumference segments to create\n\t// phiStart - the starting radian\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t//    2PI is a closed lathe, less than 2PI is a portion.\n\n\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tLatheGeometry.prototype = Object.create( Geometry.prototype );\n\tLatheGeometry.prototype.constructor = LatheGeometry;\n\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t *\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t * ExtrudeGeometry.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t *\n\t *\tmaterial: <int> // material index for front and back faces\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\n\tfunction ShapeGeometry( shapes, options ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\t\tthis.addShapeList( shapes, options );\n\n\t\tthis.computeFaceNormals();\n\n\t}\n\n\tShapeGeometry.prototype = Object.create( Geometry.prototype );\n\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\n\t/**\n\t * Add an array of shapes to THREE.ShapeGeometry.\n\t */\n\tShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tthis.addShape( shapes[ i ], options );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t */\n\tShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\t\tif ( options === undefined ) options = {};\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\t\tvar material = options.material;\n\t\tvar uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t\t//\n\n\t\tvar i, l, hole;\n\n\t\tvar shapesOffset = this.vertices.length;\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\t\thole = holes[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treverse = false;\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t// Vertices\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\t\t\tvertices = vertices.concat( hole );\n\n\t\t}\n\n\t\t//\n\n\t\tvar vert, vlen = vertices.length;\n\t\tvar face, flen = faces.length;\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = vertices[ i ];\n\n\t\t\tthis.vertices.push( new Vector3( vert.x, vert.y, 0 ) );\n\n\t\t}\n\n\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\t\tthis.faces.push( new Face3( a, b, c, null, null, material ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\n\t\tvar edge = [ 0, 0 ], hash = {};\n\n\t\tfunction sortFunction( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t}\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tvar geometry2;\n\n\t\tif ( (geometry && geometry.isBufferGeometry) ) {\n\n\t\t\tgeometry2 = new Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry2 = geometry.clone();\n\n\t\t}\n\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\n\t\tvar vertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t\t} else {\n\n\t\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = [];\n\n\t\tfor ( var key in hash ) {\n\n\t\t\tvar h = hash[ key ];\n\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );\n\n\t}\n\n\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CylinderBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tvar scope = this;\n\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\theight = height !== undefined ? height : 100;\n\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t\t// used to calculate buffer length\n\n\t\tvar nbCap = 0;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t\t}\n\n\t\tvar vertexCount = calculateVertexCount();\n\t\tvar indexCount = calculateIndexCount();\n\n\t\t// buffers\n\n\t\tvar indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\tvar vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t\t// helper variables\n\n\t\tvar index = 0,\n\t\t    indexOffset = 0,\n\t\t    indexArray = [],\n\t\t    halfHeight = height / 2;\n\n\t\t// group variables\n\t\tvar groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\n\t\t// helper functions\n\n\t\tfunction calculateVertexCount() {\n\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction calculateIndexCount() {\n\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\t\tif ( openEnded === false ) {\n\n\t\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\tfunction generateTorso() {\n\n\t\t\tvar x, y;\n\t\t\tvar normal = new Vector3();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tvar indexRow = [];\n\n\t\t\t\tvar v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\tindexRow.push( index );\n\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\t\tvar uv = new Vector2();\n\t\t\tvar vertex = new Vector3();\n\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = 0.5;\n\t\t\t\tuv.y = 0.5;\n\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tcenterIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t\t}\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\n\tCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n\tConeGeometry.prototype.constructor = ConeGeometry;\n\n\t/**\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\n\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'CircleBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 50;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tvar vertices = segments + 2;\n\n\t\tvar positions = new Float32Array( vertices * 3 );\n\t\tvar normals = new Float32Array( vertices * 3 );\n\t\tvar uvs = new Float32Array( vertices * 2 );\n\n\t\t// center data is already zero, but need to set a few extras\n\t\tnormals[ 2 ] = 1.0;\n\t\tuvs[ 0 ] = 0.5;\n\t\tuvs[ 1 ] = 0.5;\n\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\tthis.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\n\n\t\tthis.boundingSphere = new Sphere( new Vector3(), radius );\n\n\t}\n\n\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\t/**\n\t * @author hughes\n\t */\n\n\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n\t}\n\n\tCircleGeometry.prototype = Object.create( Geometry.prototype );\n\tCircleGeometry.prototype.constructor = CircleGeometry;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\n\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tGeometry.call( this );\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tBoxGeometry.prototype = Object.create( Geometry.prototype );\n\tBoxGeometry.prototype.constructor = BoxGeometry;\n\n\n\n\tvar Geometries = Object.freeze({\n\t\tWireframeGeometry: WireframeGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricBufferGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeBufferGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusBufferGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tSphereBufferGeometry: SphereBufferGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingBufferGeometry,\n\t\tPlaneBufferGeometry: PlaneBufferGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheBufferGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeBufferGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderBufferGeometry,\n\t\tCircleBufferGeometry: CircleBufferGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tBoxBufferGeometry: BoxBufferGeometry,\n\t\tBoxGeometry: BoxGeometry\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ShadowMaterial() {\n\n\t\tShaderMaterial.call( this, {\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ \"lights\" ],\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\t\tvertexShader: ShaderChunk[ 'shadow_vert' ],\n\t\t\tfragmentShader: ShaderChunk[ 'shadow_frag' ]\n\t\t} );\n\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\n\t\tObject.defineProperties( this, {\n\t\t\topacity: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tShadowMaterial.prototype.constructor = ShadowMaterial;\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction RawShaderMaterial( parameters ) {\n\n\t\tShaderMaterial.call( this, parameters );\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MultiMaterial( materials ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.type = 'MultiMaterial';\n\n\t\tthis.materials = materials instanceof Array ? materials : [];\n\n\t\tthis.visible = true;\n\n\t}\n\n\tMultiMaterial.prototype = {\n\n\t\tconstructor: MultiMaterial,\n\n\t\tisMultiMaterial: true,\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.2,\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\ttype: this.type,\n\t\t\t\tmaterials: []\n\t\t\t};\n\n\t\t\tvar materials = this.materials;\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\tdelete material.metadata;\n\n\t\t\t\toutput.materials.push( material );\n\n\t\t\t}\n\n\t\t\toutput.visible = this.visible;\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\tvar material = new this.constructor();\n\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tmaterial.visible = this.visible;\n\n\t\t\treturn material;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshStandardMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\n\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\tMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\n\tfunction MeshPhysicalMaterial( parameters ) {\n\n\t\tMeshStandardMaterial.call( this );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\t\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\t\tthis.defines = { 'PHYSICAL': '' };\n\n\t\tthis.reflectivity = source.reflectivity;\n\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshPhongMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\n\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\tMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\n\tfunction MeshNormalMaterial( parameters ) {\n\n\t\tMaterial.call( this, parameters );\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\tthis.morphTargets = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\n\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\tMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\n\tfunction MeshLambertMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\n\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\tMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\n\tfunction LineDashedMaterial( parameters ) {\n\n\t\tMaterial.call( this );\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.lights = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tLineDashedMaterial.prototype = Object.create( Material.prototype );\n\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tLineDashedMaterial.prototype.copy = function ( source ) {\n\n\t\tMaterial.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.linewidth = source.linewidth;\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t};\n\n\n\n\tvar Materials = Object.freeze({\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMultiMaterial: MultiMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tvar Cache = {\n\n\t\tenabled: false,\n\n\t\tfiles: {},\n\n\t\tadd: function ( key, file ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[ key ] = file;\n\n\t\t},\n\n\t\tget: function ( key ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[ key ];\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete this.files[ key ];\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.files = {};\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tvar DefaultLoadingManager = new LoadingManager();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction XHRLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( XHRLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( url === undefined ) url = '';\n\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\t\tvar scope = this;\n\n\t\t\tvar cached = Cache.get( url );\n\n\t\t\tif ( cached !== undefined ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t\treturn cached;\n\n\t\t\t}\n\n\t\t\t// Check for data: URI\n\t\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\t\tif ( dataUriRegexResult ) {\n\n\t\t\t\tvar mimeType = dataUriRegexResult[1];\n\t\t\t\tvar isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tvar data = dataUriRegexResult[3];\n\n\t\t\t\tdata = window.decodeURIComponent(data);\n\n\t\t\t\tif( isBase64 ) {\n\t\t\t\t\tdata = window.atob(data);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar response;\n\t\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\t \tresponse = new ArrayBuffer( data.length );\n\t\t\t\t\t\t\tvar view = new Uint8Array( response );\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\t\tresponse = new Blob( [ response ], { \"type\" : mimeType } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t// Wait for next browser tick\n\t\t\t\t\twindow.setTimeout( function() {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}, 0);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\trequest.open( 'GET', url, true );\n\n\t\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\t\tvar response = event.target.response;\n\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( onProgress !== undefined ) {\n\n\t\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\t\t\tonProgress( event );\n\n\t\t\t\t\t}, false );\n\n\t\t\t\t}\n\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}, false );\n\n\t\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );\n\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn request;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetResponseType: function ( value ) {\n\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\n\tfunction CompressedTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( CompressedTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar images = [];\n\n\t\t\tvar texture = new CompressedTexture();\n\t\t\ttexture.image = images;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\tvar loaded = 0;\n\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\t\tloadTexture( i );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\n\tvar DataTextureLoader = BinaryTextureLoader;\n\tfunction BinaryTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\n\t}\n\n\tObject.assign( BinaryTextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new DataTexture();\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\t\tif ( ! texData ) return;\n\n\t\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\t\ttexture.image = texData.image;\n\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\t\ttexture.format = texData.format;\n\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\t\ttexture.type = texData.type;\n\n\t\t\t\t}\n\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t}, onProgress, onError );\n\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ImageLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( ImageLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\timage.onload = function () {\n\n\t\t\t\timage.onload = null;\n\n\t\t\t\tURL.revokeObjectURL( image.src );\n\n\t\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\t\t\timage.onerror = onError;\n\n\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\timage.src = url;\n\n\t\t\t} else {\n\n\t\t\t\tvar loader = new XHRLoader();\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn image;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction CubeTextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( CubeTextureLoader.prototype, {\n\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new CubeTexture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfunction loadTexture( i ) {\n\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\t\tloaded ++;\n\n\t\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, undefined, onError );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction TextureLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( TextureLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture = new Texture();\n\n\t\t\tvar loader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( image ) {\n\n\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWithCredentials: function ( value ) {\n\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t}\n\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Light( color, intensity ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\t\tthis.receiveShadow = undefined;\n\n\t}\n\n\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Light,\n\n\t\tisLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tObject3D.prototype.copy.call( this, source );\n\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\ttoJSON: function ( meta ) {\n\n\t\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\t\tLight.call( this, skyColor, intensity );\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.castShadow = undefined;\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: HemisphereLight,\n\n\t\tisHemisphereLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.groundColor.copy( source.groundColor );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction LightShadow( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.matrix = new Matrix4();\n\n\t}\n\n\tObject.assign( LightShadow.prototype, {\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.camera = source.camera.clone();\n\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\n\t\t\tthis.mapSize.copy( source.mapSize );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\ttoJSON: function () {\n\n\t\t\tvar object = {};\n\n\t\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\t\tdelete object.camera.matrix;\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction SpotLightShadow() {\n\n\t\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t}\n\n\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: SpotLightShadow,\n\n\t\tisSpotLightShadow: true,\n\n\t\tupdate: function ( light ) {\n\n\t\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || 500;\n\n\t\t\tvar camera = this.camera;\n\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: SpotLight,\n\n\t\tisSpotLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\n\tfunction PointLight( color, intensity, distance, decay ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t}\n\t\t} );\n\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\t\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t}\n\n\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: PointLight,\n\n\t\tisPointLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction DirectionalLightShadow( light ) {\n\n\t\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t}\n\n\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\t\tconstructor: DirectionalLightShadow\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction DirectionalLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: DirectionalLight,\n\n\t\tisDirectionalLight: true,\n\n\t\tcopy: function ( source ) {\n\n\t\t\tLight.prototype.copy.call( this, source );\n\n\t\t\tthis.target = source.target.clone();\n\n\t\t\tthis.shadow = source.shadow.clone();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AmbientLight( color, intensity ) {\n\n\t\tLight.call( this, color, intensity );\n\n\t\tthis.type = 'AmbientLight';\n\n\t\tthis.castShadow = undefined;\n\n\t}\n\n\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\t\tconstructor: AmbientLight,\n\n\t\tisAmbientLight: true,\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tvar AnimationUtils = {\n\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function( array, from, to ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t\t}\n\n\t\t\treturn array.slice( from, to );\n\n\t\t},\n\n\t\t// converts an array to a specific type\n\t\tconvertArray: function( array, type, forceClone ) {\n\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\t\treturn new type( array ); // create typed array\n\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t\t},\n\n\t\tisTypedArray: function( object ) {\n\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\n\t\t},\n\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function( times ) {\n\n\t\t\tfunction compareTime( i, j ) {\n\n\t\t\t\treturn times[ i ] - times[ j ];\n\n\t\t\t}\n\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\t\tresult.sort( compareTime );\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function( values, stride, order ) {\n\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t}\n\n\t\t\tif ( key === undefined ) return; // no data\n\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t// ...assume THREE.Math-ish\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t\t} while ( key !== undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\n\tfunction Interpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t}\n\n\tInterpolant.prototype = {\n\n\t\tconstructor: Interpolant,\n\n\t\tevaluate: function( t ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\n\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\tvalidate_interval: {\n\n\t\t\t\tseek: {\n\n\t\t\t\t\tvar right;\n\n\t\t\t\t\tlinear_scan: {\n\t//- See http://jsperf.com/comparison-to-undefined/3\n\t//- slower code:\n\t//-\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t//- slower code:\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t\t} // linear scan\n\n\t\t\t\t\t// binary search\n\n\t\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t\t// check boundary cases, again\n\n\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // seek\n\n\t\t\t\tthis._cachedIndex = i1;\n\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t\t} // validate_interval\n\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t\t},\n\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\n\t\t// --- Protected interface\n\n\t\tDefaultSettings_: {},\n\n\t\tgetSettings_: function() {\n\n\t\t\treturn this.settings || this.DefaultSettings_;\n\n\t\t},\n\n\t\tcopySampleValue_: function( index ) {\n\n\t\t\t// copies a sample value to the result buffer\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t// Template methods for derived classes:\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t// implementations shall return this.resultBuffer\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\t// empty\n\n\t\t}\n\n\t};\n\n\tObject.assign( Interpolant.prototype, {\n\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_,\n\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tInterpolant.prototype.copySampleValue_\n\n\t} );\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction CubicInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = -0;\n\t\tthis._offsetPrev = -0;\n\t\tthis._weightNext = -0;\n\t\tthis._offsetNext = -0;\n\n\t}\n\n\tCubicInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: CubicInterpolant,\n\n\t\tDefaultSettings_: {\n\n\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\n\t\t},\n\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\n\t\t\tif ( tPrev === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tNext === undefined ) {\n\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\n\t\t},\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\n\t\t\t// evaluate polynomials\n\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t\t// combine data linearly\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author tschw\n\t */\n\n\tfunction LinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: LinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction DiscreteInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tDiscreteInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: DiscreteInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t}\n\n\t} );\n\n\tvar KeyframeTrackPrototype;\n\n\tKeyframeTrackPrototype = {\n\n\t\tTimeBufferType: Float32Array,\n\t\tValueBufferType: Float32Array,\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\t\treturn new DiscreteInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new LinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\t\treturn new CubicInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tsetInterpolation: function( interpolation ) {\n\n\t\t\tvar factoryMethod;\n\n\t\t\tswitch ( interpolation ) {\n\n\t\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( factoryMethod === undefined ) {\n\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( message );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\n\t\t},\n\n\t\tgetInterpolation: function() {\n\n\t\t\tswitch ( this.createInterpolant ) {\n\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\t\treturn InterpolateSmooth;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetValueSize: function() {\n\n\t\t\treturn this.values.length / this.times.length;\n\n\t\t},\n\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function( timeOffset ) {\n\n\t\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function( timeScale ) {\n\n\t\t\tif( timeScale !== 1.0 ) {\n\n\t\t\t\tvar times = this.times;\n\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function( startTime, endTime ) {\n\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t\t++ to; // inclusive -> exclusive bound\n\n\t\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = AnimationUtils.\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function() {\n\n\t\t\tvar valid = true;\n\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\n\t\t\t\tnKeys = times.length;\n\n\t\t\tif( nKeys === 0 ) {\n\n\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\tvalid = false;\n\n\t\t\t}\n\n\t\t\tvar prevTime = null;\n\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\t\tvar currTime = times[ i ];\n\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\n\t\t\t}\n\n\t\t\tif ( values !== undefined ) {\n\n\t\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn valid;\n\n\t\t},\n\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function() {\n\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\n\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\t\twriteIndex = 1,\n\t\t\t\tlastIndex = times.length - 1;\n\n\t\t\tfor( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\t\tvar keep = false;\n\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else keep = true;\n\n\t\t\t\t}\n\n\t\t\t\t// in-place compaction\n\n\t\t\t\tif ( keep ) {\n\n\t\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j )\n\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t++ writeIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// flush last keyframe (compaction looks ahead)\n\n\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\n\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t\tif ( writeIndex !== times.length ) {\n\n\t\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\tfunction KeyframeTrackConstructor( name, times, values, interpolation ) {\n\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\t\tif( times === undefined || times.length === 0 ) {\n\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t\t}\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t\tthis.validate();\n\t\tthis.optimize();\n\n\t}\n\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tVectorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: VectorKeyframeTrack,\n\n\t\tValueTypeName: 'vector'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction QuaternionLinearInterpolant(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tInterpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tQuaternionLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( Interpolant.prototype ), {\n\n\t\tconstructor: QuaternionLinearInterpolant,\n\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toffset = i1 * stride,\n\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\t\tQuaternion.slerpFlat( result, 0,\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: QuaternionKeyframeTrack,\n\n\t\tValueTypeName: 'quaternion',\n\n\t\t// ValueBufferType is inherited\n\n\t\tDefaultInterpolation: InterpolateLinear,\n\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\t\treturn new QuaternionLinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t\t},\n\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tNumberKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: NumberKeyframeTrack,\n\n\t\tValueTypeName: 'number',\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\t} );\n\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tStringKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: StringKeyframeTrack,\n\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction BooleanKeyframeTrack( name, times, values ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values );\n\n\t}\n\n\tBooleanKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: BooleanKeyframeTrack,\n\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\n\t\tDefaultInterpolation: InterpolateDiscrete,\n\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\n\t} );\n\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n\t}\n\n\tColorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( KeyframeTrackPrototype ), {\n\n\t\tconstructor: ColorKeyframeTrack,\n\n\t\tValueTypeName: 'color'\n\n\t\t// ValueBufferType is inherited\n\n\t\t// DefaultInterpolation is inherited\n\n\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\n\t} );\n\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\t\tKeyframeTrackConstructor.apply( this, arguments );\n\n\t}\n\n\tKeyframeTrack.prototype = KeyframeTrackPrototype;\n\tKeyframeTrackPrototype.constructor = KeyframeTrack;\n\n\t// Static methods:\n\n\tObject.assign( KeyframeTrack, {\n\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\t\tparse: function( json ) {\n\n\t\t\tif( json.type === undefined ) {\n\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t\t}\n\n\t\t\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\t\tif ( json.times === undefined ) {\n\n\t\t\t\tvar times = [], values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\n\t\t\t}\n\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\t\treturn trackType.parse( json );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\treturn new trackType(\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t\t}\n\n\t\t},\n\n\t\ttoJSON: function( track ) {\n\n\t\t\tvar trackType = track.constructor;\n\n\t\t\tvar json;\n\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\t\tjson = trackType.toJSON( track );\n\n\t\t\t} else {\n\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t\t};\n\n\t\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\n\t\t},\n\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\t\tcase \"scalar\":\n\t\t\t\tcase \"double\":\n\t\t\t\tcase \"float\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"integer\":\n\n\t\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\t\tcase \"vector\":\n\t\t\t\tcase \"vector2\":\n\t\t\t\tcase \"vector3\":\n\t\t\t\tcase \"vector4\":\n\n\t\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\t\tcase \"color\":\n\n\t\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\t\tcase \"quaternion\":\n\n\t\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\t\tcase \"bool\":\n\t\t\t\tcase \"boolean\":\n\n\t\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\t\tcase \"string\":\n\n\t\t\t\t\treturn StringKeyframeTrack;\n\n\t\t\t}\n\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\n\tfunction AnimationClip( name, duration, tracks ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t\tthis.optimize();\n\n\t}\n\n\tAnimationClip.prototype = {\n\n\t\tconstructor: AnimationClip,\n\n\t\tresetDuration: function() {\n\n\t\t\tvar tracks = this.tracks,\n\t\t\t\tduration = 0;\n\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\t\tvar track = this.tracks[ i ];\n\n\t\t\t\tduration = Math.max(\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\n\t\t},\n\n\t\ttrim: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\toptimize: function() {\n\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\tthis.tracks[ i ].optimize();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t// Static methods:\n\n\tObject.assign( AnimationClip, {\n\n\t\tparse: function( json ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t\t},\n\n\n\t\ttoJSON: function( clip ) {\n\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\n\t\t\tvar json = {\n\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn json;\n\n\t\t},\n\n\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, -1, tracks );\n\n\t\t},\n\n\t\tfindByName: function( objectOrClipArray, name ) {\n\n\t\t\tvar clipArray = objectOrClipArray;\n\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\t\treturn clipArray[ i ];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\t\tvar animationToMorphTargets = {};\n\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar clips = [];\n\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t\t}\n\n\t\t\treturn clips;\n\n\t\t},\n\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function( animation, bones ) {\n\n\t\t\tif ( ! animation ) {\n\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tAnimationUtils.flattenJSON(\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || -1;\n\t\t\tvar fps = animation.fps || 30;\n\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\n\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( new NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( tracks.length === 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction MaterialLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.textures = {};\n\n\t}\n\n\tObject.assign( MaterialLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTextures: function ( value ) {\n\n\t\t\tthis.textures = value;\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar textures = this.textures;\n\n\t\t\tfunction getTexture( name ) {\n\n\t\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn textures[ name ];\n\n\t\t\t}\n\n\t\t\tvar material = new Materials[ json.type ]();\n\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\n\t\t\t// for PointsMaterial\n\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t\t// maps\n\n\t\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\n\t\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\t\tvar normalScale = json.normalScale;\n\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t\t}\n\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t\t// MultiMaterial\n\n\t\t\tif ( json.materials !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BufferGeometryLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( BufferGeometryLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\tvar geometry = new BufferGeometry();\n\n\t\t\tvar index = json.data.index;\n\n\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t'Float64Array': Float64Array\n\t\t\t};\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tvar attributes = json.data.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t\t}\n\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif ( groups !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\t\tvar center = new Vector3();\n\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Loader() {\n\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\n\t}\n\n\tLoader.prototype = {\n\n\t\tconstructor: Loader,\n\n\t\tcrossOrigin: undefined,\n\n\t\textractUrlBase: function ( url ) {\n\n\t\t\tvar parts = url.split( '/' );\n\n\t\t\tif ( parts.length === 1 ) return './';\n\n\t\t\tparts.pop();\n\n\t\t\treturn parts.join( '/' ) + '/';\n\n\t\t},\n\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t},\n\n\t\tcreateMaterial: ( function () {\n\n\t\t\tvar color, textureLoader, materialLoader;\n\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t\tif ( color === undefined ) color = new Color();\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new TextureLoader();\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new MaterialLoader();\n\n\t\t\t\t// convert from old material format\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\t\tvar texture;\n\n\t\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\t\treturn uuid;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\n\t\t\t\tfor ( var name in m ) {\n\n\t\t\t\t\tvar value = m[ name ];\n\n\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\t\treturn materialLoader.parse( json );\n\n\t\t\t};\n\n\t\t} )()\n\n\t};\n\n\tLoader.Handlers = {\n\n\t\thandlers: [],\n\n\t\tadd: function ( regex, loader ) {\n\n\t\t\tthis.handlers.push( regex, loader );\n\n\t\t},\n\n\t\tget: function ( file ) {\n\n\t\t\tvar handlers = this.handlers;\n\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction JSONLoader( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.withCredentials = false;\n\n\t}\n\n\tObject.assign( JSONLoader.prototype, {\n\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tparse: function ( json, texturePath ) {\n\n\t\t\tvar geometry = new Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\t\tparseModel( scale );\n\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tfunction parseModel( scale ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\toffset, zLength,\n\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\n\t\t\t\tnUvLayers = 0;\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseSkin() {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseMorphing( scale ) {\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations() {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t}\n\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\treturn { geometry: geometry };\n\n\t\t\t} else {\n\n\t\t\t\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction ObjectLoader ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\n\t}\n\n\tObject.assign( ObjectLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tif ( this.texturePath === '' ) {\n\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetTexturePath: function ( value ) {\n\n\t\t\tthis.texturePath = value;\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\n\t\t},\n\n\t\tparse: function ( json, onLoad ) {\n\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t} );\n\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\t\tif ( json.animations ) {\n\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t\t}\n\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t},\n\n\t\tparseGeometries: function ( json ) {\n\n\t\t\tvar geometries = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar geometryLoader = new JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometries;\n\n\t\t},\n\n\t\tparseMaterials: function ( json, textures ) {\n\n\t\t\tvar materials = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tvar loader = new MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tparseAnimations: function ( json ) {\n\n\t\t\tvar animations = [];\n\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\t\tanimations.push( clip );\n\n\t\t\t}\n\n\t\t\treturn animations;\n\n\t\t},\n\n\t\tparseImages: function ( json, onLoad ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\n\t\t\tfunction loadImage( url ) {\n\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\treturn loader.load( url, function () {\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, undefined, function () {\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\t\tvar loader = new ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\tparseTextures: function ( json, images ) {\n\n\t\t\tfunction parseConstant( value, type ) {\n\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\t\treturn type[ value ];\n\n\t\t\t}\n\n\t\t\tvar textures = {};\n\n\t\t\tif ( json !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar data = json[ i ];\n\n\t\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar texture = new Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textures;\n\n\t\t},\n\n\t\tparseObject: function () {\n\n\t\t\tvar matrix = new Matrix4();\n\n\t\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\t\tvar object;\n\n\t\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometries[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn materials[ name ];\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'Scene':\n\n\t\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LOD':\n\n\t\t\t\t\t\tobject = new LOD();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Line':\n\n\t\t\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LineSegments':\n\n\t\t\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Group':\n\n\t\t\t\t\t\tobject = new Group();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tobject = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t\tobject.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\t\tif ( data.shadow ) {\n\n\t\t\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\t\tvar levels = data.levels;\n\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t};\n\n\t\t}()\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTangentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.SplineCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\n\tfunction Curve() {}\n\n\tCurve.prototype = {\n\n\t\tconstructor: Curve,\n\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\t\tgetPointAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t );\n\n\t\t},\n\n\t\t// Get sequence of points using getPoint( t )\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get sequence of points using getPointAt( u )\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 5;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t// Get total curve arc length\n\n\t\tgetLength: function () {\n\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\n\t\t},\n\n\t\t// Get list of cumulative segment lengths\n\n\t\tgetLengths: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\t\tif ( this.cacheArcLengths\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\treturn this.cacheArcLengths;\n\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\n\t\t\tcache.push( 0 );\n\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t\t},\n\n\t\tupdateArcLengths: function() {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\t\tgetUtoTmapping: function ( u, distance ) {\n\n\t\t\tvar arcLengths = this.getLengths();\n\n\t\t\tvar i = 0, il = arcLengths.length;\n\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\t\tif ( distance ) {\n\n\t\t\t\ttargetArcLength = distance;\n\n\t\t\t} else {\n\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t\t}\n\n\t\t\t//var time = Date.now();\n\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\t\tvar low = 0, high = il - 1, comparison;\n\n\t\t\twhile ( low <= high ) {\n\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\t\tlow = i + 1;\n\n\t\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\t\thigh = i - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// DONE\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\treturn t;\n\n\t\t\t}\n\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t\t// determine where we are between the 'before' and 'after' points\n\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t\t// add that fractional amount to t\n\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\t\treturn t;\n\n\t\t},\n\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\t\tgetTangent: function( t ) {\n\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\n\t\t\t// Capping in case of danger\n\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\n\t\t},\n\n\t\tgetTangentAt: function ( u ) {\n\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\n\t\t},\n\n\t\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\t\tvar normal = new Vector3();\n\n\t\t\tvar tangents = [];\n\t\t\tvar normals = [];\n\t\t\tvar binormals = [];\n\n\t\t\tvar vec = new Vector3();\n\t\t\tvar mat = new Matrix4();\n\n\t\t\tvar i, u, theta;\n\n\t\t\t// compute the tangent vectors for each segment on the curve\n\n\t\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\t\tu = i / segments;\n\n\t\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\t\ttangents[ i ].normalize();\n\n\t\t\t}\n\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\t\t\tnormals[ 0 ] = new Vector3();\n\t\t\tbinormals[ 0 ] = new Vector3();\n\t\t\tvar min = Number.MAX_VALUE;\n\t\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\t\tif ( tx <= min ) {\n\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t\t}\n\n\t\t\tif ( ty <= min ) {\n\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t\t}\n\n\t\t\tif ( tz <= min ) {\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t\t}\n\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\t\tvec.normalize();\n\n\t\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t\t}\n\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\t\tif ( closed === true ) {\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\t\ttheta = - theta;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\t// TODO: Transformation for Curves?\n\n\t/**************************************************************\n\t *\t3D Curves\n\t **************************************************************/\n\n\t// A Factory method for creating new curve subclasses\n\n\tCurve.create = function ( constructor, getPointFunc ) {\n\n\t\tconstructor.prototype = Object.create( Curve.prototype );\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.getPoint = getPointFunc;\n\n\t\treturn constructor;\n\n\t};\n\n\t/**************************************************************\n\t *\tLine\n\t **************************************************************/\n\n\tfunction LineCurve( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tLineCurve.prototype = Object.create( Curve.prototype );\n\tLineCurve.prototype.constructor = LineCurve;\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tLineCurve.prototype.getPoint = function ( t ) {\n\n\t\tif ( t === 1 ) {\n\n\t\t\treturn this.v2.clone();\n\n\t\t}\n\n\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\treturn point;\n\n\t};\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\n\tLineCurve.prototype.getPointAt = function ( u ) {\n\n\t\treturn this.getPoint( u );\n\n\t};\n\n\tLineCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\t\treturn tangent.normalize();\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\n\tfunction CurvePath() {\n\n\t\tthis.curves = [];\n\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\t\tconstructor: CurvePath,\n\n\t\tadd: function ( curve ) {\n\n\t\t\tthis.curves.push( curve );\n\n\t\t},\n\n\t\tclosePath: function () {\n\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\t\tgetPoint: function ( t ) {\n\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\n\t\t\t// To think about boundaries points.\n\n\t\t\twhile ( i < curveLengths.length ) {\n\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t\t},\n\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\t\tgetLength: function () {\n\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\n\t\t},\n\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getLengths();\n\n\t\t},\n\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\t\tgetCurveLengths: function () {\n\n\t\t\t// We use cache values if curves and cache array are same length\n\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\t\treturn this.cacheLengths;\n\n\t\t\t}\n\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\t\t\tvar lengths = [], sums = 0;\n\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\n\t\t\treturn lengths;\n\n\t\t},\n\n\t\tgetSpacedPoints: function ( divisions ) {\n\n\t\t\tif ( ! divisions ) divisions = 40;\n\n\t\t\tvar points = [];\n\n\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\tgetPoints: function ( divisions ) {\n\n\t\t\tdivisions = divisions || 12;\n\n\t\t\tvar points = [], last;\n\n\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\t\tvar curve = curves[ i ];\n\t\t\t\tvar resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n\t\t\t\t\t: (curve && curve.isLineCurve) ? 1\n\t\t\t\t\t: (curve && curve.isSplineCurve) ? divisions * curve.points.length\n\t\t\t\t\t: divisions;\n\n\t\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\n\t\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push( point );\n\t\t\t\t\tlast = point;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\tpoints.push( points[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn points;\n\n\t\t},\n\n\t\t/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\n\t\t/// Generate geometry from path points (for Line or Points objects)\n\n\t\tcreatePointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\t// Generate geometry from equidistant sampling along the path\n\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\n\t\t},\n\n\t\tcreateGeometry: function ( points ) {\n\n\t\t\tvar geometry = new Geometry();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\n\t/**************************************************************\n\t *\tEllipse curve\n\t **************************************************************/\n\n\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation || 0;\n\n\t}\n\n\tEllipseCurve.prototype = Object.create( Curve.prototype );\n\tEllipseCurve.prototype.constructor = EllipseCurve;\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tEllipseCurve.prototype.getPoint = function( t ) {\n\n\t\tvar twoPi = Math.PI * 2;\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\n\t\t\tvar tx = x - this.aX;\n\t\t\tvar ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn new Vector2( x, y );\n\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\n\tvar CurveUtils = {\n\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t\t},\n\n\t\t// Puay Bing, thanks for helping with this derivative!\n\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t3 * t * t * p3;\n\n\t\t},\n\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t\t// To check if my formulas are correct\n\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\n\t\t\treturn h00 + h10 + h01 + h11;\n\n\t\t},\n\n\t\t// Catmull-Rom\n\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t};\n\n\t/**************************************************************\n\t *\tSpline curve\n\t **************************************************************/\n\n\tfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t}\n\n\tSplineCurve.prototype = Object.create( Curve.prototype );\n\tSplineCurve.prototype.constructor = SplineCurve;\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tSplineCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\treturn new Vector2(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t);\n\n\t};\n\n\t/**************************************************************\n\t *\tCubic Bezier curve\n\t **************************************************************/\n\n\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\n\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n\tCubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b3 = ShapeUtils.b3;\n\n\t\treturn new Vector2(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t);\n\n\t};\n\n\tCubicBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentCubicBezier = CurveUtils.tangentCubicBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t).normalize();\n\n\t};\n\n\t/**************************************************************\n\t *\tQuadratic Bezier curve\n\t **************************************************************/\n\n\n\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n\n\tQuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar b2 = ShapeUtils.b2;\n\n\t\treturn new Vector2(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t);\n\n\t};\n\n\n\tQuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\t\tvar tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;\n\n\t\treturn new Vector2(\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t).normalize();\n\n\t};\n\n\tvar PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\t\tfromPoints: function ( vectors ) {\n\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t\t}\n\n\t\t},\n\n\t\tmoveTo: function ( x, y ) {\n\n\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\t},\n\n\t\tlineTo: function ( x, y ) {\n\n\t\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( x, y );\n\n\t\t},\n\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\t\tvar curve = new QuadraticBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\t\tvar curve = new CubicBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew Vector2( aX, aY )\n\t\t\t);\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.set( aX, aY );\n\n\t\t},\n\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\t\tvar curve = new SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\n\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\t},\n\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\t},\n\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t},\n\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.curves.push( curve );\n\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\tthis.currentPoint.copy( lastPoint );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\n\tfunction Shape() {\n\n\t\tPath.apply( this, arguments );\n\n\t\tthis.holes = [];\n\n\t}\n\n\tShape.prototype = Object.assign( Object.create( PathPrototype ), {\n\n\t\tconstructor: Shape,\n\n\t\tgetPointsHoles: function ( divisions ) {\n\n\t\t\tvar holesPts = [];\n\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t\t}\n\n\t\t\treturn holesPts;\n\n\t\t},\n\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\t\textractAllPoints: function ( divisions ) {\n\n\t\t\treturn {\n\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t\t};\n\n\t\t},\n\n\t\textractPoints: function ( divisions ) {\n\n\t\t\treturn this.extractAllPoints( divisions );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t *\n\t **/\n\n\tfunction Path( points ) {\n\n\t\tCurvePath.call( this );\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.fromPoints( points );\n\n\t\t}\n\n\t}\n\n\tPath.prototype = PathPrototype;\n\tPathPrototype.constructor = Path;\n\n\n\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\tfunction ShapePath() {\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\t}\n\n\tShapePath.prototype = {\n\t\tmoveTo: function ( x, y ) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo( x, y );\n\t\t},\n\t\tlineTo: function ( x, y ) {\n\t\t\tthis.currentPath.lineTo( x, y );\n\t\t},\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t},\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t},\n\t\tsplineThru: function ( pts ) {\n\t\t\tthis.currentPath.splineThru( pts );\n\t\t},\n\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\t\tvar shapes = [];\n\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn\tinside;\n\n\t\t\t}\n\n\t\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\t\tvar subPaths = this.subPaths;\n\t\t\tif ( subPaths.length === 0 ) return [];\n\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\t\tif ( subPaths.length === 1 ) {\n\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\n\t\t\t}\n\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\t\tif ( solid ) {\n\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t\t//console.log('cw', i);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t\t//console.log('ccw', i);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\t\tif ( newShapes.length > 1 ) {\n\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar tmpHoles;\n\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shape\", shapes);\n\n\t\t\treturn shapes;\n\n\t\t}\n\t};\n\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Font( data ) {\n\n\t\tthis.data = data;\n\n\t}\n\n\tObject.assign( Font.prototype, {\n\n\t\tisFont: true,\n\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\t\tfunction createPaths( text ) {\n\n\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tvar paths = [];\n\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\toffset += ret.offset;\n\n\t\t\t\t\tpaths.push( ret.path );\n\n\t\t\t\t}\n\n\t\t\t\treturn paths;\n\n\t\t\t}\n\n\t\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\t\tif ( ! glyph ) return;\n\n\t\t\t\tvar path = new ShapePath();\n\n\t\t\t\tvar pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\t\tif ( glyph.o ) {\n\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\t\tvar data = this.data;\n\n\t\t\tvar paths = createPaths( text );\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction FontLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( FontLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json;\n\n\t\t\t\ttry {\n\n\t\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar font = scope.parse( json );\n\n\t\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( json ) {\n\n\t\t\treturn new Font( json );\n\n\t\t}\n\n\t} );\n\n\tvar context;\n\n\tfunction getAudioContext() {\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction AudioLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t}\n\n\tObject.assign( AudioLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar context = getAudioContext();\n\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction StereoCamera() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t}\n\n\tObject.assign( StereoCamera.prototype, {\n\n\t\tupdate: ( function () {\n\n\t\t\tvar instance, focus, fov, aspect, near, far, zoom;\n\n\t\t\tvar eyeRight = new Matrix4();\n\t\t\tvar eyeLeft = new Matrix4();\n\n\t\t\treturn function update( camera ) {\n\n\t\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom;\n\n\t\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t\tinstance = this;\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\tvar eyeSep = this.eyeSep / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t\t// translate xOffset\n\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t\t// for left eye\n\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t\t// for right eye\n\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction CubeCamera( near, far, cubeResolution ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tvar fov = 90, aspect = 1;\n\n\t\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\n\t\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\n\t\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\n\t\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\n\t\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\n\t\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\n\t\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\t\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\t\trenderer.setRenderTarget( null );\n\n\t\t};\n\n\t}\n\n\tCubeCamera.prototype = Object.create( Object3D.prototype );\n\tCubeCamera.prototype.constructor = CubeCamera;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioListener() {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = getAudioContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t}\n\n\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: AudioListener,\n\n\t\tgetInput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tremoveFilter: function ( ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.filter;\n\n\t\t},\n\n\t\tsetFilter: function ( value ) {\n\n\t\t\tif ( this.filter !== null ) {\n\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t\t} else {\n\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\n\t\t},\n\n\t\tgetMasterVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\t\tsetMasterVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\t\t\tvar quaternion = new Quaternion();\n\t\t\tvar scale = new Vector3();\n\n\t\t\tvar orientation = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\n\tfunction Audio( listener ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.context = listener.context;\n\t\tthis.source = this.context.createBufferSource();\n\t\tthis.source.onended = this.onEnded.bind( this );\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.startTime = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis.filters = [];\n\n\t}\n\n\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\t\tconstructor: Audio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.gain;\n\n\t\t},\n\n\t\tsetNodeSource: function ( audioNode ) {\n\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetBuffer: function ( audioBuffer ) {\n\n\t\t\tthis.source.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\n\t\t\tif ( this.autoplay ) this.play();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tplay: function () {\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar source = this.context.createBufferSource();\n\n\t\t\tsource.buffer = this.source.buffer;\n\t\t\tsource.loop = this.source.loop;\n\t\t\tsource.onended = this.source.onended;\n\t\t\tsource.start( 0, this.startTime );\n\t\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\t\tthis.isPlaying = true;\n\n\t\t\tthis.source = source;\n\n\t\t\treturn this.connect();\n\n\t\t},\n\n\t\tpause: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = 0;\n\t\t\tthis.isPlaying = false;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tdisconnect: function () {\n\n\t\t\tif ( this.filters.length > 0 ) {\n\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t\t} else {\n\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilters: function () {\n\n\t\t\treturn this.filters;\n\n\t\t},\n\n\t\tsetFilters: function ( value ) {\n\n\t\t\tif ( ! value ) value = [];\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\n\t\t\t} else {\n\n\t\t\t\tthis.filters = value;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetFilter: function () {\n\n\t\t\treturn this.getFilters()[ 0 ];\n\n\t\t},\n\n\t\tsetFilter: function ( filter ) {\n\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t\t},\n\n\t\tsetPlaybackRate: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif ( this.isPlaying === true ) {\n\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetPlaybackRate: function () {\n\n\t\t\treturn this.playbackRate;\n\n\t\t},\n\n\t\tonEnded: function () {\n\n\t\t\tthis.isPlaying = false;\n\n\t\t},\n\n\t\tgetLoop: function () {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\treturn this.source.loop;\n\n\t\t},\n\n\t\tsetLoop: function ( value ) {\n\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.source.loop = value;\n\n\t\t},\n\n\t\tgetVolume: function () {\n\n\t\t\treturn this.gain.gain.value;\n\n\t\t},\n\n\n\t\tsetVolume: function ( value ) {\n\n\t\t\tthis.gain.gain.value = value;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PositionalAudio( listener ) {\n\n\t\tAudio.call( this, listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\t\tconstructor: PositionalAudio,\n\n\t\tgetOutput: function () {\n\n\t\t\treturn this.panner;\n\n\t\t},\n\n\t\tgetRefDistance: function () {\n\n\t\t\treturn this.panner.refDistance;\n\n\t\t},\n\n\t\tsetRefDistance: function ( value ) {\n\n\t\t\tthis.panner.refDistance = value;\n\n\t\t},\n\n\t\tgetRolloffFactor: function () {\n\n\t\t\treturn this.panner.rolloffFactor;\n\n\t\t},\n\n\t\tsetRolloffFactor: function ( value ) {\n\n\t\t\tthis.panner.rolloffFactor = value;\n\n\t\t},\n\n\t\tgetDistanceModel: function () {\n\n\t\t\treturn this.panner.distanceModel;\n\n\t\t},\n\n\t\tsetDistanceModel: function ( value ) {\n\n\t\t\tthis.panner.distanceModel = value;\n\n\t\t},\n\n\t\tgetMaxDistance: function () {\n\n\t\t\treturn this.panner.maxDistance;\n\n\t\t},\n\n\t\tsetMaxDistance: function ( value ) {\n\n\t\t\tthis.panner.maxDistance = value;\n\n\t\t},\n\n\t\tupdateMatrixWorld: ( function () {\n\n\t\t\tvar position = new Vector3();\n\n\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t\t};\n\n\t\t} )()\n\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AudioAnalyser( audio, fftSize ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\tObject.assign( AudioAnalyser.prototype, {\n\n\t\tgetFrequencyData: function () {\n\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\t\treturn this.data;\n\n\t\t},\n\n\t\tgetAverageFrequency: function () {\n\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tvalue += data[ i ];\n\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\n\t\t}\n\n\t} );\n\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t\t}\n\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\n\t\tthis._mixBufferRegion = mixFunction;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\tPropertyMixer.prototype = {\n\n\t\tconstructor: PropertyMixer,\n\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function( accuIndex, weight ) {\n\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\t\tif ( currentWeight === 0 ) {\n\n\t\t\t\t// accuN := incoming * weight\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\n\t\t\t} else {\n\n\t\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\n\t\t},\n\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function( accuIndex ) {\n\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\t\tweight = this.cumulativeWeight,\n\n\t\t\t\tbinding = this.binding;\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t\tif ( weight < 1 ) {\n\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t\t}\n\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function() {\n\n\t\t\tvar binding = this.binding;\n\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\n\t\t\t\toriginalValueOffset = stride * 3;\n\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = 0;\n\n\t\t},\n\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function() {\n\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t\t},\n\n\n\t\t// mix functions\n\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tif ( t >= 0.5 ) {\n\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tQuaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t\t},\n\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\t\tvar s = 1 - t;\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tvar j = dstOffset + i;\n\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode(\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\t\tthis.rootNode = rootNode;\n\n\t}\n\n\tPropertyBinding.prototype = {\n\n\t\tconstructor: PropertyBinding,\n\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\n\t\t},\n\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\n\t\t},\n\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function() {\n\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\ttargetObject = PropertyBinding.findNode(\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\t\tthis.node = targetObject;\n\n\t\t\t}\n\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\n\t \t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( objectName ) {\n\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\n\t\t\t\t\tcase 'materials':\n\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\t\tif ( nodeProperty === undefined ) {\n\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\n\t\t\t}\n\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\n\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t\t} else {\n\n\t\t\t\tthis.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tthis.node = null;\n\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\n\t\t}\n\n\t};\n\n\tObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function() {},\n\t\t_setValue_unavailable: function() {},\n\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\n\t\tGetterByBindingType: [\n\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\t\tvar source = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t\t},\n\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t\t}\n\n\t\t],\n\n\t\tSetterByBindingTypeAndVersioning: [\n\n\t\t\t[\n\t\t\t\t// Direct\n\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// EntireArray\n\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// ArrayElement\n\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t], [\n\n\t\t\t\t// HasToFromArray\n\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t\t},\n\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t]\n\n\t\t]\n\n\t} );\n\n\tPropertyBinding.Composite =\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\tPropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t};\n\n\tPropertyBinding.Composite.prototype = {\n\n\t\tconstructor: PropertyBinding.Composite,\n\n\t\tgetValue: function( array, offset ) {\n\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t\t},\n\n\t\tsetValue: function( array, offset ) {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].bind();\n\n\t\t\t}\n\n\t\t},\n\n\t\tunbind: function() {\n\n\t\t\tvar bindings = this._bindings;\n\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tbindings[ i ].unbind();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.create = function( root, path, parsedPath ) {\n\n\t\tif ( ! ( (root && root.isAnimationObjectGroup) ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t};\n\n\tPropertyBinding.parseTrackName = function( trackName ) {\n\n\t\t// matches strings in the form of:\n\t\t//    nodeName.property\n\t\t//    nodeName.property[accessor]\n\t\t//    nodeName.material.property[accessor]\n\t\t//    uuid.property[accessor]\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t//    parentName/nodeName.property\n\t\t//    parentName/parentName/nodeName.property[index]\n\t\t//    .bone[Armature.DEF_cog].position\n\t\t//    scene:helium_balloon_model:helium_balloon_model.position\n\t\t// created and tested via https://regex101.com/#javascript\n\n\t\tvar re = /^((?:\\w+[\\/:])*)(\\w+)?(?:\\.(\\w+)(?:\\[(.+)\\])?)?\\.(\\w+)(?:\\[(.+)\\])?$/;\n\t\tvar matches = re.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t\t}\n\n\t\tvar results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ], \t// allowed to be null, specified root node.\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ],\n\t\t\tpropertyIndex: matches[ 6 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t};\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t};\n\n\tPropertyBinding.findNode = function( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\t\treturn bone;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\t\tif ( bone ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\n\tfunction AnimationObjectGroup( var_args ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t},\n\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t\t};\n\n\t}\n\n\tAnimationObjectGroup.prototype = {\n\n\t\tconstructor: AnimationObjectGroup,\n\n\t\tisAnimationObjectGroup: true,\n\n\t\tadd: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index === undefined ) {\n\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\tnew PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\t\tbinding = new PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\tremove: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// remove & forget\n\t\tuncache: function( var_args ) {\n\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t\t},\n\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\t\tindex = bindings.length;\n\n\t\t\tindicesByPath[ path ] = index;\n\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\n\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\tnew PropertyBinding( object, path, parsedPath );\n\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\n\t\t},\n\n\t\tunsubscribe_: function( path ) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\n\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: \tZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = -1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n\t}\n\n\tAnimationAction.prototype = {\n\n\t\tconstructor: AnimationAction,\n\n\t\t// State & Scheduling\n\n\t\tplay: function() {\n\n\t\t\tthis._mixer._activateAction( this );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstop: function() {\n\n\t\t\tthis._mixer._deactivateAction( this );\n\n\t\t\treturn this.reset();\n\n\t\t},\n\n\t\treset: function() {\n\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\n\t\t},\n\n\t\tisRunning: function() {\n\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\t// return true when play has been called\n\t\tisScheduled: function() {\n\n\t\t\treturn this._mixer._isActiveAction( this );\n\n\t\t},\n\n\t\tstartAt: function( time ) {\n\n\t\t\tthis._startTime = time;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetLoop: function( mode, repetitions ) {\n\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Weight\n\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function( weight ) {\n\n\t\t\tthis.weight = weight;\n\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\t\treturn this.stopFading();\n\n\t\t},\n\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function() {\n\n\t\t\treturn this._effectiveWeight;\n\n\t\t},\n\n\t\tfadeIn: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t\t},\n\n\t\tfadeOut: function( duration ) {\n\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t\t},\n\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\n\t\t\tif( warp ) {\n\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t\t},\n\n\t\tstopFading: function() {\n\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\t\tif ( weightInterpolant !== null ) {\n\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Time Scale Control\n\n\t\t// set the weight stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function() {\n\n\t\t\treturn this._effectiveTimeScale;\n\n\t\t},\n\n\t\tsetDuration: function( duration ) {\n\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\tsyncWith: function( action ) {\n\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\n\t\t\treturn this.stopWarping();\n\n\t\t},\n\n\t\thalt: function( duration ) {\n\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t\t},\n\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tstopWarping: function() {\n\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Object Accessors\n\n\t\tgetMixer: function() {\n\n\t\t\treturn this._mixer;\n\n\t\t},\n\n\t\tgetClip: function() {\n\n\t\t\treturn this._clip;\n\n\t\t},\n\n\t\tgetRoot: function() {\n\n\t\t\treturn this._localRoot || this._mixer._root;\n\n\t\t},\n\n\t\t// Interna\n\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t// called by the mixer\n\n\t\t\tvar startTime = this._startTime;\n\n\t\t\tif ( startTime !== null ) {\n\n\t\t\t\t// check for scheduled start of action\n\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t\t}\n\n\t\t\t\t// start\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t\t// apply time scale and advance time\n\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\t\t\tvar weight = this._updateWeight( time );\n\n\t\t\tif ( weight > 0 ) {\n\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_updateWeight: function( time ) {\n\n\t\t\tvar weight = 0;\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\n\t\t},\n\n\t\t_updateTimeScale: function( time ) {\n\n\t\t\tvar timeScale = 0;\n\n\t\t\tif ( ! this.paused ) {\n\n\t\t\t\ttimeScale = this.timeScale;\n\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\n\t\t},\n\n\t\t_updateTime: function( deltaTime ) {\n\n\t\t\tvar time = this.time + deltaTime;\n\n\t\t\tif ( deltaTime === 0 ) return time;\n\n\t\t\tvar duration = this._clip.duration,\n\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\n\t\t\tif ( loop === LoopOnce ) {\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\n\t\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\t\ttime = duration;\n\n\t\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\t\ttime = 0;\n\n\t\t\t\t\t} else break handle_stop;\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t// wrap around\n\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\n\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\n\t\t},\n\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\t\tvar settings = this._interpolantSettings;\n\n\t\t\tif ( pingPong ) {\n\n\t\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\n\n\t\t\t} else {\n\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\t\tif ( atStart ) {\n\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t\tif ( atEnd ) {\n\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\tZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant === null ) {\n\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t\t}\n\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\n\tfunction AnimationMixer( root ) {\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\tObject.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\t\treturn existingAction;\n\n\t\t\t\t}\n\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t\t}\n\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\t\treturn newAction;\n\n\t\t},\n\n\t\t// get an existing action\n\t\texistingAction: function( clip, optionalRoot ) {\n\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function() {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tactions[ i ].reset();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].useCount = 0;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// advance the time and update apply the animation\n\t\tupdate: function( deltaTime ) {\n\n\t\t\tdeltaTime *= this.timeScale;\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t\t// run active actions\n\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\t\tvar action = actions[ i ];\n\n\t\t\t\tif ( action.enabled ) {\n\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update scene graph\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// return this mixer's root target object\n\t\tgetRoot: function() {\n\n\t\t\treturn this._root;\n\n\t\t},\n\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function( clip ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function( root ) {\n\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\t\tif ( action !== undefined ) {\n\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingByName !== undefined ) {\n\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\t\tif ( action !== null ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// Implementation details:\n\n\tObject.assign( AnimationMixer.prototype, {\n\n\t\t_bindAction: function( action, prototypeAction ) {\n\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\t\tif ( bindingsByName === undefined ) {\n\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t\t}\n\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t\t}\n\n\t\t},\n\n\t\t_activateAction: function( action ) {\n\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t_deactivateAction: function( action ) {\n\n\t\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction( action );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Memory manager\n\n\t\t_initMemoryManager: function() {\n\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n\t\t\t// }\n\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\n\t\t\tvar scope = this;\n\n\t\t\tthis.stats = {\n\n\t\t\t\tactions: {\n\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Memory management for AnimationAction objects\n\n\t\t_isActiveAction: function( action ) {\n\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\n\t\t},\n\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\t\tif ( actionsForClip === undefined ) {\n\n\t\t\t\tactionsForClip = {\n\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\n\t\t\t\t};\n\n\t\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t\t} else {\n\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t\t},\n\n\t\t_removeInactiveAction: function( action ) {\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\n\t\t\taction._cacheIndex = null;\n\n\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\n\t\t\taction._byClipCacheIndex = null;\n\n\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\t\tdelete actionByRoot[ rootUuid ];\n\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t},\n\n\t\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendAction: function( action ) {\n\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t\t},\n\n\t\t_takeBackAction: function( action ) {\n\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t\t},\n\n\t\t// Memory management for PropertyMixer objects\n\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tbindings = this._bindings;\n\n\t\t\tif ( bindingByName === undefined ) {\n\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t\t}\n\n\t\t\tbindingByName[ trackName ] = binding;\n\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\n\t\t},\n\n\t\t_removeInactiveBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\n\t\t\tdelete bindingByName[ trackName ];\n\n\t\t\tremove_empty_map: {\n\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t\t}\n\n\t\t},\n\n\t\t_lendBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t\t},\n\n\t\t_takeBackBinding: function( binding ) {\n\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t\t},\n\n\n\t\t// Memory management of Interpolants for weight and time scale\n\n\t\t_lendControlInterpolant: function() {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\t\tif ( interpolant === undefined ) {\n\n\t\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t\t}\n\n\t\t\treturn interpolant;\n\n\t\t},\n\n\t\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t\t},\n\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n\t} );\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Uniform( value ) {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferGeometry() {\n\n\t\tBufferGeometry.call( this );\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\n\t}\n\n\tInstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n\tInstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tInstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t};\n\n\tInstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized === true;\n\n\t}\n\n\n\tInterleavedBufferAttribute.prototype = {\n\n\t\tconstructor: InterleavedBufferAttribute,\n\n\t\tisInterleavedBufferAttribute: true,\n\n\t\tget count() {\n\n\t\t\treturn this.data.count;\n\n\t\t},\n\n\t\tget array() {\n\n\t\t\treturn this.data.array;\n\n\t\t},\n\n\t\tsetX: function ( index, x ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetY: function ( index, y ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetZ: function ( index, z ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetW: function ( index, w ) {\n\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetX: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t\t},\n\n\t\tgetY: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\t},\n\n\t\tgetZ: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\t},\n\n\t\tgetW: function ( index ) {\n\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\t},\n\n\t\tsetXY: function ( index, x, y ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZ: function ( index, x, y, z ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\t\tindex = index * this.data.stride + this.offset;\n\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InterleavedBuffer( array, stride ) {\n\n\t\tthis.uuid = _Math.generateUUID();\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t}\n\n\tInterleavedBuffer.prototype = {\n\n\t\tconstructor: InterleavedBuffer,\n\n\t\tisInterleavedBuffer: true,\n\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t},\n\n\t\tsetArray: function ( array ) {\n\n\t\t\tif ( Array.isArray( array ) ) {\n\n\t\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t\t}\n\n\t\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\t\tthis.array = array;\n\n\t\t},\n\n\t\tsetDynamic: function ( value ) {\n\n\t\t\tthis.dynamic = value;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopy: function ( source ) {\n\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tset: function ( value, offset ) {\n\n\t\t\tif ( offset === undefined ) offset = 0;\n\n\t\t\tthis.array.set( value, offset );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\t\tInterleavedBuffer.call( this, array, stride );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n\tInstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tInstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\n\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\n\t\tBufferAttribute.call( this, array, itemSize );\n\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n\t}\n\n\tInstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n\tInstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tInstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\n\tfunction Raycaster( origin, direction, near, far ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t}\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tRaycaster.prototype = {\n\n\t\tconstructor: Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( (camera && camera.isPerspectiveCamera) ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( (camera && camera.isOrthographicCamera) ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Clock( autoStart ) {\n\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tClock.prototype = {\n\n\t\tconstructor: Clock,\n\n\t\tstart: function () {\n\n\t\t\tthis.startTime = ( performance || Date ).now();\n\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\n\t\t},\n\n\t\tgetElapsedTime: function () {\n\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\n\t\t},\n\n\t\tgetDelta: function () {\n\n\t\t\tvar diff = 0;\n\n\t\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\t\tthis.start();\n\n\t\t\t}\n\n\t\t\tif ( this.running ) {\n\n\t\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\n\t\t\t\tthis.elapsedTime += diff;\n\n\t\t\t}\n\n\t\t\treturn diff;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Spline from Tween.js, slightly optimized (and trashed)\n\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t *\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction Spline( points ) {\n\n\t\tthis.points = points;\n\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\tpoint, intPoint, weight, w2, w3,\n\t\tpa, pb, pc, pd;\n\n\t\tthis.initFromArray = function ( a ) {\n\n\t\t\tthis.points = [];\n\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getPoint = function ( k ) {\n\n\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\tpd = this.points[ c[ 3 ] ];\n\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\t\treturn v3;\n\n\t\t};\n\n\t\tthis.getControlPointsArray = function () {\n\n\t\t\tvar i, p, l = this.points.length,\n\t\t\t\tcoords = [];\n\n\t\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\t\tp = this.points[ i ];\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t\t}\n\n\t\t\treturn coords;\n\n\t\t};\n\n\t\t// approximate length by summing linear segments\n\n\t\tthis.getLength = function ( nSubDivisions ) {\n\n\t\t\tvar i, index, nSamples, position,\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\toldPosition = new Vector3(),\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tchunkLengths = [],\n\t\t\t\ttotalLength = 0;\n\n\t\t\t// first point has 0 length\n\n\t\t\tchunkLengths[ 0 ] = 0;\n\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\t\tindex = i / nSamples;\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\ttmpVec.copy( position );\n\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\t\toldPosition.copy( position );\n\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\tintPoint = Math.floor( point );\n\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// last point ends with total length\n\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t\t};\n\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\t\tvar i, j,\n\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\trealDistance,\n\t\t\t\tsampling, position,\n\t\t\t\tnewpoints = [],\n\t\t\t\ttmpVec = new Vector3(),\n\t\t\t\tsl = this.getLength();\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t\t}\n\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tthis.points = newpoints;\n\n\t\t};\n\n\t\t// Catmull-Rom\n\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\n\tfunction Spherical( radius, phi, theta ) {\n\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\t\treturn this;\n\n\t}\n\n\tSpherical.prototype = {\n\n\t\tconstructor: Spherical,\n\n\t\tset: function ( radius, phi, theta ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tclone: function () {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t},\n\n\t\tcopy: function ( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function() {\n\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromVector3: function( vec3 ) {\n\n\t\t\tthis.radius = vec3.length();\n\n\t\t\tif ( this.radius === 0 ) {\n\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t};\n\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\r\n\tfunction MorphBlendMesh( geometry, material ) {\n\r\n\t\tMesh.call( this, geometry, material );\r\n\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\t\tvar name = \"__default\";\r\n\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\r\n\t\tvar fps = numFrames / 1;\r\n\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\r\n\t}\r\n\r\n\tMorphBlendMesh.prototype = Object.create( Mesh.prototype );\r\n\tMorphBlendMesh.prototype.constructor = MorphBlendMesh;\r\n\r\n\tMorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\t\tvar animation = {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\r\n\t\t\tlength: end - start + 1,\r\n\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\r\n\t\t\tactive: false,\r\n\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\r\n\t\t};\r\n\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in frameRanges ) {\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t\t}\r\n\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.weight = weight;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = time;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\t\tvar time = 0;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\ttime = animation.time;\r\n\r\n\t\t}\r\n\r\n\t\treturn time;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\t\tvar duration = - 1;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tduration = animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\treturn duration;\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.active = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tMorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\t\tif ( ! animation.active ) continue;\r\n\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tfunction ImmediateRenderObject( material ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.material = material;\n\t\tthis.render = function ( renderCallback ) {};\n\n\t}\n\n\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\n\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\n\tVertexNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\t\tvar faces = objGeometry.faces;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {\n\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\t\tvar idx = 0;\n\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction SpotLightHelper( light ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = [\n\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t0, 0, 0,   0, - 1,   1\n\t\t];\n\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\n\tSpotLightHelper.prototype.constructor = SpotLightHelper;\n\n\tSpotLightHelper.prototype.dispose = function () {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t};\n\n\tSpotLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar vector2 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t */\n\n\tfunction SkeletonHelper( object ) {\n\n\t\tthis.bones = this.getBoneList( object );\n\n\t\tvar geometry = new Geometry();\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\t\tgeometry.colors.push( new Color( 0, 0, 1 ) );\n\t\t\t\tgeometry.colors.push( new Color( 0, 1, 0 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.dynamic = true;\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.root = object;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\n\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\n\tSkeletonHelper.prototype.constructor = SkeletonHelper;\n\n\tSkeletonHelper.prototype.getBoneList = function( object ) {\n\n\t\tvar boneList = [];\n\n\t\tif ( (object && object.isBone) ) {\n\n\t\t\tboneList.push( object );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t\t}\n\n\t\treturn boneList;\n\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\n\t\tvar geometry = this.geometry;\n\n\t\tvar matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );\n\n\t\tvar boneMatrix = new Matrix4();\n\n\t\tvar j = 0;\n\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( (bone.parent && bone.parent.isBone) ) {\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t\tgeometry.computeBoundingSphere();\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction PointLightHelper( light, sphereSize ) {\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\tMesh.call( this, geometry, material );\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\t\tvar d = light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\n\t}\n\n\tPointLightHelper.prototype = Object.create( Mesh.prototype );\n\tPointLightHelper.prototype.constructor = PointLightHelper;\n\n\tPointLightHelper.prototype.dispose = function () {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t};\n\n\tPointLightHelper.prototype.update = function () {\n\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t/*\n\t\tvar d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t};\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction HemisphereLightHelper( light, sphereSize ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.colors = [ new Color(), new Color() ];\n\n\t\tvar geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t\t}\n\n\t\tvar material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );\n\n\t\tthis.lightSphere = new Mesh( geometry, material );\n\t\tthis.add( this.lightSphere );\n\n\t\tthis.update();\n\n\t}\n\n\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\n\tHemisphereLightHelper.prototype.dispose = function () {\n\n\t\tthis.lightSphere.geometry.dispose();\n\t\tthis.lightSphere.material.dispose();\n\n\t};\n\n\tHemisphereLightHelper.prototype.update = function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction GridHelper( size, divisions, color1, color2 ) {\n\n\t\tdivisions = divisions || 1;\n\t\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\t\tvar center = divisions / 2;\n\t\tvar step = ( size * 2 ) / divisions;\n\t\tvar vertices = [], colors = [];\n\n\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\n\t\t\tvar color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tGridHelper.prototype = Object.create( LineSegments.prototype );\n\tGridHelper.prototype.constructor = GridHelper;\n\n\tGridHelper.prototype.setColors = function () {\n\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\n\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\n\t\tthis.object = object;\n\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t\t//\n\n\t\tvar nNormals = 0;\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( (objGeometry && objGeometry.isGeometry) ) {\n\n\t\t\tnNormals = objGeometry.faces.length;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar positions = new Float32Attribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.addAttribute( 'position', positions );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\n\t}\n\n\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\n\tFaceNormalsHelper.prototype.update = ( function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar normalMatrix = new Matrix3();\n\n\t\treturn function update() {\n\n\t\t\tthis.object.updateMatrixWorld( true );\n\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\t\tvar position = this.geometry.attributes.position;\n\n\t\t\t//\n\n\t\t\tvar objGeometry = this.object.geometry;\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() );\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tfunction DirectionalLightHelper( light, size ) {\n\n\t\tObject3D.call( this );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [\n\t\t\t- size,   size, 0,\n\t\t\t  size,   size, 0,\n\t\t\t  size, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size,   size, 0\n\t\t], 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { fog: false } );\n\n\t\tthis.add( new Line( geometry, material ) );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.add( new Line( geometry, material ));\n\n\t\tthis.update();\n\n\t}\n\n\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\n\tDirectionalLightHelper.prototype.dispose = function () {\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.geometry.dispose();\n\t\tlightPlane.material.dispose();\n\t\ttargetLine.geometry.dispose();\n\t\ttargetLine.material.dispose();\n\n\t};\n\n\tDirectionalLightHelper.prototype.update = function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\t\tvar v3 = new Vector3();\n\n\t\treturn function update() {\n\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\n\t\t\tlightPlane.lookAt( v3 );\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t\ttargetLine.lookAt( v3 );\n\t\t\ttargetLine.scale.z = v3.length();\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\tfunction CameraHelper( camera ) {\n\n\t\tvar geometry = new Geometry();\n\t\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\t\tvar pointMap = {};\n\n\t\t// colors\n\n\t\tvar hexFrustum = 0xffaa00;\n\t\tvar hexCone = 0xff0000;\n\t\tvar hexUp = 0x00aaff;\n\t\tvar hexTarget = 0xffffff;\n\t\tvar hexCross = 0x333333;\n\n\t\t// near\n\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t\t// far\n\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t\t// sides\n\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t\t// cone\n\n\t\taddLine( \"p\", \"n1\", hexCone );\n\t\taddLine( \"p\", \"n2\", hexCone );\n\t\taddLine( \"p\", \"n3\", hexCone );\n\t\taddLine( \"p\", \"n4\", hexCone );\n\n\t\t// up\n\n\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\taddLine( \"u3\", \"u1\", hexUp );\n\n\t\t// target\n\n\t\taddLine( \"c\", \"t\", hexTarget );\n\t\taddLine( \"p\", \"c\", hexCross );\n\n\t\t// cross\n\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\t\tfunction addLine( a, b, hex ) {\n\n\t\t\taddPoint( a, hex );\n\t\t\taddPoint( b, hex );\n\n\t\t}\n\n\t\tfunction addPoint( id, hex ) {\n\n\t\t\tgeometry.vertices.push( new Vector3() );\n\t\t\tgeometry.colors.push( new Color( hex ) );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t\t}\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t\tthis.camera = camera;\n\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t}\n\n\tCameraHelper.prototype = Object.create( LineSegments.prototype );\n\tCameraHelper.prototype.constructor = CameraHelper;\n\n\tCameraHelper.prototype.update = function () {\n\n\t\tvar geometry, pointMap;\n\n\t\tvar vector = new Vector3();\n\t\tvar camera = new Camera();\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\t\tvar points = pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function update() {\n\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\n\t\t\tvar w = 1, h = 1;\n\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t\t// center / target\n\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t\t// near\n\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t\t// far\n\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t\t// up\n\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t\t// cross\n\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\t\tgeometry.verticesNeedUpdate = true;\n\n\t\t};\n\n\t}();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\t// a helper to show the world-axis-aligned bounding box for an object\n\n\tfunction BoundingBoxHelper( object, hex ) {\n\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\t\tthis.object = object;\n\n\t\tthis.box = new Box3();\n\n\t\tMesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n\t}\n\n\tBoundingBoxHelper.prototype = Object.create( Mesh.prototype );\n\tBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\n\tBoundingBoxHelper.prototype.update = function () {\n\n\t\tthis.box.setFromObject( this.object );\n\n\t\tthis.box.getSize( this.scale );\n\n\t\tthis.box.getCenter( this.position );\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction BoxHelper( object, color ) {\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tthis.update( object );\n\n\t\t}\n\n\t}\n\n\tBoxHelper.prototype = Object.create( LineSegments.prototype );\n\tBoxHelper.prototype.constructor = BoxHelper;\n\n\tBoxHelper.prototype.update = ( function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function update( object ) {\n\n\t\t\tif ( (object && object.isBox3) ) {\n\n\t\t\t\tbox.copy( object );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromObject( object );\n\n\t\t\t}\n\n\t\t\tif ( box.isEmpty() ) return;\n\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t\tthis.geometry.computeBoundingSphere();\n\n\t\t};\n\n\t} )();\n\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\n\tvar lineGeometry = new BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tObject3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tArrowHelper.prototype = Object.create( Object3D.prototype );\n\tArrowHelper.prototype.constructor = ArrowHelper;\n\n\tArrowHelper.prototype.setDirection = ( function () {\n\n\t\tvar axis = new Vector3();\n\t\tvar radians;\n\n\t\treturn function setDirection( dir ) {\n\n\t\t\t// dir is assumed to be normalized\n\n\t\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\t\tradians = Math.acos( dir.y );\n\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t};\n\n\tArrowHelper.prototype.setColor = function ( color ) {\n\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\n\t};\n\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction AxisHelper( size ) {\n\n\t\tsize = size || 1;\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t0, 0, 0,  0, 0, size\n\t\t] );\n\n\t\tvar colors = new Float32Array( [\n\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t] );\n\n\t\tvar geometry = new BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\t\tLineSegments.call( this, geometry, material );\n\n\t}\n\n\tAxisHelper.prototype = Object.create( LineSegments.prototype );\n\tAxisHelper.prototype.constructor = AxisHelper;\n\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\tvar CatmullRomCurve3 = ( function() {\n\n\t\tvar\n\t\t\ttmp = new Vector3(),\n\t\t\tpx = new CubicPoly(),\n\t\t\tpy = new CubicPoly(),\n\t\t\tpz = new CubicPoly();\n\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\n\t\tfunction CubicPoly() {}\n\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\t\tthis.c0 = x0;\n\t\t\tthis.c1 = t0;\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t\t};\n\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\t// initCubicPoly\n\t\t\tthis.init( x1, x2, t1, t2 );\n\n\t\t};\n\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t};\n\n\t\tCubicPoly.prototype.calc = function( t ) {\n\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t\t};\n\n\t\t// Subclass Three.js curve\n\t\treturn Curve.create(\n\n\t\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\t\tthis.points = p || [];\n\t\t\t\tthis.closed = false;\n\n\t\t\t},\n\n\t\t\tfunction ( t ) {\n\n\t\t\t\tvar points = this.points,\n\t\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\t\tl = points.length;\n\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\n\t\t\t\tif ( this.closed ) {\n\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\tweight = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate first point\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\tp0 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// extrapolate last point\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\tp3 = tmp;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new Vector3(\n\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\tpz.calc( weight )\n\t\t\t\t);\n\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t);\n\n\t} )();\n\n\t/**************************************************************\n\t *\tClosed Spline 3D curve\n\t **************************************************************/\n\n\n\tfunction ClosedSplineCurve3( points ) {\n\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\t\tCatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\n\t}\n\n\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n\t/**************************************************************\n\t *\tSpline 3D curve\n\t **************************************************************/\n\n\n\tvar SplineCurve3 = Curve.create(\n\n\t\tfunction ( points /* array of Vector3 */ ) {\n\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\tthis.points = ( points === undefined ) ? [] : points;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\t\tvar interpolate = CurveUtils.interpolate;\n\n\t\t\treturn new Vector3(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tCubic Bezier 3D curve\n\t **************************************************************/\n\n\tvar CubicBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2, v3 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b3 = ShapeUtils.b3;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tQuadratic Bezier 3D curve\n\t **************************************************************/\n\n\tvar QuadraticBezierCurve3 = Curve.create(\n\n\t\tfunction ( v0, v1, v2 ) {\n\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar b2 = ShapeUtils.b2;\n\n\t\t\treturn new Vector3(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t);\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tLine3D\n\t **************************************************************/\n\n\tvar LineCurve3 = Curve.create(\n\n\t\tfunction ( v1, v2 ) {\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tif ( t === 1 ) {\n\n\t\t\t\treturn this.v2.clone();\n\n\t\t\t}\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\tvector.multiplyScalar( t );\n\t\t\tvector.add( this.v1 );\n\n\t\t\treturn vector;\n\n\t\t}\n\n\t);\n\n\t/**************************************************************\n\t *\tArc curve\n\t **************************************************************/\n\n\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t}\n\n\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\n\tArcCurve.prototype.constructor = ArcCurve;\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tvar SceneUtils = {\n\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\t\tvar group = new Group();\n\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t},\n\n\t\tdetach: function ( child, parent, scene ) {\n\n\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\tparent.remove( child );\n\t\t\tscene.add( child );\n\n\t\t},\n\n\t\tattach: function ( child, scene, parent ) {\n\n\t\t\tvar matrixWorldInverse = new Matrix4();\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\t\tscene.remove( child );\n\t\t\tparent.add( child );\n\n\t\t}\n\n\t};\n\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tfunction Face4 ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new Face3( a, b, c, normal, color, materialIndex );\n\t}\n\n\tvar LineStrip = 0;\n\n\tvar LinePieces = 1;\n\n\tfunction PointCloud ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction ParticleSystem ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new Points( geometry, material );\n\t}\n\n\tfunction PointCloudMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleBasicMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction ParticleSystemMaterial ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new PointsMaterial( parameters );\n\t}\n\n\tfunction Vertex ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new Vector3( x, y, z );\n\t}\n\n\t//\n\n\tfunction EdgesHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\t\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\tfunction WireframeHelper( object, hex ) {\n\t\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\t\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\t}\n\n\t//\n\n\tObject.assign( Box2.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Box3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t},\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t},\n\t\tsize: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\t\treturn this.getSize( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Line3.prototype, {\n\t\tcenter: function ( optionalTarget ) {\n\t\t\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\t\t\treturn this.getCenter( optionalTarget );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix3.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t}\n\t} );\n\n\tObject.assign( Matrix4.prototype, {\n\t\textractPosition: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\t\t},\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\treturn vector.applyProjection( this );\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t},\n\t\trotateAxis: function ( v ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\ttranslate: function ( v ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t},\n\t\trotateX: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t},\n\t\trotateY: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t},\n\t\trotateZ: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t},\n\t\trotateByAxis: function ( axis, angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.assign( Plane.prototype, {\n\t\tisIntersectionLine: function ( line ) {\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\t}\n\t} );\n\n\tObject.assign( Quaternion.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\t}\n\t} );\n\n\tObject.assign( Ray.prototype, {\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\n\tObject.assign( Shape.prototype, {\n\t\textrude: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\t\treturn new ExtrudeGeometry( this, options );\n\t\t},\n\t\tmakeGeometry: function ( options ) {\n\t\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\t\treturn new ShapeGeometry( this, options );\n\t\t}\n\t} );\n\n\tObject.assign( Vector3.prototype, {\n\t\tsetEulerFromRotationMatrix: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Object3D.prototype, {\n\t\tgetChildByName: function ( name ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\t\t},\n\t\trenderDepth: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t}\n\t} );\n\n\tObject.defineProperties( Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( LOD.prototype, {\n\t\tobjects: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\n\t};\n\n\t//\n\n\tObject.defineProperties( Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.assign( BufferGeometry.prototype, {\n\t\taddIndex: function ( index ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\t\t},\n\t\tclearDrawCalls: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\t\t},\n\t\tcomputeTangents: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t},\n\t\tcomputeOffsets: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( MeshPhongMaterial.prototype, {\n\t\tmetal: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tEventDispatcher.prototype = Object.assign( Object.create( {\n\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\t\tconstructor: EventDispatcher,\n\n\t\tapply: function ( target ) {\n\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\t\tObject.assign( target, this );\n\n\t\t}\n\n\t} ), EventDispatcher.prototype );\n\n\t//\n\n\tObject.defineProperties( Uniform.prototype, {\n\t\tdynamic: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t}\n\t\t},\n\t\tonUpdate: {\n\t\t\tvalue: function () {\n\t\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( WebGLRenderer.prototype, {\n\t\tsupportsFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\t\t\treturn this.capabilities.vertexTextures;\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\t\t},\n\t\tinitMaterial: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t},\n\t\taddPrePlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t},\n\t\taddPostPlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t},\n\t\tupdateShadowMap: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\tObject.defineProperties( WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\t\t\t},\n\t\t\tset: function ( cullFace ) {\n\t\t\t\tvar value = ( cullFace !== CullFaceBack );\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\tthis.renderReverseSided = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.defineProperties( WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t} );\n\n\t//\n\n\tObject.assign( Audio.prototype, {\n\t\tload: function ( file ) {\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\tscope.setBuffer( buffer );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\n\tObject.assign( AudioAnalyser.prototype, {\n\t\tgetData: function ( file ) {\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\t}\n\t} );\n\n\t//\n\n\tvar GeometryUtils = {\n\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\t\tvar matrix;\n\n\t\t\tif ( geometry2.isMesh ) {\n\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t\t}\n\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t\t},\n\n\t\tcenter: function ( geometry ) {\n\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\n\t\t}\n\n\t};\n\n\tvar ImageUtils = {\n\n\t\tcrossOrigin: undefined,\n\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\t\tvar loader = new TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\t\tvar loader = new CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tloadCompressedTexture: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t},\n\n\t\tloadCompressedTextureCube: function () {\n\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tfunction Projector () {\n\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\t\tthis.projectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\n\t\t};\n\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\n\t\t};\n\n\t\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t\t};\n\n\t}\n\n\t//\n\n\tfunction CanvasRenderer () {\n\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\n\t}\n\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.ShaderLib = ShaderLib;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.FogExp2 = FogExp2;\n\texports.Fog = Fog;\n\texports.Scene = Scene;\n\texports.LensFlare = LensFlare;\n\texports.Sprite = Sprite;\n\texports.LOD = LOD;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.Skeleton = Skeleton;\n\texports.Bone = Bone;\n\texports.Mesh = Mesh;\n\texports.LineSegments = LineSegments;\n\texports.Line = Line;\n\texports.Points = Points;\n\texports.Group = Group;\n\texports.VideoTexture = VideoTexture;\n\texports.DataTexture = DataTexture;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CubeTexture = CubeTexture;\n\texports.CanvasTexture = CanvasTexture;\n\texports.DepthTexture = DepthTexture;\n\texports.TextureIdCount = TextureIdCount;\n\texports.Texture = Texture;\n\texports.MaterialIdCount = MaterialIdCount;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.TextureLoader = TextureLoader;\n\texports.ObjectLoader = ObjectLoader;\n\texports.MaterialLoader = MaterialLoader;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.LoadingManager = LoadingManager;\n\texports.JSONLoader = JSONLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.FontLoader = FontLoader;\n\texports.XHRLoader = XHRLoader;\n\texports.Loader = Loader;\n\texports.Cache = Cache;\n\texports.AudioLoader = AudioLoader;\n\texports.SpotLightShadow = SpotLightShadow;\n\texports.SpotLight = SpotLight;\n\texports.PointLight = PointLight;\n\texports.HemisphereLight = HemisphereLight;\n\texports.DirectionalLightShadow = DirectionalLightShadow;\n\texports.DirectionalLight = DirectionalLight;\n\texports.AmbientLight = AmbientLight;\n\texports.LightShadow = LightShadow;\n\texports.Light = Light;\n\texports.StereoCamera = StereoCamera;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.CubeCamera = CubeCamera;\n\texports.Camera = Camera;\n\texports.AudioListener = AudioListener;\n\texports.PositionalAudio = PositionalAudio;\n\texports.getAudioContext = getAudioContext;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.Audio = Audio;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.PropertyMixer = PropertyMixer;\n\texports.PropertyBinding = PropertyBinding;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.AnimationUtils = AnimationUtils;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationClip = AnimationClip;\n\texports.Uniform = Uniform;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.BufferGeometry = BufferGeometry;\n\texports.GeometryIdCount = GeometryIdCount;\n\texports.Geometry = Geometry;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.BufferAttribute = BufferAttribute;\n\texports.Face3 = Face3;\n\texports.Object3DIdCount = Object3DIdCount;\n\texports.Object3D = Object3D;\n\texports.Raycaster = Raycaster;\n\texports.Layers = Layers;\n\texports.EventDispatcher = EventDispatcher;\n\texports.Clock = Clock;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.Interpolant = Interpolant;\n\texports.Triangle = Triangle;\n\texports.Spline = Spline;\n\texports.Math = _Math;\n\texports.Spherical = Spherical;\n\texports.Plane = Plane;\n\texports.Frustum = Frustum;\n\texports.Sphere = Sphere;\n\texports.Ray = Ray;\n\texports.Matrix4 = Matrix4;\n\texports.Matrix3 = Matrix3;\n\texports.Box3 = Box3;\n\texports.Box2 = Box2;\n\texports.Line3 = Line3;\n\texports.Euler = Euler;\n\texports.Vector4 = Vector4;\n\texports.Vector3 = Vector3;\n\texports.Vector2 = Vector2;\n\texports.Quaternion = Quaternion;\n\texports.ColorKeywords = ColorKeywords;\n\texports.Color = Color;\n\texports.MorphBlendMesh = MorphBlendMesh;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.VertexNormalsHelper = VertexNormalsHelper;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.PointLightHelper = PointLightHelper;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.GridHelper = GridHelper;\n\texports.FaceNormalsHelper = FaceNormalsHelper;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.CameraHelper = CameraHelper;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.BoxHelper = BoxHelper;\n\texports.ArrowHelper = ArrowHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.SplineCurve3 = SplineCurve3;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.LineCurve3 = LineCurve3;\n\texports.ArcCurve = ArcCurve;\n\texports.EllipseCurve = EllipseCurve;\n\texports.SplineCurve = SplineCurve;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.LineCurve = LineCurve;\n\texports.Shape = Shape;\n\texports.ShapePath = ShapePath;\n\texports.Path = Path;\n\texports.Font = Font;\n\texports.CurvePath = CurvePath;\n\texports.Curve = Curve;\n\texports.ShapeUtils = ShapeUtils;\n\texports.SceneUtils = SceneUtils;\n\texports.CurveUtils = CurveUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.ParametricBufferGeometry = ParametricBufferGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.TubeBufferGeometry = TubeBufferGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusBufferGeometry = TorusBufferGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.SphereBufferGeometry = SphereBufferGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.RingBufferGeometry = RingBufferGeometry;\n\texports.PlaneBufferGeometry = PlaneBufferGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.LatheBufferGeometry = LatheBufferGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.ConeBufferGeometry = ConeBufferGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.CylinderBufferGeometry = CylinderBufferGeometry;\n\texports.CircleBufferGeometry = CircleBufferGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.BoxBufferGeometry = BoxBufferGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.PointsMaterial = PointsMaterial;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.Material = Material;\n\texports.REVISION = REVISION;\n\texports.MOUSE = MOUSE;\n\texports.CullFaceNone = CullFaceNone;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.FrontSide = FrontSide;\n\texports.BackSide = BackSide;\n\texports.DoubleSide = DoubleSide;\n\texports.FlatShading = FlatShading;\n\texports.SmoothShading = SmoothShading;\n\texports.NoColors = NoColors;\n\texports.FaceColors = FaceColors;\n\texports.VertexColors = VertexColors;\n\texports.NoBlending = NoBlending;\n\texports.NormalBlending = NormalBlending;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.CustomBlending = CustomBlending;\n\texports.BlendingMode = BlendingMode;\n\texports.AddEquation = AddEquation;\n\texports.SubtractEquation = SubtractEquation;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.MinEquation = MinEquation;\n\texports.MaxEquation = MaxEquation;\n\texports.ZeroFactor = ZeroFactor;\n\texports.OneFactor = OneFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.NeverDepth = NeverDepth;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.EqualDepth = EqualDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterDepth = GreaterDepth;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.MixOperation = MixOperation;\n\texports.AddOperation = AddOperation;\n\texports.NoToneMapping = NoToneMapping;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.UVMapping = UVMapping;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.SphericalReflectionMapping = SphericalReflectionMapping;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.TextureMapping = TextureMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.TextureWrapping = TextureWrapping;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.TextureFilter = TextureFilter;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.ByteType = ByteType;\n\texports.ShortType = ShortType;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.IntType = IntType;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.FloatType = FloatType;\n\texports.HalfFloatType = HalfFloatType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.AlphaFormat = AlphaFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBAFormat = RGBAFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.RGBEFormat = RGBEFormat;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LoopPingPong = LoopPingPong;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.LinearEncoding = LinearEncoding;\n\texports.sRGBEncoding = sRGBEncoding;\n\texports.GammaEncoding = GammaEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.CubeGeometry = BoxGeometry;\n\texports.Face4 = Face4;\n\texports.LineStrip = LineStrip;\n\texports.LinePieces = LinePieces;\n\texports.MeshFaceMaterial = MultiMaterial;\n\texports.PointCloud = PointCloud;\n\texports.Particle = Sprite;\n\texports.ParticleSystem = ParticleSystem;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Vertex = Vertex;\n\texports.EdgesHelper = EdgesHelper;\n\texports.WireframeHelper = WireframeHelper;\n\texports.GeometryUtils = GeometryUtils;\n\texports.ImageUtils = ImageUtils;\n\texports.Projector = Projector;\n\texports.CanvasRenderer = CanvasRenderer;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n\tObject.defineProperty( exports, 'AudioContext', {\n\t\tget: function () {\n\t\t\treturn exports.getAudioContext();\n\t\t}\n\t});\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three/build/three.js\n// module id = 6\n// module chunks = 0","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./input-button.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-dac84c3e!../node_modules/vue-loader/lib/selector?type=template&index=0!./input-button.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/input-button.vue\n// module id = 7\n// module chunks = 0","/* eslint-disable */\nimport Vue from 'vue'\n// your-tasteful-component is an alias to the path of your component\n// for example: vue build component.vue\n// then `your-tasteful-component` is `component.vue`\nimport App from 'your-tasteful-component'\n\nnew Vue({\n  el: '#app',\n  render: h => h(App)\n})\n\n\n\n// WEBPACK FOOTER //\n// ./~/vue-cli/lib/default-entry.es6","<template>\n\t<div class=\"h-100 container-fluid\">\n\t\t<div class=\"h-100 row\">\n\t\t\t<div class=\"h-100 col-12 main\"\n\t\t\t\t :class=\"{'col-sm-8 col-xl-9': showSidebar}\"\n\t\t\t\t :style=\"{'backgroundColor': 'hsl(0, 0%, ' + settings.backgroundColor + '%)'}\"\n\t\t\t>\n\t\t\t\t<viewport :dataCanvas=\"dataCanvas\"></viewport>\n\t\t\t</div>\n\t\t\t<div\n\t\t\t\tclass=\"\"\n\t\t\t\t:class=\"{'sidebar h-100 col-12 col-sm-4 col-xl-3': showSidebar}\"\n\t\t\t>\n\t\t\t\t<div class=\"settingsToggle\"><a\n\t\t\t\t\tclass=\"icon fa\"\n\t\t\t\t\t:class=\"showSidebar ? 'fa-times' : 'fa-sliders'\"\n\t\t\t\t\t@click=\"settingsToggle\"\n\t\t\t\t></a></div>\n\t\t\t\t<settings\n\t\t\t\t\tv-if=\"showSidebar\"\n\t\t\t\t\t:settings=\"settings\"\n\t\t\t\t\t:dataCanvas=\"dataCanvas\"\n\t\t\t\t></settings>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</template>\n<script>\n\timport Vue from 'vue'\n\timport state from './state'\n\timport Viewport from './viewport.vue'\n\timport Settings from './settings'\n\timport { resizeWindowEventHandler } from './viewport.js'\n\n\n\tlet dataCanvas = document.createElement('canvas');\n\tdataCanvas.className = 'dataCanvas';\n\texport default {\n\t\tcomponents: {\n\t\t\tViewport,\n\t\t\tSettings\n\t\t},\n\t\tdata: function(){\n\t\t\treturn {\n\t\t\t\tshowSidebar: true,\n\t\t\t\tsettings: state,\n\t\t\t\tdataCanvas: dataCanvas\n\t\t\t}\n\t\t},\n\t\tmounted: function(){\n\t\t\tdocument.addEventListener('keydown', this.keyHandler);\n\t\t\tif((/Mac OS X 10/).test(navigator.userAgent)){\n\t\t\t\tdocument.body.parentNode.className += ' disableElasticScrolling';\n\t\t\t}\n\t\t},\n\t\tbeforeDestroy:  function(){\n\t\t\tdocument.removeEventListener('keydown', this.keyHandler);\n\t\t},\n\t\tmethods: {\n\t\t\tkeyHandler: function(keyboardEvent){\n\t\t\t\tlet key = '' + keyboardEvent.code + '-' + (0 + keyboardEvent.ctrlKey);\n\t\t\t\tlet cameraPosition = state.cameraPositionKeymap[key];\n\t\t\t\tif(cameraPosition){\n\t\t\t\t\tif(keyboardEvent.ctrlKey){\n\t\t\t\t\t\tkeyboardEvent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\tstate.cameraPosition = cameraPosition.toLocaleLowerCase();\n\t\t\t\t}\n\t\t\t\tif(key === 'Numpad5-0'){\n\t\t\t\t\tlet mode = state.cameraMode;\n\t\t\t\t\tlet list = state.cameraModeList;\n\t\t\t\t\tstate.cameraMode = mode === list[0] ? list[1] : list[0];\n\t\t\t\t}\n\t\t\t},\n\t\t\tsettingsToggle: function(){\n\t\t\t\tthis.showSidebar = !this.showSidebar;\n\t\t\t\twindow.scrollTo(0,0);\n\t\t\t\trequestAnimationFrame(resizeWindowEventHandler);\n\t\t\t}\n\t\t}\n\t}\n</script>\n<style src=\"font-awesome/css/font-awesome.css\"></style>\n<style src=\"bootstrap/dist/css/bootstrap.css\"></style>\n<style src=\"./styles.css\"></style>\n\n\n\n// WEBPACK FOOTER //\n// app.vue?0a6bfdf7","<template>\n\t<div></div>\n</template>\n<script>\n\texport default {\n\t\tprops: {\n\t\t\tcontent: HTMLElement\n\t\t},\n\t\tmounted: function(){\n\t\t\t//what am I doing with my life\n\t\t\tthis.$el.appendChild(this.content);\n\t\t}\n\t}\n</script>\n\n\n\n// WEBPACK FOOTER //\n// existing-dom-node.vue?4a841854","<template>\n\t<button\n\t\ttype=\"button\"\n\t\tclass=\"btn\"\n\t\t:class=\"classObject\"\n\t\t@click=\"click\"\n\t\tv-html=\"displayLabel\"\n\t></button>\n</template>\n<script>\n\timport {buttonMixin} from './mixin-input';\n\texport default {\n\t\tmixins: [buttonMixin]\n\t};\n</script>\n\n\n\n// WEBPACK FOOTER //\n// input-button.vue?f429e6a0","<template>\n\t<div class=\"form-check\">\n\t\t<label class=\"form-check-label\">\n\t\t\t<input\n\t\t\t\ttype=\"checkbox\"\n\t\t\t\tclass=\"form-check-input\"\n\t\t\t\t:id=\"id\"\n\t\t\t\tv-model=\"internalValue\"\n\t\t\t\tv-on:change=\"change\"\n\t\t\t/>\n\t\t\t{{ label }}\n\t\t</label>\n\t</div>\n</template>\n<script>\n\timport inputMixin from './mixin-input';\n\texport default {\n\t\tprops: {\n\t\t\tvalue: Boolean\n\t\t},\n\t\tmixins: [inputMixin]\n\t}\n</script>\n\n\n\n// WEBPACK FOOTER //\n// input-check.vue?3d26d9df","<template>\n\t<div class=\"form-group\">\n\t\t<label :for=\"id\">{{ label }}</label>\n\t\t<select\n\t\t\tclass=\"form-control\"\n\t\t\t:id=\"id\"\n\t\t\tv-model=\"internalValue\"\n\t\t\tv-on:change=\"change\"\n\t\t>\n\t\t\t<option v-for=\"option in list\" v-bind:value=\"option.value || option\">{{ option.text || option }}</option>\n\t\t</select>\n\t</div>\n</template>\n<script>\n\timport inputMixin from './mixin-input';\n\texport default {\n\t\tmixins: [inputMixin],\n\t\tprops: {\n\t\t\tlist: Array,\n\t\t}\n\t}\n</script>\n\n\n\n// WEBPACK FOOTER //\n// input-select.vue?e6295138","<script>\n\timport state from './state';\n\timport InputButton from './input-button';\n\texport default {\n\t\tmixins: [InputButton],\n\t\tcomputed: {\n\t\t\tdisplayLabel: function () {\n\t\t\t\tlet check = this.active() ? 'fa-check-square-o' : 'fa-square-o ';\n\t\t\t\treturn `<i class=\"fa ${check}\" aria-hidden=\"true\"></i> ${this.label}`;\n\t\t\t}\n\t\t},\n\t\tmethods: {\n\t\t\tactive: function () {\n\t\t\t\treturn state[this.destinationAddress];\n\t\t\t},\n\t\t\tclick: function () {\n\t\t\t\tstate[this.destinationAddress] = !state[this.destinationAddress];\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n\n\n// WEBPACK FOOTER //\n// input-toggle.vue?5a9cd282","<template>\n\t<div class=\"card settings\">\n\t\t<div class=\"card-header\">Settings</div>\n\t\t<div class=\"card-body\">\n\t\t\t<existingDomNode class=\"dataCanvasHolder\" :content=\"dataCanvas\"></existingDomNode>\n\t\t\t<form encType=\"multipart/form-data\">\n\t\t\t\t\t<div class=\"form-group no-gutters\">\n\t\t\t\t\t\t<input-select\n\t\t\t\t\t\t\tlabel=\"Image\"\n\t\t\t\t\t\t\t:list=\"settings.imageList\"\n\t\t\t\t\t\t\t:value=\"settings.image\"\n\t\t\t\t\t\t\tdestinationAddress=\"image\"\n\t\t\t\t\t\t></input-select>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tclass=\"btn btn-primary col-12\"\n\t\t\t\t\t\t\tv-on:click=\"clearAllImages\"\n\t\t\t\t\t\t>Clear all</button>\n\t\t\t\t\t\t<label\n\t\t\t\t\t\t\tfor=\"uploadImage\"\n\t\t\t\t\t\t\tclass=\"btn btn-primary col-12\"\n\t\t\t\t\t\t>Upload Image</label>\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\t\tid=\"uploadImage\"\n\t\t\t\t\t\t\tstyle=\"display: none;\"\n\t\t\t\t\t\t\tv-on:change=\"uploadImage\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"form-group no-gutters\">\n\t\t\t\t\t\t<input-select\n\t\t\t\t\t\t\tclass=\"col-12\"\n\t\t\t\t\t\t\tlabel=\"Display Method\"\n\t\t\t\t\t\t\t:list=\"settings.displayMethodList\"\n\t\t\t\t\t\t\t:value=\"settings.displayMethod\"\n\t\t\t\t\t\t\tdestinationAddress=\"displayMethod\"\n\t\t\t\t\t\t></input-select>\n\t\t\t\t\t\t<input-toggle\n\t\t\t\t\t\t\tclass=\"col-12\"\n\t\t\t\t\t\t\tlabel=\"Show Bounds\"\n\t\t\t\t\t\t\tdestinationAddress=\"showBounds\"\n\t\t\t\t\t\t></input-toggle>\n\t\t\t\t\t</div>\n\t\t\t\t\t<hr />\n\t\t\t\t\t<div class=\"form-group no-gutters\">\n\t\t\t\t\t\t<input-select\n\t\t\t\t\t\t\tclass=\"col-12\"\n\t\t\t\t\t\t\tlabel=\"Camera Mode\"\n\t\t\t\t\t\t\t:list=\"settings.cameraModeList\"\n\t\t\t\t\t\t\t:value=\"settings.cameraMode\"\n\t\t\t\t\t\t\tdestinationAddress=\"cameraMode\"\n\t\t\t\t\t\t></input-select>\n\t\t\t\t\t\t<div class=\"form-group no-gutters col-12\">\n\t\t\t\t\t\t\t<label>Automatic Rotation</label>\n\t\t\t\t\t\t\t<div role=\"group\">\n\t\t\t\t\t\t\t\t<input-toggle\n\t\t\t\t\t\t\t\t\tclass=\"col-6\"\n\t\t\t\t\t\t\t\t\tlabel=\"SpinY\"\n\t\t\t\t\t\t\t\t\tdestinationAddress=\"autoRotateY\"\n\t\t\t\t\t\t\t\t></input-toggle><input-toggle\n\t\t\t\t\t\t\t\tclass=\"col-6\"\n\t\t\t\t\t\t\t\tlabel=\"SpinX\"\n\t\t\t\t\t\t\t\tdestinationAddress=\"autoRotateX\"\n\t\t\t\t\t\t\t></input-toggle>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"form-group no-gutters col-12\">\n\t\t\t\t\t\t\t<label>Camera Positions</label>\n\t\t\t\t\t\t\t<div role=\"group\">\n\t\t\t\t\t\t\t\t<input-button\n\t\t\t\t\t\t\t\t\tclass=\"col-6 col-lg-3\"\n\t\t\t\t\t\t\t\t\t:label=\"item\"\n\t\t\t\t\t\t\t\t\tdestinationAddress=\"cameraPosition\"\n\t\t\t\t\t\t\t\t\tv-for=\"item in settings.cameraPositionList\"\n\t\t\t\t\t\t\t\t></input-button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<input-select\n\t\t\t\t\t\t\tclass=\"col-12\"\n\t\t\t\t\t\t\tlabel=\"Background Color\"\n\t\t\t\t\t\t\t:value=\"settings.backgroundColor\"\n\t\t\t\t\t\t\t:list=\"settings.backgroundColorList\"\n\t\t\t\t\t\t\tdestinationAddress=\"backgroundColor\"\n\t\t\t\t\t\t></input-select>\n\t\t\t\t\t</div>\n\t\t\t</form>\n\t\t\t<div>\n\t\t\t\t<h5>RainbowSpace:<br />Color Gamut Visualizer</h5>\n\t\t\t\t<p>A project by <a href=\"http://nuclearpixel.com/about/\">Admiral Potato</a>.<br /><a href=\"https://github.com/AdmiralPotato/rainbowspace\">Check out the project on GitHub</a> if you have questions, comments, feedback or issues.</p>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</template>\n<script>\n\timport state from './state';\n\timport ExistingDomNode from './existing-dom-node';\n\timport InputButton from './input-button';\n\timport InputCheck from './input-check';\n\timport InputSelect from './input-select';\n\timport InputToggle from './input-toggle';\n\n\texport default {\n\t\tcomponents: {\n\t\t\tExistingDomNode,\n\t\t\tInputButton,\n\t\t\tInputCheck,\n\t\t\tInputSelect,\n\t\t\tInputToggle\n\t\t},\n\t\tprops: {\n\t\t\tsettings: Object,\n\t\t\tdataCanvas: HTMLCanvasElement\n\t\t},\n\t\tmethods: {\n\t\t\tclearAllImages: function(){\n\t\t\t\tstate.imageList = [];\n\t\t\t},\n\t\t\tuploadImage: function(changeEvent){\n\t\t\t\tlet fileList = Array.prototype.slice.call(changeEvent.target.files);\n\t\t\t\tstate.scaleImages = this.isMobile();\n\t\t\t\tfileList.forEach(function(file){\n\t\t\t\t\twindow.viewport.vue.readFile(file);\n\t\t\t\t});\n\t\t\t},\n\t\t\tisMobile: function() {\n\t\t\t\tlet result = navigator.userAgent.match(/(Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone)/i);\n\t\t\t\treturn result !== null;\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n\n\n// WEBPACK FOOTER //\n// settings.vue?5497475f","<template>\n\t<canvas\n\t\tclass=\"viewport\"\n\t\t:width=\"width\"\n\t\t:height=\"height\"\n\t\t:class=\"{clickable: clickable}\"\n\t\tv-on:mousedown=\"start\"\n\t\tv-on:mousemove=\"move\"\n\t\tv-on:mouseup=\"stop\"\n\t\tv-on:mouseout=\"stop\"\n\t\tv-on:touchstart=\"start\"\n\t\tv-on:touchmove=\"move\"\n\t\tv-on:touchend=\"stop\"\n\t></canvas>\n</template>\n<script>\n\timport state from './state';\n\timport Viewport from './viewport';\n\timport Vertifier from './vertifier';\n\timport { resizeWindowEventHandler } from './viewport.js'\n\n\texport default {\n\t\tprops: {\n\t\t\tdataCanvas: HTMLCanvasElement\n\t\t},\n\t\tdata: function(){\n\t\t\treturn {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tclickable: false\n\t\t\t};\n\t\t},\n\t\tmounted: function(){\n\t\t\tlet t = this;\n\t\t\tthis.viewport = new Viewport(this.$el, this, this.dataCanvas);\n\t\t\tlet handleAsFile = function(data){\n\t\t\t\tt.readFile(data.getAsFile());\n\t\t\t};\n\t\t\tlet searchForImage = function(data){\n\t\t\t\tdata.getAsString(function(raw){\n\t\t\t\t\tlet value = ' ' + raw.replace(/\\n/g, ' ') + ' ';\n\t\t\t\t\tlet imageTagRegexExec = /.*(\\<img.*?\\>)/i.exec(value);\n\t\t\t\t\tlet img = imageTagRegexExec && imageTagRegexExec[1] ? imageTagRegexExec[1] : null;\n\t\t\t\t\tlet srcExec = img ? /src=\"(.*?)\"/i.exec(img) : null;\n\t\t\t\t\tlet altExec = img ? /alt=\"(.*?)\"/i.exec(img) : null;\n\t\t\t\t\tlet src = srcExec ? srcExec[1] : null;\n\t\t\t\t\tlet alt = altExec ? altExec[1] : null;\n\t\t\t\t\tif(src){\n\t\t\t\t\t\tstate.imageList.push({\n\t\t\t\t\t\t\ttext: (alt || src.split('/').pop()),\n\t\t\t\t\t\t\tvalue: src\n\t\t\t\t\t\t});\n\t\t\t\t\t\tstate.image = src;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tlet supportedTypeMap = {\n\t\t\t\t\"image/png\": handleAsFile,\n\t\t\t\t\"image/jpeg\": handleAsFile,\n\t\t\t\t\"image/gif\": handleAsFile,\n\t\t\t\t\"image/bmp\": handleAsFile,\n\t\t\t\t\"image/svg+xml\": handleAsFile,\n\t\t\t\t\"text/html\": searchForImage,\n\t\t\t};\n\t\t\tthis.handleDrag = function(event){\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconsole.log(event.type);\n\t\t\t\tif(event.type === 'drop'){\n\t\t\t\t\tlet itemList = Array.prototype.slice.call(event.dataTransfer.items);\n\t\t\t\t\tlet anySuitableHandler = false;\n\t\t\t\t\tlet handleType = function(item){\n\t\t\t\t\t\tif(supportedTypeMap.hasOwnProperty(item.type)){\n\t\t\t\t\t\t\tlet handler = supportedTypeMap[item.type];\n\t\t\t\t\t\t\thandler(item);\n\t\t\t\t\t\t\tanySuitableHandler = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\titemList.forEach(handleType);\n\t\t\t\t\tif(!anySuitableHandler){\n\t\t\t\t\t\talert('Sorry, was not able to load that image - still working out all the bugs. Try an image from another source?');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.$el.addEventListener('wheel', this.handleWheel);\n\t\t\tthis.$el.addEventListener('dragover', this.handleDrag);\n\t\t\tthis.$el.addEventListener('dragenter', this.handleDrag);\n\t\t\tthis.$el.addEventListener('drop', this.handleDrag);\n\t\t},\n\t\tbeforeMount: function () {\n\t\t\tdocument.addEventListener('resize', resizeWindowEventHandler);\n\t\t\twindow.addEventListener('resize', resizeWindowEventHandler);\n\t\t},\n\t\tbeforeDestroy: function () {\n\t\t\tdocument.removeEventListener('resize', resizeWindowEventHandler);\n\t\t\twindow.removeEventListener('resize', resizeWindowEventHandler);\n\t\t\tthis.$el.removeEventListener('wheel', this.handleWheel);\n\t\t\tthis.$el.removeEventListener('dragover', this.handleDrag);\n\t\t\tthis.$el.removeEventListener('dragenter', this.handleDrag);\n\t\t\tthis.$el.removeEventListener('drop', this.handleDrag);\n\t\t},\n\t\tmethods: {\n\t\t\thandleWheel: function(event){\n\t\t\t\tthis.viewport.scroll(event.deltaX * 0.001 + event.deltaY * 0.01);\n\t\t\t},\n\t\t\treadFile: function(file){\n\t\t\t\tlet name = file.name;\n\t\t\t\tlet nameUnique = ['draggedUp', file.name, file.type, file.size, file.lastModified].join(':');\n\t\t\t\tlet imageAlreadyLoaded = Vertifier.loadedImageMap[nameUnique];\n\t\t\t\tif(imageAlreadyLoaded){\n\t\t\t\t\tconsole.log('file.alreadyLoaded', name);\n\t\t\t\t\tstate.image = nameUnique;\n\t\t\t\t} else {\n\t\t\t\t\tlet reader = new FileReader();\n\t\t\t\t\treader.onloadend = function(upload) {\n\t\t\t\t\t\tconsole.log('file.loaded', name);\n\t\t\t\t\t\tlet image = new Image();\n\t\t\t\t\t\timage.onload = function(){\n\t\t\t\t\t\t\tconsole.log('img.loaded', name);\n\t\t\t\t\t\t\tVertifier.loadedImageMap[nameUnique] = image;\n\t\t\t\t\t\t\tstate.imageList.push({\n\t\t\t\t\t\t\t\ttext: name,\n\t\t\t\t\t\t\t\tvalue: nameUnique\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tstate.image = nameUnique;\n\t\t\t\t\t\t};\n\t\t\t\t\t\timage.src = upload.target.result;\n\t\t\t\t\t};\n\t\t\t\t\treader.readAsDataURL(file);\n\t\t\t\t}\n\t\t\t},\n\t\t\tstart: function (event) {\n\t\t\t\tlet x = event.clientX;\n\t\t\t\tlet y = event.clientY;\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif(!this.viewport.dragging){\n\t\t\t\t\tif(event.targetTouches){\n\t\t\t\t\t\tx = event.targetTouches[0].clientX;\n\t\t\t\t\t\ty = event.targetTouches[0].clientY;\n\t\t\t\t\t}\n\t\t\t\t\tthis.viewport.dragStart(x, y);\n\t\t\t\t}\n\t\t\t\tstate.autoRotateY = false;\n\t\t\t\tstate.autoRotateX = false;\n\t\t\t},\n\t\t\tstop: function (event) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.viewport.dragStop();\n\t\t\t},\n\t\t\tmove: function (event) {\n\t\t\t\tif(this.viewport.dragging) {\n\t\t\t\t\tlet x = event.clientX;\n\t\t\t\t\tlet y = event.clientY;\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tif (event.targetTouches) {\n\t\t\t\t\t\tx = event.targetTouches[0].clientX;\n\t\t\t\t\t\ty = event.targetTouches[0].clientY;\n\t\t\t\t\t}\n\t\t\t\t\tthis.viewport.dragMove(x, y);\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t};\n</script>\n\n\n\n// WEBPACK FOOTER //\n// viewport.vue?5443e31e","\n/* styles */\nrequire(\"!!../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?-autoprefixer&sourceMap!../node_modules/vue-loader/lib/style-rewriter?id=data-v-70745af6!postcss-loader?sourceMap!font-awesome/css/font-awesome.css\")\nrequire(\"!!../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?-autoprefixer&sourceMap!../node_modules/vue-loader/lib/style-rewriter?id=data-v-70745af6!postcss-loader?sourceMap!bootstrap/dist/css/bootstrap.css\")\nrequire(\"!!../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?-autoprefixer&sourceMap!../node_modules/vue-loader/lib/style-rewriter?id=data-v-70745af6!postcss-loader?sourceMap!./styles.css\")\n\nvar Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./app.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-70745af6!../node_modules/vue-loader/lib/selector?type=template&index=0!./app.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app.vue\n// module id = 20\n// module chunks = 0","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./existing-dom-node.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-6ad38a13!../node_modules/vue-loader/lib/selector?type=template&index=0!./existing-dom-node.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/existing-dom-node.vue\n// module id = 21\n// module chunks = 0","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./input-check.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-4505eba9!../node_modules/vue-loader/lib/selector?type=template&index=0!./input-check.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/input-check.vue\n// module id = 22\n// module chunks = 0","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./input-select.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-1a88f2ab!../node_modules/vue-loader/lib/selector?type=template&index=0!./input-select.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/input-select.vue\n// module id = 23\n// module chunks = 0","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./input-toggle.vue\"),\n  /* template */\n  null,\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/input-toggle.vue\n// module id = 24\n// module chunks = 0","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./settings.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-59a2166f!../node_modules/vue-loader/lib/selector?type=template&index=0!./settings.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/settings.vue\n// module id = 25\n// module chunks = 0","var Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./viewport.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-4fab5972!../node_modules/vue-loader/lib/selector?type=template&index=0!./viewport.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/viewport.vue\n// module id = 26\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"form-group\"\n  }, [_c('label', {\n    attrs: {\n      \"for\": _vm.id\n    }\n  }, [_vm._v(_vm._s(_vm.label))]), _vm._v(\" \"), _c('select', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.internalValue),\n      expression: \"internalValue\"\n    }],\n    staticClass: \"form-control\",\n    attrs: {\n      \"id\": _vm.id\n    },\n    on: {\n      \"change\": [function($event) {\n        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {\n          return o.selected\n        }).map(function(o) {\n          var val = \"_value\" in o ? o._value : o.value;\n          return val\n        });\n        _vm.internalValue = $event.target.multiple ? $$selectedVal : $$selectedVal[0]\n      }, _vm.change]\n    }\n  }, _vm._l((_vm.list), function(option) {\n    return _c('option', {\n      domProps: {\n        \"value\": option.value || option\n      }\n    }, [_vm._v(_vm._s(option.text || option))])\n  }))])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-1a88f2ab!./~/vue-loader/lib/selector.js?type=template&index=0!./src/input-select.vue\n// module id = 27\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"form-check\"\n  }, [_c('label', {\n    staticClass: \"form-check-label\"\n  }, [_c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.internalValue),\n      expression: \"internalValue\"\n    }],\n    staticClass: \"form-check-input\",\n    attrs: {\n      \"type\": \"checkbox\",\n      \"id\": _vm.id\n    },\n    domProps: {\n      \"checked\": Array.isArray(_vm.internalValue) ? _vm._i(_vm.internalValue, null) > -1 : (_vm.internalValue)\n    },\n    on: {\n      \"change\": _vm.change,\n      \"__c\": function($event) {\n        var $$a = _vm.internalValue,\n          $$el = $event.target,\n          $$c = $$el.checked ? (true) : (false);\n        if (Array.isArray($$a)) {\n          var $$v = null,\n            $$i = _vm._i($$a, $$v);\n          if ($$el.checked) {\n            $$i < 0 && (_vm.internalValue = $$a.concat([$$v]))\n          } else {\n            $$i > -1 && (_vm.internalValue = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))\n          }\n        } else {\n          _vm.internalValue = $$c\n        }\n      }\n    }\n  }), _vm._v(\"\\n\\t\\t\" + _vm._s(_vm.label) + \"\\n\\t\")])])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-4505eba9!./~/vue-loader/lib/selector.js?type=template&index=0!./src/input-check.vue\n// module id = 28\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('canvas', {\n    staticClass: \"viewport\",\n    class: {\n      clickable: _vm.clickable\n    },\n    attrs: {\n      \"width\": _vm.width,\n      \"height\": _vm.height\n    },\n    on: {\n      \"mousedown\": _vm.start,\n      \"mousemove\": _vm.move,\n      \"mouseup\": _vm.stop,\n      \"mouseout\": _vm.stop,\n      \"touchstart\": _vm.start,\n      \"touchmove\": _vm.move,\n      \"touchend\": _vm.stop\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-4fab5972!./~/vue-loader/lib/selector.js?type=template&index=0!./src/viewport.vue\n// module id = 29\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"card settings\"\n  }, [_c('div', {\n    staticClass: \"card-header\"\n  }, [_vm._v(\"Settings\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"card-body\"\n  }, [_c('existingDomNode', {\n    staticClass: \"dataCanvasHolder\",\n    attrs: {\n      \"content\": _vm.dataCanvas\n    }\n  }), _vm._v(\" \"), _c('form', {\n    attrs: {\n      \"encType\": \"multipart/form-data\"\n    }\n  }, [_c('div', {\n    staticClass: \"form-group no-gutters\"\n  }, [_c('input-select', {\n    attrs: {\n      \"label\": \"Image\",\n      \"list\": _vm.settings.imageList,\n      \"value\": _vm.settings.image,\n      \"destinationAddress\": \"image\"\n    }\n  }), _vm._v(\" \"), _c('button', {\n    staticClass: \"btn btn-primary col-12\",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": _vm.clearAllImages\n    }\n  }, [_vm._v(\"Clear all\")]), _vm._v(\" \"), _c('label', {\n    staticClass: \"btn btn-primary col-12\",\n    attrs: {\n      \"for\": \"uploadImage\"\n    }\n  }, [_vm._v(\"Upload Image\")]), _vm._v(\" \"), _c('input', {\n    staticStyle: {\n      \"display\": \"none\"\n    },\n    attrs: {\n      \"type\": \"file\",\n      \"id\": \"uploadImage\"\n    },\n    on: {\n      \"change\": _vm.uploadImage\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters\"\n  }, [_c('input-select', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Display Method\",\n      \"list\": _vm.settings.displayMethodList,\n      \"value\": _vm.settings.displayMethod,\n      \"destinationAddress\": \"displayMethod\"\n    }\n  }), _vm._v(\" \"), _c('input-toggle', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Show Bounds\",\n      \"destinationAddress\": \"showBounds\"\n    }\n  })], 1), _vm._v(\" \"), _c('hr'), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters\"\n  }, [_c('input-select', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Camera Mode\",\n      \"list\": _vm.settings.cameraModeList,\n      \"value\": _vm.settings.cameraMode,\n      \"destinationAddress\": \"cameraMode\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters col-12\"\n  }, [_c('label', [_vm._v(\"Automatic Rotation\")]), _vm._v(\" \"), _c('div', {\n    attrs: {\n      \"role\": \"group\"\n    }\n  }, [_c('input-toggle', {\n    staticClass: \"col-6\",\n    attrs: {\n      \"label\": \"SpinY\",\n      \"destinationAddress\": \"autoRotateY\"\n    }\n  }), _c('input-toggle', {\n    staticClass: \"col-6\",\n    attrs: {\n      \"label\": \"SpinX\",\n      \"destinationAddress\": \"autoRotateX\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"form-group no-gutters col-12\"\n  }, [_c('label', [_vm._v(\"Camera Positions\")]), _vm._v(\" \"), _c('div', {\n    attrs: {\n      \"role\": \"group\"\n    }\n  }, _vm._l((_vm.settings.cameraPositionList), function(item) {\n    return _c('input-button', {\n      staticClass: \"col-6 col-lg-3\",\n      attrs: {\n        \"label\": item,\n        \"destinationAddress\": \"cameraPosition\"\n      }\n    })\n  }))]), _vm._v(\" \"), _c('input-select', {\n    staticClass: \"col-12\",\n    attrs: {\n      \"label\": \"Background Color\",\n      \"value\": _vm.settings.backgroundColor,\n      \"list\": _vm.settings.backgroundColorList,\n      \"destinationAddress\": \"backgroundColor\"\n    }\n  })], 1)]), _vm._v(\" \"), _vm._m(0)], 1)])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('h5', [_vm._v(\"RainbowSpace:\"), _c('br'), _vm._v(\"Color Gamut Visualizer\")]), _vm._v(\" \"), _c('p', [_vm._v(\"A project by \"), _c('a', {\n    attrs: {\n      \"href\": \"http://nuclearpixel.com/about/\"\n    }\n  }, [_vm._v(\"Admiral Potato\")]), _vm._v(\".\"), _c('br'), _c('a', {\n    attrs: {\n      \"href\": \"https://github.com/AdmiralPotato/rainbowspace\"\n    }\n  }, [_vm._v(\"Check out the project on GitHub\")]), _vm._v(\" if you have questions, comments, feedback or issues.\")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-59a2166f!./~/vue-loader/lib/selector.js?type=template&index=0!./src/settings.vue\n// module id = 30\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div')\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-6ad38a13!./~/vue-loader/lib/selector.js?type=template&index=0!./src/existing-dom-node.vue\n// module id = 31\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"h-100 container-fluid\"\n  }, [_c('div', {\n    staticClass: \"h-100 row\"\n  }, [_c('div', {\n    staticClass: \"h-100 col-12 main\",\n    class: {\n      'col-sm-8 col-xl-9': _vm.showSidebar\n    },\n    style: ({\n      'backgroundColor': 'hsl(0, 0%, ' + _vm.settings.backgroundColor + '%)'\n    })\n  }, [_c('viewport', {\n    attrs: {\n      \"dataCanvas\": _vm.dataCanvas\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    class: {\n      'sidebar h-100 col-12 col-sm-4 col-xl-3': _vm.showSidebar\n    }\n  }, [_c('div', {\n    staticClass: \"settingsToggle\"\n  }, [_c('a', {\n    staticClass: \"icon fa\",\n    class: _vm.showSidebar ? 'fa-times' : 'fa-sliders',\n    on: {\n      \"click\": _vm.settingsToggle\n    }\n  })]), _vm._v(\" \"), (_vm.showSidebar) ? _c('settings', {\n    attrs: {\n      \"settings\": _vm.settings,\n      \"dataCanvas\": _vm.dataCanvas\n    }\n  }) : _vm._e()], 1)])])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-70745af6!./~/vue-loader/lib/selector.js?type=template&index=0!./src/app.vue\n// module id = 32\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('button', {\n    staticClass: \"btn\",\n    class: _vm.classObject,\n    attrs: {\n      \"type\": \"button\"\n    },\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.displayLabel)\n    },\n    on: {\n      \"click\": _vm.click\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-dac84c3e!./~/vue-loader/lib/selector.js?type=template&index=0!./src/input-button.vue\n// module id = 33\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 34\n// module chunks = 0"],"sourceRoot":""}